##Algorithm - Two Pointers
----------------------------------------------------------
1. Container With Most Water (Question #11):
Given `n` non-negative integers `height`, where each represents a point at coordinate `(i, height[i])`, n vertical lines are drawn such that the two endpoints of the line `i` are at `(i, height[i])` and `(i, 0)`. Find two lines, which, together with the x-axis, forms a container, such that the container contains the most water.
Example:
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The maximum area is obtained by choosing the second and sixth vertical lines.

Approach :
Initialize two pointers, start and end, pointing to the first and last indices of the array.
Initialize a variable maxArea to keep track of the maximum water area encountered so far.
While the start pointer is less than the end pointer:
Calculate the current water area using the formula: area = (end - start) * min(height[start], height[end]).
Update maxArea if the current area is greater than the previous maximum.
Move the pointer that points to the smaller height inward, as moving the pointer with the larger height won't increase the area.
Repeat step 3 until the pointers meet, indicating that all possible areas have been considered.
Return the maxArea as the result.

In this solution, we iterate through the array once using the two-pointer technique, resulting in a time complexity of O(n), where n is the number of elements in the array. The space complexity is O(1) as we only use a constant amount of extra space.

Java code :

public int maxArea(int[] height) {
    int n = height.length;
    int start = 0;
    int end = n - 1;
    int maxWaterArea = Integer.MIN_VALUE;

    while (start < end) {
        int minHeight = Math.min(height[start], height[end]);
        int currWaterArea = (end - start) * minHeight;
        maxWaterArea = Math.max(maxWaterArea, currWaterArea);

        if (height[start] < height[end])
            start++;
        else 
            end--;
    }

    return maxWaterArea;
}
----------------------------------------------------------------
2. Three Sum (Question #15):
Given an array `nums` of `n` integers, find all unique triplets in the array which gives the sum of `0`.
Example:
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]

Approach:
To solve the Three Sum problem (Question #15), you can use the two-pointer technique combined with sorting the array. Here's how you can approach it:

1. Sort the given array in non-decreasing order. This step allows us to use the two-pointer technique effectively.
2. Iterate through the array from left to right, considering each element as a potential first element of the triplet.
   - Skip duplicate elements to avoid duplicate triplets.
   - For each element, set two pointers, `left` and `right`, initially pointing to the next element and the last element, respectively.
   - While `left` is less than `right`, calculate the sum of the three elements (current element + `nums[left]` + `nums[right]`).
     - If the sum is equal to zero, add the triplet `[nums[i], nums[left], nums[right]]` to the result set.
     - If the sum is less than zero, increment `left` to increase the sum.
     - If the sum is greater than zero, decrement `right` to decrease the sum.
     - Skip duplicate elements for `left` and `right` to avoid duplicate triplets.
3. Repeat step 2 until all elements have been considered as potential first elements.
4. Return the list of unique triplets that sum to zero.

In this solution, we sort the array first, which takes O(nlogn) time. Then, we iterate through the array using the two-pointer technique, resulting in a time complexity of O(n^2). The space complexity is O(1) as we only use a constant amount of extra space.

public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    if (nums.length < 3) {
        return result;
    }
    Arrays.sort(nums);
    int n = nums.length;

    for (int i = 0; i < n-2; i++){
        //Check if i is not 0 and i-1 element should not be same to i'th
        //element else skip that triplet
        if (i > 0 && nums[i] == nums[i-1]) {
            continue;
        }
        int left = i+1;
        int right = n-1;

        while (left < right) {
            int target = nums[i] + nums[left] + nums[right];
            if (target == 0) {
                result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                //avoid duplicates on left ptr
                while(left < right && nums[left] == nums[left+1]) {
                    left++;
                }

                //avoid duplicates on right ptr
                while(left < right && nums[right] == nums[right-1]) {
                    right--;
                }
                left++;
                right--;
            } else if (target < 0){
                left++;
            } else {
                right--;
            }
        }
    }
    return result;
}
----------------------------------------------------------------

3. Remove Duplicates from Sorted Array (Question #26):
Given a sorted array `nums`, remove the duplicates in-place such that each element appears only once and returns the new length.
Example:
Input: nums = [1,1,2]
Output: 2

Approach
1. Initialize two pointers, `ptr1` and `ptr2`, both initially set to 0 and 1 respectively. 
2. Iterate till ptr2 < array length
3. if nums[ptr1] == nums[ptr2] that means duplicates increment ptr2
4. if nums[ptr1] != nums[ptr2] that means distinct elements increment ptr1 and swap elements on both pointers increment both pointers
5. finally return ptr1+1 value that will be your total distinct elements

TC : O(N) - SC : O(1)

public int removeDuplicates(int[] nums) {
    if (nums.length < 2){
        return nums.length;
    }
    int n = nums.length;
    int ptr1 = 0;
    int ptr2 = 1;
    while (ptr2 < n) {
        if (nums[ptr1] == nums[ptr2]) {
            ptr2++;
        } else {
            ptr1++;
            int temp = nums[ptr2];
            nums[ptr2] = nums[ptr1];
            nums[ptr1] = temp;
            ptr2++;
        }
    }
    return ++ptr1;
}
----------------------------------------------------

4. Linked List Cycle II (Question #142):
Given a linked list, return the node where the cycle begins. If there is no cycle, return `null`.
Example:
Input: head = [3,2,0,-4], pos = 1
Output: the node with value 2
Explanation: There is a cycle in the linked list, where the tail connects to the second node.

To solve the Linked List Cycle II problem (Question #142), you can use the Floyd's Tortoise and Hare algorithm, also known as the "fast and slow pointers" technique. Here's how you can approach it:

1. Initialize two pointers, `slow` and `fast`, both initially set to the head of the linked list.
2. Move `slow` one step at a time and `fast` two steps at a time through the linked list.
3. Continue moving the pointers until they meet or `fast` reaches the end of the linked list (i.e., it becomes `null`).
   - If `fast` becomes `null`, it means there is no cycle in the linked list. Return `null`.
   - If `slow` and `fast` meet, it indicates the presence of a cycle in the linked list.
4. Reset the `slow` pointer to the head of the linked list and keep `fast` at the meeting point.
5. Move both pointers one step at a time until they meet again. The meeting point will be the start of the cycle.
6. Return the node at which the cycle starts.


Proof : 

1. Once the `fast` and `slow` pointers meet inside the cycle, let's say the distance from the head of the linked list to the start of the cycle is `D`, and the distance from the start of the cycle to the meeting point of the two pointers is `K`.

2. When the `fast` pointer catches up to the `slow` pointer, it has traveled twice the distance as the `slow` pointer. Therefore, the `fast` pointer has traveled a total distance of `D + K + C` (where `C` represents the number of complete cycles the `fast` pointer made within the cycle), while the `slow` pointer has traveled a distance of `D + K`.

3. Since the `fast` pointer moves twice as fast as the `slow` pointer, we can express their respective distances as follows: `2(D + K) = D + K + C`, which simplifies to `D + K = C`. This equation tells us that the distance from the head of the linked list to the start of the cycle is equal to the number of complete cycles within the cycle.

4. By resetting the `slow` pointer to the head of the linked list and keeping the `fast` pointer at the meeting point, and then moving both pointers one step at a time, the `slow` pointer will travel a distance of `D` to reach the start of the cycle, while the `fast` pointer will travel a distance of `C` within the cycle.

5. As the `slow` and `fast` pointers continue moving, they will eventually meet again at the start of the cycle. This is because the `slow` pointer has traveled a distance of `D`, while the `fast` pointer has traveled a distance of `C`, and we know from step 3 that `D` is equal to `C`.

In this solution, we use two pointers to detect the cycle and find the node where the cycle starts. The time complexity of this algorithm is O(n), where n is the number of nodes in the linked list. The space complexity is O(1) as we only use a constant amount of extra space.

Code : 
public ListNode detectCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;

    while(fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (fast == slow){
            break;
        }
    }

    if (fast == null || fast.next == null){
        return null;
    }

    slow = head;

    while (slow != fast) {
        slow = slow.next;
        fast = fast.next;
    }

    return slow;
}
-------------------------------------------------------------
5. Reverse Linked List II (Question #92):
Reverse a linked list from position `m` to `n`. Do it in one-pass and without using extra memory.
Example:
Input: 1 -> 2 -> 3 -> 4 -> 5, m = 2, n = 4
Output: 1 -> 4 -> 3 -> 2 -> 5

--------------------------------------------------------------

6. Longest Palindromic Substring (Question #5):
Given a string `s`, return the longest palindromic substring in `s`.
Example:
Input: "babad"
Output: "bab" or "aba"

class Solution {
    int totalSubStringLength = 0;
    int startPoint = 0;

    public String longestPalindrome(String s) {
        int n = s.length();

        // Iterate through each character of the input string
        for (int i = 0; i < n; i++) {
            findPalindrome(s, i, i);      // Consider current character as the center of a palindrome with an odd length
            findPalindrome(s, i, i+1);    // Consider current character and the next character as the center of a palindrome with an even length
        }

        // Return the longest palindromic substring using the startPoint and totalSubStringLength variables
        return s.substring(startPoint, startPoint + totalSubStringLength);
    }

    public void findPalindrome(String s, int start, int end) {
        // Expand around the center indices until the characters are equal or the boundary is reached
        while (start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end)) {
            start--;
            end++;
        }

        // Check if the length of the current palindrome is greater than the stored length
        if (totalSubStringLength < end - start - 1) {
            startPoint = start + 1;                          // Update the starting index of the longest palindrome
            totalSubStringLength = end - start - 1;          // Update the length of the longest palindrome
        }
    }
}

1. The class defines two member variables: `totalSubStringLength` and `startPoint`.
   - `totalSubStringLength` stores the length of the longest palindromic substring found so far.
   - `startPoint` stores the starting index of the longest palindromic substring found so far.

2. The `longestPalindrome` method takes the input string `s` and returns the longest palindromic substring in `s`.

3. The method initializes `totalSubStringLength` and `startPoint` to 0.

4. The method iterates through each character of the input string `s` using a `for` loop.

5. For each character at index `i`, the method calls the `findPalindrome` method twice:
   - The first call considers the current character as the center of a palindrome with an odd length.
   - The second call considers the current character and the next character as the center of a palindrome with an even length.

6. The `findPalindrome` method is responsible for expanding around the center indices to find the length of the palindrome.

7. The `findPalindrome` method uses a `while` loop to expand the palindrome by checking if the characters at indices `start` and `end` are equal. It continues expanding as long as the characters are equal and there are characters available on both sides.

8. After the `while` loop, the `findPalindrome` method checks if the length of the current palindrome (given by `end - start - 1`) is greater than the stored length (`totalSubStringLength`).

9. If the length of the current palindrome is indeed longer, the `findPalindrome` method updates `startPoint` with the new starting index (`start + 1`) and `totalSubStringLength` with the new length (`end - start - 1`).

10. The `longestPalindrome` method returns the substring of `s` starting from `startPoint` and with a length of `totalSubStringLength`, representing the longest palindromic substring found in the input string.

The provided code is another valid implementation for finding the Longest Palindromic Substring. Here's an explanation of the code, with a focus on the specific block you mentioned:

```java
if (totalSubStringLength < end - start - 1) {
    startPoint = start + 1;
    totalSubStringLength = end - start - 1;
}
```

This block of code is responsible for updating the variables `startPoint` and `totalSubStringLength` when a longer palindromic substring is found.

- `totalSubStringLength` keeps track of the length of the longest palindromic substring found so far.
- `startPoint` stores the starting index of the longest palindromic substring found so far.

Here's how the block works:

1. The block is inside the `findPalindrome` method, which is called for each character in the string `s`.

2. The `while` loop inside `findPalindrome` expands the palindromic substring by checking if the characters at indices `start` and `end` are equal. It continues expanding as long as the characters are equal and there are characters available on both sides.

3. After the `while` loop, the block checks if the length of the current palindrome (given by `end - start - 1`) is greater than the stored length (`totalSubStringLength`).

4. If the length of the current palindrome is indeed longer, the block updates `startPoint` with the new starting index (`start + 1`) and `totalSubStringLength` with the new length (`end - start - 1`).

By updating these variables, the block ensures that `startPoint` and `totalSubStringLength` always store the starting index and length of the longest palindromic substring found so far during the iterations.

After the iterations are complete, the `longestPalindrome` method returns the substring of `s` starting from `startPoint` and with a length of `totalSubStringLength`, representing the longest palindromic substring found in the input string.


Time complexity Explanation

1. The `longestPalindrome` method contains a `for` loop that iterates through each character of the input string. Since there are n characters in the string, this loop has a time complexity of O(n).

2. Inside the `for` loop, the `findPalindrome` method is called twice for each character. This results in a nested loop structure where, in the worst case, each iteration of the outer loop triggers a loop iteration in the `findPalindrome` method.

3. The `findPalindrome` method contains a `while` loop that expands around the center indices until the characters are no longer equal or the boundary of the string is reached. This expansion process has a time complexity of O(n) in the worst case, where n is the length of the string.

4. Since the `findPalindrome` method is called twice for each character in the `longestPalindrome` method, and the expansion process within each call has a time complexity of O(n), the overall time complexity of the `longestPalindrome` method is O(n * n) = O(n^2).

Therefore, the overall time complexity of the provided `Solution` class is O(n^2), where n is the length of the input string `s`.

--------------------------------------------------------------

7. Merge Intervals (Question #56):
Given an array of intervals `intervals` where `intervals[i] = [start_i, end_i]`, merge all overlapping intervals.
Example:
Input: [[1, 3], [2, 6], [8, 10], [15, 18]]
Output: [[1, 6], [8, 10], [15, 18]]

--------------------------------------------------------------

8. Valid Parentheses (Question #20):
Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['`, `']'`, determine if the input string is valid.
Example:
Input: "{[]}"
Output: true

--------------------------------------------------------------

9. Minimum Window Substring (Question #76):
Given two strings `s` and `t`, return the minimum window in `s` which will contain all the characters in `t` in complexity `O(n)`.
Example:
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"

--------------------------------------------------------------

10. Remove Element (Question #27):
Given an array `nums` and a value `val`, remove all instances of that value in-place and return the new length.
Example:
Input: nums = [3, 2, 2, 3], val = 3
Output: 2

--------------------------------------------------------------

11. Find the Index of the First Occurrence in a String (Question #28):
Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Example:
Input: haystack = "hello", needle = "ll"
Output: 2

--------------------------------------------------------------

12. Next Permutation (Question #31):
Implement `next permutation`, which rearranges numbers into the lexicographically next greater permutation of numbers.
Example:
Input: nums = [1, 2, 3]
Output: [1, 3, 2]

--------------------------------------------------------------

13. Remove Nth Node From End of List (Question #19):
Given the `head` of a linked list, remove the `nth` node from the end of the list and return its head.
Example:
Input: 1 -> 2 -> 3 -> 4 -> 5, n = 2
Output: 1 -> 2 -> 3 -> 5

--------------------------------------------------------------

14. Rotate Array (Question #189):
Given an array, rotate the array to the right by `k` steps, where `k` is non-negative.
Example:
Input: nums = [1, 2, 3, 4, 5, 6, 7], k = 3
Output: [5, 6, 7, 1, 2, 3, 4]

--------------------------------------------------------------


##HashMap

1. Two Sum (Question #1):
Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.
Example:
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: The sum of 2 and 7 equals 9, so the output is [0,1].

public int[] twoSum(int[] nums, int target) {
    HashMap<Integer, Integer> map = new HashMap<>();

    for (int i = 0; i < nums.length; i++){
        int complement = target - nums[i];
        if (map.containsKey(complement)){
            return new int[] {map.get(complement), i};
        }
        map.put(nums[i], i);
    }
    return new int[]{};
}
