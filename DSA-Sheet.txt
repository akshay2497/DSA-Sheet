##Algorithm - Two Pointers
----------------------------------------------------------
1. Container With Most Water (Question #11):
Given `n` non-negative integers `height`, where each represents a point at coordinate `(i, height[i])`, n vertical lines are drawn such that the two endpoints of the line `i` are at `(i, height[i])` and `(i, 0)`. Find two lines, which, together with the x-axis, forms a container, such that the container contains the most water.
Example:
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The maximum area is obtained by choosing the second and sixth vertical lines.

Approach :
Initialize two pointers, start and end, pointing to the first and last indices of the array.
Initialize a variable maxArea to keep track of the maximum water area encountered so far.
While the start pointer is less than the end pointer:
Calculate the current water area using the formula: area = (end - start) * min(height[start], height[end]).
Update maxArea if the current area is greater than the previous maximum.
Move the pointer that points to the smaller height inward, as moving the pointer with the larger height won't increase the area.
Repeat step 3 until the pointers meet, indicating that all possible areas have been considered.
Return the maxArea as the result.

In this solution, we iterate through the array once using the two-pointer technique, resulting in a time complexity of O(n), where n is the number of elements in the array. The space complexity is O(1) as we only use a constant amount of extra space.

Java code :

public int maxArea(int[] height) {
    int n = height.length;
    int start = 0;
    int end = n - 1;
    int maxWaterArea = Integer.MIN_VALUE;

    while (start < end) {
        int minHeight = Math.min(height[start], height[end]);
        int currWaterArea = (end - start) * minHeight;
        maxWaterArea = Math.max(maxWaterArea, currWaterArea);

        if (height[start] < height[end])
            start++;
        else 
            end--;
    }

    return maxWaterArea;
}
----------------------------------------------------------------
2. Three Sum (Question #15):
Given an array `nums` of `n` integers, find all unique triplets in the array which gives the sum of `0`.
Example:
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]

Approach:
To solve the Three Sum problem (Question #15), you can use the two-pointer technique combined with sorting the array. Here's how you can approach it:

1. Sort the given array in non-decreasing order. This step allows us to use the two-pointer technique effectively.
2. Iterate through the array from left to right, considering each element as a potential first element of the triplet.
   - Skip duplicate elements to avoid duplicate triplets.
   - For each element, set two pointers, `left` and `right`, initially pointing to the next element and the last element, respectively.
   - While `left` is less than `right`, calculate the sum of the three elements (current element + `nums[left]` + `nums[right]`).
     - If the sum is equal to zero, add the triplet `[nums[i], nums[left], nums[right]]` to the result set.
     - If the sum is less than zero, increment `left` to increase the sum.
     - If the sum is greater than zero, decrement `right` to decrease the sum.
     - Skip duplicate elements for `left` and `right` to avoid duplicate triplets.
3. Repeat step 2 until all elements have been considered as potential first elements.
4. Return the list of unique triplets that sum to zero.

In this solution, we sort the array first, which takes O(nlogn) time. Then, we iterate through the array using the two-pointer technique, resulting in a time complexity of O(n^2). The space complexity is O(1) as we only use a constant amount of extra space.

public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    if (nums.length < 3) {
        return result;
    }
    Arrays.sort(nums);
    int n = nums.length;

    for (int i = 0; i < n-2; i++){
        //Check if i is not 0 and i-1 element should not be same to i'th
        //element else skip that triplet
        if (i > 0 && nums[i] == nums[i-1]) {
            continue;
        }
        int left = i+1;
        int right = n-1;

        while (left < right) {
            int target = nums[i] + nums[left] + nums[right];
            if (target == 0) {
                result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                //avoid duplicates on left ptr
                while(left < right && nums[left] == nums[left+1]) {
                    left++;
                }

                //avoid duplicates on right ptr
                while(left < right && nums[right] == nums[right-1]) {
                    right--;
                }
                left++;
                right--;
            } else if (target < 0){
                left++;
            } else {
                right--;
            }
        }
    }
    return result;
}
----------------------------------------------------------------

3. Remove Duplicates from Sorted Array (Question #26):
Given a sorted array `nums`, remove the duplicates in-place such that each element appears only once and returns the new length.
Example:
Input: nums = [1,1,2]
Output: 2

Approach
1. Initialize two pointers, `ptr1` and `ptr2`, both initially set to 0 and 1 respectively. 
2. Iterate till ptr2 < array length
3. if nums[ptr1] == nums[ptr2] that means duplicates increment ptr2
4. if nums[ptr1] != nums[ptr2] that means distinct elements increment ptr1 and swap elements on both pointers increment both pointers
5. finally return ptr1+1 value that will be your total distinct elements

TC : O(N) - SC : O(1)

public int removeDuplicates(int[] nums) {
    if (nums.length < 2){
        return nums.length;
    }
    int n = nums.length;
    int ptr1 = 0;
    int ptr2 = 1;
    while (ptr2 < n) {
        if (nums[ptr1] == nums[ptr2]) {
            ptr2++;
        } else {
            ptr1++;
            int temp = nums[ptr2];
            nums[ptr2] = nums[ptr1];
            nums[ptr1] = temp;
            ptr2++;
        }
    }
    return ++ptr1;
}
----------------------------------------------------

4. Linked List Cycle II (Question #142):
Given a linked list, return the node where the cycle begins. If there is no cycle, return `null`.
Example:
Input: head = [3,2,0,-4], pos = 1
Output: the node with value 2
Explanation: There is a cycle in the linked list, where the tail connects to the second node.

To solve the Linked List Cycle II problem (Question #142), you can use the Floyd's Tortoise and Hare algorithm, also known as the "fast and slow pointers" technique. Here's how you can approach it:

1. Initialize two pointers, `slow` and `fast`, both initially set to the head of the linked list.
2. Move `slow` one step at a time and `fast` two steps at a time through the linked list.
3. Continue moving the pointers until they meet or `fast` reaches the end of the linked list (i.e., it becomes `null`).
   - If `fast` becomes `null`, it means there is no cycle in the linked list. Return `null`.
   - If `slow` and `fast` meet, it indicates the presence of a cycle in the linked list.
4. Reset the `slow` pointer to the head of the linked list and keep `fast` at the meeting point.
5. Move both pointers one step at a time until they meet again. The meeting point will be the start of the cycle.
6. Return the node at which the cycle starts.


Proof : 

1. Once the `fast` and `slow` pointers meet inside the cycle, let's say the distance from the head of the linked list to the start of the cycle is `D`, and the distance from the start of the cycle to the meeting point of the two pointers is `K`.

2. When the `fast` pointer catches up to the `slow` pointer, it has traveled twice the distance as the `slow` pointer. Therefore, the `fast` pointer has traveled a total distance of `D + K + C` (where `C` represents the number of complete cycles the `fast` pointer made within the cycle), while the `slow` pointer has traveled a distance of `D + K`.

3. Since the `fast` pointer moves twice as fast as the `slow` pointer, we can express their respective distances as follows: `2(D + K) = D + K + C`, which simplifies to `D + K = C`. This equation tells us that the distance from the head of the linked list to the start of the cycle is equal to the number of complete cycles within the cycle.

4. By resetting the `slow` pointer to the head of the linked list and keeping the `fast` pointer at the meeting point, and then moving both pointers one step at a time, the `slow` pointer will travel a distance of `D` to reach the start of the cycle, while the `fast` pointer will travel a distance of `C` within the cycle.

5. As the `slow` and `fast` pointers continue moving, they will eventually meet again at the start of the cycle. This is because the `slow` pointer has traveled a distance of `D`, while the `fast` pointer has traveled a distance of `C`, and we know from step 3 that `D` is equal to `C`.

In this solution, we use two pointers to detect the cycle and find the node where the cycle starts. The time complexity of this algorithm is O(n), where n is the number of nodes in the linked list. The space complexity is O(1) as we only use a constant amount of extra space.

Code : 
public ListNode detectCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;

    while(fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (fast == slow){
            break;
        }
    }

    if (fast == null || fast.next == null){
        return null;
    }

    slow = head;

    while (slow != fast) {
        slow = slow.next;
        fast = fast.next;
    }

    return slow;
}
-------------------------------------------------------------
5. Reverse Linked List II (Question #92):
Reverse a linked list from position `m` to `n`. Do it in one-pass and without using extra memory.
Example:
Input: 1 -> 2 -> 3 -> 4 -> 5, m = 2, n = 4
Output: 1 -> 4 -> 3 -> 2 -> 5

--------------------------------------------------------------

6. Longest Palindromic Substring (Question #5):
Given a string `s`, return the longest palindromic substring in `s`.
Example:
Input: "babad"
Output: "bab" or "aba"

class Solution {
    int totalSubStringLength = 0;
    int startPoint = 0;

    public String longestPalindrome(String s) {
        int n = s.length();

        // Iterate through each character of the input string
        for (int i = 0; i < n; i++) {
            findPalindrome(s, i, i);      // Consider current character as the center of a palindrome with an odd length
            findPalindrome(s, i, i+1);    // Consider current character and the next character as the center of a palindrome with an even length
        }

        // Return the longest palindromic substring using the startPoint and totalSubStringLength variables
        return s.substring(startPoint, startPoint + totalSubStringLength);
    }

    public void findPalindrome(String s, int start, int end) {
        // Expand around the center indices until the characters are equal or the boundary is reached
        while (start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end)) {
            start--;
            end++;
        }

        // Check if the length of the current palindrome is greater than the stored length
        if (totalSubStringLength < end - start - 1) {
            startPoint = start + 1;                          // Update the starting index of the longest palindrome
            totalSubStringLength = end - start - 1;          // Update the length of the longest palindrome
        }
    }
}

1. The class defines two member variables: `totalSubStringLength` and `startPoint`.
   - `totalSubStringLength` stores the length of the longest palindromic substring found so far.
   - `startPoint` stores the starting index of the longest palindromic substring found so far.

2. The `longestPalindrome` method takes the input string `s` and returns the longest palindromic substring in `s`.

3. The method initializes `totalSubStringLength` and `startPoint` to 0.

4. The method iterates through each character of the input string `s` using a `for` loop.

5. For each character at index `i`, the method calls the `findPalindrome` method twice:
   - The first call considers the current character as the center of a palindrome with an odd length.
   - The second call considers the current character and the next character as the center of a palindrome with an even length.

6. The `findPalindrome` method is responsible for expanding around the center indices to find the length of the palindrome.

7. The `findPalindrome` method uses a `while` loop to expand the palindrome by checking if the characters at indices `start` and `end` are equal. It continues expanding as long as the characters are equal and there are characters available on both sides.

8. After the `while` loop, the `findPalindrome` method checks if the length of the current palindrome (given by `end - start - 1`) is greater than the stored length (`totalSubStringLength`).

9. If the length of the current palindrome is indeed longer, the `findPalindrome` method updates `startPoint` with the new starting index (`start + 1`) and `totalSubStringLength` with the new length (`end - start - 1`).

10. The `longestPalindrome` method returns the substring of `s` starting from `startPoint` and with a length of `totalSubStringLength`, representing the longest palindromic substring found in the input string.

The provided code is another valid implementation for finding the Longest Palindromic Substring. Here's an explanation of the code, with a focus on the specific block you mentioned:

```java
if (totalSubStringLength < end - start - 1) {
    startPoint = start + 1;
    totalSubStringLength = end - start - 1;
}
```

This block of code is responsible for updating the variables `startPoint` and `totalSubStringLength` when a longer palindromic substring is found.

- `totalSubStringLength` keeps track of the length of the longest palindromic substring found so far.
- `startPoint` stores the starting index of the longest palindromic substring found so far.

Here's how the block works:

1. The block is inside the `findPalindrome` method, which is called for each character in the string `s`.

2. The `while` loop inside `findPalindrome` expands the palindromic substring by checking if the characters at indices `start` and `end` are equal. It continues expanding as long as the characters are equal and there are characters available on both sides.

3. After the `while` loop, the block checks if the length of the current palindrome (given by `end - start - 1`) is greater than the stored length (`totalSubStringLength`).

4. If the length of the current palindrome is indeed longer, the block updates `startPoint` with the new starting index (`start + 1`) and `totalSubStringLength` with the new length (`end - start - 1`).

By updating these variables, the block ensures that `startPoint` and `totalSubStringLength` always store the starting index and length of the longest palindromic substring found so far during the iterations.

After the iterations are complete, the `longestPalindrome` method returns the substring of `s` starting from `startPoint` and with a length of `totalSubStringLength`, representing the longest palindromic substring found in the input string.


Time complexity Explanation

1. The `longestPalindrome` method contains a `for` loop that iterates through each character of the input string. Since there are n characters in the string, this loop has a time complexity of O(n).

2. Inside the `for` loop, the `findPalindrome` method is called twice for each character. This results in a nested loop structure where, in the worst case, each iteration of the outer loop triggers a loop iteration in the `findPalindrome` method.

3. The `findPalindrome` method contains a `while` loop that expands around the center indices until the characters are no longer equal or the boundary of the string is reached. This expansion process has a time complexity of O(n) in the worst case, where n is the length of the string.

4. Since the `findPalindrome` method is called twice for each character in the `longestPalindrome` method, and the expansion process within each call has a time complexity of O(n), the overall time complexity of the `longestPalindrome` method is O(n * n) = O(n^2).

Therefore, the overall time complexity of the provided `Solution` class is O(n^2), where n is the length of the input string `s`.

--------------------------------------------------------------

7. Merge Intervals (Question #56):
Given an array of intervals `intervals` where `intervals[i] = [start_i, end_i]`, merge all overlapping intervals.
Example:
Input: [[1, 3], [2, 6], [8, 10], [15, 18]]
Output: [[1, 6], [8, 10], [15, 18]]

Solution:

1. Sort the intervals based on the starting points. This ensures that overlapping intervals will be adjacent to each other after sorting.

2. Initialize an empty list to store the merged intervals.

3. Iterate through the sorted intervals. For each interval, check if it overlaps with the previous merged interval or if it is non-overlapping.

4. If the current interval overlaps with the previous merged interval, update the end point of the merged interval if necessary to include the current interval.

5. If the current interval is non-overlapping, add the previous merged interval to the result list and set the current interval as the new merged interval.

6. After iterating through all intervals, add the last merged interval to the result list.

7. Return the result list containing the merged intervals.

```java
public int[][] merge(int[][] intervals) {
    if (intervals == null || intervals.length == 0) {
        return new int[0][];
    }

    // Sort the intervals based on the starting points
    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

    List<int[]> mergedIntervals = new ArrayList<>();
    int[] currentInterval = intervals[0];

    // Iterate through the sorted intervals
    for (int i = 1; i < intervals.length; i++) {
        int[] interval = intervals[i];

        // If the current interval overlaps with the previous merged interval, update the end point if necessary
        if (interval[0] <= currentInterval[1]) {
            currentInterval[1] = Math.max(currentInterval[1], interval[1]);
        }
        // If the current interval is non-overlapping, add the previous merged interval to the result list
        else {
            mergedIntervals.add(currentInterval);
            currentInterval = interval;
        }
    }

    // Add the last merged interval to the result list
    mergedIntervals.add(currentInterval);

    // Convert the list to a 2D array
    int[][] result = new int[mergedIntervals.size()][2];
    for (int i = 0; i < mergedIntervals.size(); i++) {
        result[i] = mergedIntervals.get(i);
    }

    return result;
}
```

Time and Space complexity:
The time complexity of this solution is O(n log n), where n is the number of intervals. The sorting step takes O(n log n) time, and the merging step iterates through the sorted intervals once, which takes O(n) time. The space complexity is O(n) as we store the merged intervals in a list.

--------------------------------------------------------------

8. Valid Parentheses (Question #20):
Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['`, `']'`, determine if the input string is valid.
Example:
Input: "{[]}"
Output: true

Solution:

1. The `isValid` method takes a string `s` as input and returns a boolean value indicating whether the parentheses in `s` are valid.

2. The method initializes a `Stack` data structure named `stack` to keep track of the opening parentheses encountered.

3. It also initializes a variable `n` with the length of the input string `s`.

4. The method iterates through each character of the input string using a `for` loop.

5. For each character, the method checks if it is an opening parenthesis (`(`, `[`, `{`). If so, it pushes the character onto the stack.

6. If the character is a closing parenthesis (`)`, `]`, `}`), the method checks if the stack is empty. If it is, this means there is no matching opening parenthesis for the current closing parenthesis, so the string is invalid, and the method returns `false`.

7. If the stack is not empty, the method pops the top character from the stack and compares it with the current closing parenthesis. If they do not match, this means the parentheses are not in the correct order, and the method returns `false`.

8. If all parentheses are matched and valid, the method continues the loop until all characters in the string are processed.

9. After the loop, the method checks if there are any remaining opening parentheses in the stack. If there are, this means the string is invalid because some opening parentheses were not closed, and the method returns `false`. Otherwise, it returns `true`.

The code follows a straightforward approach using a stack to track the opening parentheses encountered. It compares each closing parenthesis with the top of the stack to ensure that they match. If the stack is empty or the parentheses do not match, it returns `false`. Otherwise, if all parentheses are valid, it returns `true`.

Time and Space complexity :

The time complexity of this implementation is O(n), where n is the length of the input string `s`, as we iterate through each character once. The space complexity is O(n) as we use a stack to store opening parentheses, and in the worst case, all characters in `s` could be opening parentheses.

```Java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();

        int n = s.length();

        for (int i = 0; i < n; i++) {
            char currChar = s.charAt(i);

            if (currChar == '(' || currChar == '[' || currChar == '{') {
                stack.push(currChar);
            } else {
                if (stack.isEmpty()){
                    return false;
                }
                char poppedChar = stack.pop();
                if (currChar == ')' && poppedChar != '('){
                    return false;
                } else if (currChar == ']' && poppedChar != '[') {
                    return false;
                } else if (currChar == '}' && poppedChar != '{'){
                    return false;
                }
            }
        }
        return stack.size() > 0 ? false : true;
    }
}
```

--------------------------------------------------------------

9. Minimum Window Substring (Question #76):
Given two strings `s` and `t`, return the minimum window in `s` which will contain all the characters in `t` in complexity `O(n)`.
Example:
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"

Solution:

1. Initialize two pointers, `left` and `right`, to track the window boundaries. Set them both to 0 initially.

2. Create two frequency maps, `targetMap` and `windowMap`, to track the character frequencies of the target string `t` and the current window in string `s`, respectively. Initially, both maps should be empty.

3. Populate the `targetMap` by iterating through the characters of string `t`. For each character, update its frequency in the map.

4. Initialize variables to track the minimum window length (`minWindowLength`), the starting index of the minimum window (`minWindowStart`), and a counter to keep track of the characters in `t` that have been matched in the current window (`matchedCount`). Set the `matchedCount` to 0 initially.

5. Start iterating through the string `s` using the `right` pointer:
   - For each character encountered, update its frequency in the `windowMap`.
   - If the character is present in the `targetMap` and its frequency in the `windowMap` is less than or equal to its frequency in the `targetMap`, increment the `matchedCount` by 1.

6. Check if all characters in `t` have been matched in the current window:
   - If the `matchedCount` is equal to the length of the target string `t`, it means all characters in `t` have been matched. In this case, we have found a valid window.
   - Update the minimum window length and the starting index of the minimum window if necessary.

7. Shrink the window by moving the `left` pointer:
   - While the `left` pointer can be moved and the current window still contains all characters from `t`, update the `windowMap` and `matchedCount` accordingly.
   - Check if the updated window is still valid (contains all characters from `t`).
   - If the updated window is still valid, update the minimum window length and the starting index of the minimum window if necessary.

8. Repeat steps 5 to 7 until the `right` pointer reaches the end of the string `s`.

9. After the loop, check if a valid window was found. If so, return the substring of `s` that corresponds to the minimum window length, starting from the `minWindowStart` index. Otherwise, return an empty string.

Code:

```java
public String minWindow(String s, String t) {
    HashMap<Character, Integer> targetMap = new HashMap<>(); // Frequency map for target string t
    HashMap<Character, Integer> windowMap = new HashMap<>(); // Frequency map for current window in s

    // Populate the targetMap with character frequencies from string t
    for (char ch : t.toCharArray()) {
        targetMap.put(ch, targetMap.getOrDefault(ch, 0) + 1);
    }

    int left = 0;                  // Left pointer of the window
    int right = 0;                 // Right pointer of the window
    int minWindowStart = 0;        // Starting index of the minimum window
    int minWindowLength = Integer.MAX_VALUE; // Minimum window length
    int matchedCount = 0;          // Counter to track matched characters

    // Iterate through the string s using the right pointer
    while (right < s.length()) {
        char rightChar = s.charAt(right);
        windowMap.put(rightChar, windowMap.getOrDefault(rightChar, 0) + 1); // Update the frequency of the character in the window map

        // If the current character is present in targetMap and its frequency in the window map is <= its frequency in targetMap
        if (targetMap.containsKey(rightChar) && windowMap.get(rightChar) <= targetMap.get(rightChar)) {
            matchedCount++; // Increment matchedCount as a character from t is matched
        }

        // Check if all characters from t have been matched in the current window
        while (matchedCount == t.length()) {
            // Update the minimum window length and starting index if necessary
            if (right - left + 1 < minWindowLength) {
                minWindowLength = right - left + 1;
                minWindowStart = left;
            }

            // Shrink the window from the left side
            char leftChar = s.charAt(left);
            windowMap.put(leftChar, windowMap.get(leftChar) - 1); // Update the frequency of the character in the window map

            // If the current character was one of the characters from t, decrement the matchedCount
            if (targetMap.containsKey(leftChar) && windowMap.get(leftChar) < targetMap.get(leftChar)) {
                matchedCount--;
            }

            left++; // Move the left pointer to shrink the window
        }

        right++; // Move the right pointer to expand the window
    }

    // Check if a valid window was found
    if (minWindowLength != Integer.MAX_VALUE) {
        return s.substring(minWindowStart, minWindowStart + minWindowLength);
    } else {
        return "";
    }
}
```

Time and Space Complexity :

The time complexity of this solution is O(n), where n is the length of the string `s`. The two pointers, `left` and `right`, traverse the string `s` only once. Additionally, the frequency maps and comparisons have constant time complexity since the number of characters is limited (128 ASCII characters). Therefore, the overall time complexity is linear, meeting the complexity requirement of O(n).

--------------------------------------------------------------

10. Remove Element (Question #27):
Given an array `nums` and a value `val`, remove all instances of that value in-place and return the new length.
Example:
Input: nums = [3, 2, 2, 3], val = 3
Output: 2

Solution:
In this solution, we use two pointers: `left` and `right`. The `left` pointer keeps track of the position where the non-val elements should be placed, and the `right` pointer iterates through the array to check each element.

The algorithm works as follows:

1. Initialize the `left` and `right` pointers to 0.
2. Iterate through the array with the `right` pointer.
3. If the element at the `right` pointer is not equal to `val`, it is a non-val element.
   - Assign the non-val element to the `left` pointer position in the array.
   - Increment the `left` pointer.
4. Increment the `right` pointer.
5. Repeat steps 3-4 until the end of the array.
6. Return the value of `left`, which represents the count of elements in `nums` that are not equal to `val`.

The time complexity of this solution is O(n), where n is the length of the input array `nums`. The algorithm iterates through the array only once, making it efficient.

TC = O(N) SC = O(1)

Code:
```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int left = 0; // Left pointer
        int right = 0; // Right pointer

        while (right < nums.length) {
            if (nums[right] != val) {
                nums[left] = nums[right];
                left++;
            }
            right++;
        }

        return left;
    }
}
```

--------------------------------------------------------------

11. Find the Index of the First Occurrence in a String (Question #28):
Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Example:
Input: haystack = "hello", needle = "ll"
Output: 2

Solution:
In this solution, we use two pointers: `i` for haystack and `j` for needle. The algorithm iterates through the haystack, comparing the characters with the needle.

The algorithm works as follows:

1. Check if the needle is empty. If so, it is always present at index 0 in haystack, so we return 0.
2. Set the lengths of the haystack and needle to variables `m` and `n`, respectively.
3. Iterate through the haystack from index 0 to index `m - n`.
4. Check if the current character in haystack matches the first character in needle.
5. If there's a match, store the starting index in the variable `start`.
6. Check if the remaining characters in haystack match the corresponding characters in needle.
7. If all characters in needle have matched, return the starting index `start` as the first occurrence of needle in haystack.
8. If not all characters have matched, reset the `i` pointer to the `start` index for the next iteration.
9. Repeat steps 4-8 until the end of the haystack is reached.
10. If needle is not part of haystack, return -1.

The time complexity of this solution is O((m-n) * n), where `m` is the length of the haystack and `n` is the length of the needle. In the worst case, the algorithm will compare each character in the haystack with the needle.

TC = O(N)

Code:

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle.isEmpty()) {
            return 0; // If needle is empty, it is always present at index 0 in haystack
        }
        
        int m = haystack.length();
        int n = needle.length();
        
        for (int i = 0; i <= m - n; i++) {
            int j = 0; // Needle pointer
            
            // Check if the current character in haystack matches the first character in needle
            if (haystack.charAt(i) == needle.charAt(j)) {
                int start = i; // Store the starting index in haystack
                
                // Check if the remaining characters in haystack match the corresponding characters in needle
                while (j < n && i < m && haystack.charAt(i) == needle.charAt(j)) {
                    i++;
                    j++;
                }
                
                // If j reaches the end of needle, it means all characters have matched
                if (j == n) {
                    return start; // Return the starting index of the first occurrence of needle in haystack
                }
                
                // Reset i to the starting index in haystack for the next iteration
                i = start;
            }
        }
        
        return -1; // Needle is not part of haystack
    }
}
```

--------------------------------------------------------------

12. Next Permutation (Question #31):
Implement `next permutation`, which rearranges numbers into the lexicographically next greater permutation of numbers.
Example:
Input: nums = [1, 2, 3]
Output: [1, 3, 2]

--------------------------------------------------------------

13. Remove Nth Node From End of List (Question #19):
Given the `head` of a linked list, remove the `nth` node from the end of the list and return its head.
Example:
Input: 1 -> 2 -> 3 -> 4 -> 5, n = 2
Output: 1 -> 2 -> 3 -> 5

Solution:

The solution uses two pointers, `leftPtr` and `rightPtr`, to remove the `nth` node from the end of the linked list. Here's the explanation of the solution:

1. Create a `dummyPtr` as a dummy node with a value of 0 and set its `next` pointer to the `head` of the linked list. This is done to handle the edge case where the `nth` node to be removed is the first node in the list.

2. Initialize the `leftPtr` to the `dummyPtr` and the `rightPtr` to the `head`.

3. Move the `rightPtr` `n` steps forward. This ensures that the distance between the `leftPtr` and `rightPtr` is exactly `n` nodes.

4. While `rightPtr` is not null, move both the `leftPtr` and `rightPtr` one step forward. This continues until the `rightPtr` reaches the end of the list.

5. At this point, the `leftPtr` will be pointing to the node just before the `nth` node from the end.

6. Update the `leftPtr` to skip the `nth` node by adjusting its `next` pointer to point to the node after the `nth` node.

7. Finally, return the `dummyPtr.next`, which is the updated head of the linked list.

Code : 

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummyPtr = new ListNode(0, head); // Create a dummy node
    ListNode leftPtr = dummyPtr; // Initialize left pointer to the dummy node
    ListNode rightPtr = head; // Initialize right pointer to the head

    while (n > 0 && rightPtr != null) {
        rightPtr = rightPtr.next; // Move right pointer n steps forward
        n--;
    }

    while (rightPtr != null) {
        rightPtr = rightPtr.next; // Move both pointers one step forward
        leftPtr = leftPtr.next;
    }

    leftPtr.next = leftPtr.next.next; // Skip the nth node by adjusting the next pointer of leftPtr

    return dummyPtr.next; // Return the head of the updated linked list
}
```

The time complexity of this solution is O(L), where L is the length of the linked list. The algorithm iterates through the linked list only once, performing a constant number of operations at each node. Therefore, the time complexity is linear in the length of the linked list.


--------------------------------------------------------------

14. Rotate Array (Question #189):
Given an array, rotate the array to the right by `k` steps, where `k` is non-negative.
Example:
Input: nums = [1, 2, 3, 4, 5, 6, 7], k = 3
Output: [5, 6, 7, 1, 2, 3, 4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]


Solution : 

The solution uses a reverse technique to rotate the array in-place. Here's the explanation of the solution:

1. In the `rotate` function, start by updating the value of `k` to `k % nums.length`. This is done to handle cases where `k` is larger than the length of the array. Taking the modulus ensures that `k` is within the valid range.

2. Initialize the variable `N` to `nums.length - 1`. This represents the last index of the array.

3. Call the `reverse` function three times:
   a. Reverse the entire array using `reverse(nums, 0, N)`. This step effectively reverses the entire array.
   b. Reverse the first `k` elements of the array using `reverse(nums, 0, k - 1)`. This step reverses the subarray containing the first `k` elements.
   c. Reverse the remaining elements of the array using `reverse(nums, k, N)`. This step reverses the subarray containing the remaining elements after the first `k` elements.

The `reverse` function is a helper function used to reverse a subarray within the array. It takes the array, the left index, and the right index as parameters.


Code : 

```java
public void rotate(int[] nums, int k) {
    k = k % nums.length; // Handle cases where k is larger than the length of the array
    int N = nums.length - 1; // Last index of the array
    
    reverse(nums, 0, N); // Reverse the entire array
    reverse(nums, 0, k - 1); // Reverse the first k elements
    reverse(nums, k, N); // Reverse the remaining elements
}

public void reverse(int[] arr, int left, int right) {
    while (left <= right) {
        int temp = arr[left]; // Swap elements at left and right indices
        arr[left] = arr[right];
        arr[right] = temp;
        left++; // Move left pointer towards the right
        right--; // Move right pointer towards the left
    }
}
```
Time and Space Complexity :

The time complexity of this solution is O(N), where N is the length of the array. The algorithm performs three reversals, each of which takes O(N/2) time. However, in big O notation, we ignore constant factors, so the overall time complexity is simplified to O(N).

The space complexity of the solution is O(1) since the algorithm operates in-place without using any additional data structures.

--------------------------------------------------------------
--------------------------------------------------------------

##Binary Search Algorithm


1. Binary Search (Question #704) [Easy]:
Given a sorted (in ascending order) integer array `nums` and a target value `target`, write a function to implement binary search and      return the index of the target in the array. If the target is not found, return -1.


Solution :
1. Initialize variables `left` and `right` as the start and end indices of the input array.
2. Perform binary search by repeatedly dividing the search space until `left` is less than or equal to `right`.
3. Calculate the middle index `mid` using `(left + right) / 2` to find the mid-point of the current search space.
4. Check if the element at index `mid` is equal to the target. If so, return `mid`, as we found the target.
5. If the element at index `mid` is less than the target, move the left pointer to `mid + 1` to search the right half of the current search space.
6. If the element at index `mid` is greater than the target, move the right pointer to `mid - 1` to search the left half of the current search space.
7. Repeat steps 3 to 6 until `left` becomes greater than `right`.

Time Complexity (TC): The time complexity of this binary search algorithm is O(log n), where n is the number of elements in the input array. Binary search efficiently reduces the search space by half in each iteration, resulting in logarithmic time complexity.

Space Complexity (SC): The space complexity is O(1) since the algorithm only uses a constant amount of extra space to store the variables `left`, `right`, and `mid`, regardless of the size of the input array.

Code:

```java
public int search(int[] nums, int target) {
    // Get the length of the input array
    int n = nums.length;
    
    // Initialize the left and right pointers for binary search
    int left = 0, right = n - 1;
    
    // Binary search loop
    while (left <= right) {
        // Calculate the mid index using the left and right pointers
        int mid = left + (right - left) / 2;
        
        // If the middle element is the target, return its index
        if (nums[mid] == target) {
            return mid;
        }

        // If the middle element is less than the target, ignore the left half
        if (nums[mid] < target) {
            left = mid + 1;
        }
        // If the middle element is greater than the target, ignore the right half
        else {
            right = mid - 1;
        }
    }

    // If the target is not found, return -1
    return -1;
}

Recursive : 
public int search(int[] nums, int target) {
    return binarySearch(nums, target, 0, nums.length - 1);
}

private int binarySearch(int[] nums, int target, int left, int right) {
    if (left > right) {
        return -1; // Base case: Target not found
    }

    int mid = left + (right - left) / 2;

    if (nums[mid] == target) {
        return mid; // Base case: Target found
    } else if (nums[mid] < target) {
        // Recursive call to search the right half
        return binarySearch(nums, target, mid + 1, right);
    } else {
        // Recursive call to search the left half
        return binarySearch(nums, target, left, mid - 1);
    }
}

```

----------------------------------------------------------

2. First Bad Version (Question #278) [Easy]:
You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

Example 1:

Input: n = 5, bad = 4
Output: 4
Explanation:
call isBadVersion(3) -> false
call isBadVersion(5) -> true
call isBadVersion(4) -> true
Then 4 is the first bad version.
Example 2:

Input: n = 1, bad = 1
Output: 1

Solution:
1. Initialize the `left` and `right` pointers to the first and last versions (1 and `n`) in the range to be searched.
2. Initialize the `ans` variable to store the answer, i.e., the index of the first bad version.
3. Perform binary search using the `while` loop, which continues as long as the `left` pointer is less than or equal to the `right` pointer.
4. Calculate the middle index `mid` using `(left + right) / 2` to divide the search space.
5. Check if the middle version `mid` is bad using the `isBadVersion()` function.
6. If the middle version is bad, update the `ans` to `mid` as we found a possible candidate for the first bad version, and continue searching the left half to find the first occurrence of the bad version.
7. If the middle version is not bad, continue searching the right half.
8. Repeat steps 4 to 7 until the `left` pointer becomes greater than the `right` pointer, indicating that we have found the first bad version.
9. Return the `ans` as the index of the first bad version.

Time Complexity (TC): The time complexity of this binary search algorithm is O(log n), where `n` is the number of versions. Binary search efficiently reduces the search space by half in each iteration, resulting in logarithmic time complexity.

Space Complexity (SC): The space complexity is O(1) since the algorithm only uses a constant amount of extra space to store the variables `left`, `right`, `ans`, and `mid`, regardless of the size of the input `n`.

Code: 

```java
public int firstBadVersion(int n) {
    // Initialize left and right pointers to search the versions
    int left = 1, right = n;
    
    // Initialize a variable to store the answer (first bad version)
    int ans = 0;

    // Binary search loop
    while (left <= right) {
        // Calculate the middle index using the left and right pointers
        int mid = left + (right - left) / 2;

        // Check if the middle version is bad (using the provided isBadVersion() function)
        if (isBadVersion(mid)) {
            // If the middle version is bad, update the answer to mid and search the left half
            ans = mid;
            right = mid - 1;
        } else {
            // If the middle version is not bad, search the right half
            left = mid + 1;
        }
    }

    // Return the first bad version found
    return ans;
}
```
-----------------------------------------------------------

3. Find Minimum in Rotated Sorted Array (Question #153) [Medium]:
Suppose an array of length `n` is rotated at an unknown pivot index and initially sorted in ascending order. Find the minimum element in the array. You may assume that the array does not contain duplicates.

Solution:
1. The binary search algorithm is used to find the minimum element in a rotated sorted array.
2. Initialize `left` and `right` pointers to the first and last elements of the array, respectively.
3. Perform binary search using the `while` loop, which continues as long as `left` is less than `right`.
4. Calculate the middle index `mid` using `(left + right) / 2`.
5. Check if the element at the middle index `mid` is greater than the element at the right index `right`. If true, it means that the minimum element is on the right side of `mid`, so we update `left = mid + 1`.
6. Check if the element at the middle index `mid` is less than the element at the right index `right`. If true, 
it means that the minimum element is either `mid` or on the left side of `mid`, so we update `right = mid`.
7. If the element at the middle index `mid` is equal to the element at the right index `right`, it means there are duplicate elements. In this case, we can safely ignore the rightmost element as it will not affect the minimum element, so we update `right--` to exclude the duplicate element.
8. Repeat steps 4 to 7 until `left` becomes equal to `right`, indicating that we have found the minimum element.
9. Return the element at the `left` index, which is the minimum element.

Time Complexity (TC): The time complexity of this binary search algorithm is O(log n), where `n` is the number of elements in the array. Binary search efficiently reduces the search space by half in each iteration, resulting in logarithmic time complexity.

Space Complexity (SC): The space complexity is O(1) since the algorithm only uses a constant amount of extra space to store the variables `left`, `right`, and `mid`, regardless of the size of the input array.

Code:

```java
public int findMin(int[] nums) {
    int left = 0;
    int right = nums.length - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;

        // Check if the middle element is greater than the rightmost element
        // If true, the minimum element is on the right side, 
        // so we update the left pointer
        if (nums[mid] > nums[right]) {
            left = mid + 1;
        }
        // Check if the middle element is less than the rightmost element
        // If true, the minimum element is either the middle element or 
        // on the left side
        // So we update the right pointer to mid since mid can be 
        // a potential candidate for the minimum element
        else if (nums[mid] < nums[right]) {
            right = mid;
        }
        // If the middle element is equal to the rightmost element
        // We can safely ignore the rightmost element as it will 
        // not affect the minimum element
        // So we update the right pointer to exclude the duplicate element
        // Below case is puerly to avoid duplicates in the array
        else {
            right--;
        }
    }

    // The left pointer will point to the minimum element
    return nums[left];
}
```

---------------------------------------------------------

4. Search in Rotated Sorted Array (Question #33) [Medium]:
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. You are given a target value to search for. If found in the array, return its index; otherwise, return -1. You may assume no duplicate exists in the array.

There is an integer array nums sorted in ascending order (with distinct values).

Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].

Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.

You must write an algorithm with O(log n) runtime complexity.

Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
Example 3:

Input: nums = [1], target = 0
Output: -1

Solution:

The given code implements a modified version of binary search to find the target element in a rotated sorted array. The algorithm exploits the fact that at least one half of the rotated array will always be sorted.

1. Initialize the left pointer to the beginning of the array (`0`) and the right pointer to the end of the array (`nums.length - 1`).
2. Use a while loop to perform binary search until the left and right pointers meet or cross each other.
3. Calculate the middle index (`mid`) in each iteration.
4. Check if the element at `mid` is equal to the target. If yes, return the index (`mid`).
5. Check if the left half or the right half is sorted by comparing the values at `left` and `mid`. This step helps in identifying which half to search for the target.
6. Adjust the pointers accordingly to continue the binary search in the sorted half that potentially contains the target element.
7. If the target is not found, the loop will terminate, and the function will return `-1`.

Time Complexity (TC):
The time complexity of this algorithm is O(log N) where N is the number of elements in the `nums` array. This is because binary search reduces the search space by half in each iteration.

Space Complexity (SC):
The space complexity of this algorithm is O(1) because it uses a constant amount of extra space for the variables (`left`, `right`, `mid`, and `target`) regardless of the size of the input array.

```java
public int search(int[] nums, int target) {
    int left = 0; // Initialize the left pointer to the start of the array.
    int right = nums.length - 1; // Initialize the right pointer to the end of the array.

    while (left <= right) { // Perform binary search until left and right pointers meet.
        int mid = (left + right) / 2; // Calculate the middle index.

        if (nums[mid] == target) { // If the middle element is the target, return its index.
            return mid;
        }

        if (nums[left] <= nums[mid]) { // Check if the left half is sorted.
            if (target >= nums[left] && target < nums[mid]) {
                // If the target lies in the left sorted half, adjust the right pointer.
                right = mid - 1;
            } else {
                // If the target doesn't lie in the left sorted half, adjust the left pointer.
                left = mid + 1;
            }
        } else {
            // The right half is sorted.
            if (target <= nums[right] && target > nums[mid]) {
                // If the target lies in the right sorted half, adjust the left pointer.
                left = mid + 1;
            } else {
                // If the target doesn't lie in the right sorted half, adjust the right pointer.
                right = mid - 1;
            }
        }
    }

    return -1; // Return -1 if the target is not found in the array.
}
```
--------------------------------------------------

5. Search Insert Position (Question #35) [Easy]:
Given a sorted array of distinct integers `nums` and a target value `target`, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

Example 1:

Input: nums = [1,3,5,6], target = 5
Output: 2
Example 2:

Input: nums = [1,3,5,6], target = 2
Output: 1
Example 3:

Input: nums = [1,3,5,6], target = 7
Output: 4

Solution:
The given code implements a modified version of binary search to find the index where the target should be inserted in the sorted array.

1. Initialize the left pointer to the beginning of the array (`0`) and the right pointer to the end of the array (`n - 1`).
2. Initialize a variable `lastLessValueIndex` to keep track of the index where the target would be inserted if it's not found in the array.
3. Use a while loop to perform binary search until the left and right pointers meet or cross each other.
4. Calculate the middle index (`mid`) in each iteration.
5. Check if the element at `mid` is equal to the target. If yes, return the index (`mid`) since the target is found in the array.
6. If the element at `mid` is less than the target, update `lastLessValueIndex` to `mid + 1` since the target would be inserted after the current `mid` element.
7. If the element at `mid` is greater than the target, adjust the right pointer to search in the left half of the array.
8. If the target is not found, the loop will terminate, and the function will return `lastLessValueIndex`.

Time Complexity (TC):
The time complexity of this algorithm is O(log N) where N is the number of elements in the `nums` array. This is because binary search reduces the search space by half in each iteration.

Space Complexity (SC):
The space complexity of this algorithm is O(1) because it uses a constant amount of extra space for the variables (`left`, `right`, `mid`, and `lastLessValueIndex`) regardless of the size of the input array.

```java
public int searchInsert(int[] nums, int target) {
    int n = nums.length; // Get the length of the input array.

    int left = 0, right = n - 1; // Initialize the left and right pointers.
    int lastLessValueIndex = 0; // Initialize a variable to store the index where the target would be inserted.

    while (left <= right) { // Perform binary search until the left and right pointers meet or cross each other.
        int mid = (right + left) / 2; // Calculate the middle index.

        if (nums[mid] == target) { // If the middle element is the target, return its index.
            return mid;
        }

        if (nums[mid] < target) { // If the middle element is less than the target, update the lastLessValueIndex and adjust the left pointer.
            lastLessValueIndex = mid + 1;
            left = mid + 1;
        } else {
            // If the middle element is greater than the target, adjust the right pointer.
            right = mid - 1;
        }
    }

    return lastLessValueIndex; // Return the index where the target would be inserted.
}
```
------------------------------------------------------------

6. Find Peak Element (Question #162) [Medium]:

A peak element is an element that is strictly greater than its neighbors.

Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, 
return the index to any of the peaks.

You may imagine that nums[-1] = nums[n] = -. In other words, an element is always considered to be strictly greater 
than a neighbor that is outside the array.

You must write an algorithm that runs in O(log n) time.

 

Example 1:

Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
Example 2:

Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 
where the peak element is 6.


Solution:

1. The first part of the code checks for special cases:
   - If there's only one element in the array, it is the peak element.
   - If the first element is greater than the second, it is the peak element.
   - If the last element is greater than the second-to-last, it is the peak element.
   These checks handle the edge cases and optimize the algorithm for arrays that have a peak at the start or end.

2. After handling the special cases, the algorithm proceeds with binary search to find a peak element in the remaining portion of the array. The binary search process continues until the left and right pointers meet or cross each other.

3. In each iteration of the binary search loop, the middle element (mid) is checked to see if it is a peak element (greater than its adjacent elements). If it is a peak element, its index is returned.

4. If the middle element is not a peak element, the algorithm determines whether it is in an increasing or decreasing sequence by comparing it with its adjacent element. Based on this information, the left or right pointer is adjusted to search for a peak in the appropriate direction.

Time Complexity (TC):
The time complexity of this algorithm is O(log N) because binary search reduces the search space by half in each iteration, where N is the number of elements in the `nums` array.

Space Complexity (SC):
The space complexity of this algorithm is O(1) because it uses a constant amount of extra space for the variables (`left`, `right`, `mid`, and `n`) regardless of the size of the input array.

```java
public int findPeakElement(int[] nums) {
    int n = nums.length;
    if (n == 1) {
        return 0; // If there's only one element in the array, it is the peak element.
    }

    if (nums[0] > nums[1]) {
        return 0; // If the first element is greater than the second, it is the peak element.
    }

    if (nums[n - 1] > nums[n - 2]) {
        return n - 1; // If the last element is greater than the second-to-last, it is the peak element.
    }

    int left = 1; // Initialize the left pointer to the second element.
    int right = n - 2; // Initialize the right pointer to the second-to-last element.

    while (left <= right) { // Perform binary search until the left and right pointers meet or cross each other.
        int mid = (left + right) / 2; // Calculate the middle index.

        // Check if the middle element is a peak element (greater than its adjacent elements).
        if (nums[mid] > nums[mid + 1] && nums[mid] > nums[mid - 1]) {
            return mid; // If the middle element is a peak, return its index.
        }

        // If the middle element is in an increasing sequence, move the left pointer to mid + 1.
        if (nums[mid] < nums[mid + 1]) {
            left = mid + 1;
        } else if (nums[mid] > nums[mid + 1]) {
            // If the middle element is in a decreasing sequence, move the right pointer to mid - 1.
            right = mid - 1;
        }
    }

    return -1; // Return -1 if a peak element is not found in the array.
}
```

------------------------------------------------------------

7. Search for a Range (Question #34) [Medium]:

Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.

If target is not found in the array, return [-1, -1].

You must write an algorithm with O(log n) runtime complexity.

Example 1:

Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
Example 2:

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
Example 3:

Input: nums = [], target = 0
Output: [-1,-1]

Solution:
The given code aims to find the first and last occurrences of the target element in a sorted array. The algorithm utilizes 
two binary search loops to find these occurrences.

1. The first binary search loop is used to find the leftmost occurrence of the target. It works in a similar way to 
standard binary search, but when the target is found, it continues searching on the left side to find the leftmost occurrence.
2. The second binary search loop is used to find the rightmost occurrence of the target. It also works similarly to 
standard binary search, but when the target is found, it continues searching on the right side to find the rightmost occurrence.

Time Complexity (TC):
The time complexity of this algorithm is O(log N) for each binary search loop, where N is the number of elements in the `nums` array. Since we have two binary search loops, the overall time complexity remains O(log N).

Space Complexity (SC):
The space complexity of this algorithm is O(1) because it uses a constant amount of extra space for the variables (`left`, `right`, `mid`, `result`, `leftMostIndex`, and `rightMostIndex`) regardless of the size of the input array.


```java
public int[] searchRange(int[] nums, int target) {
    int n = nums.length;
    if (n == 0) {
        return new int[]{-1, -1}; // If the input array is empty, return [-1, -1].
    }

    int left = 0;
    int right = nums.length - 1;

    int[] result = {-1, -1}; // Initialize the result array with [-1, -1].
    int leftMostIndex = -1; // Initialize variables to store the leftmost and rightmost indices of the target.
    int rightMostIndex = -1;

    // First, we'll find the leftmost occurrence of the target using binary search.
    while (left <= right) {
        int mid = (right + left) / 2;

        if (nums[mid] == target) {
            leftMostIndex = mid; // If target found, store the index in leftMostIndex and continue searching on the left side.
            right = mid - 1; // Adjust the right pointer to search in the left half.
        } else if (nums[mid] < target) {
            left = mid + 1; // If target is greater than mid, search in the right half.
        } else {
            right = mid - 1; // If target is less than mid, search in the left half.
        }
    }

    left = 0;
    right = nums.length - 1;

    // Now, we'll find the rightmost occurrence of the target using binary search.
    while (left <= right) {
        int mid = (right + left) / 2;

        if (nums[mid] == target) {
            rightMostIndex = mid; // If target found, store the index in rightMostIndex and continue searching on the right side.
            left = mid + 1; // Adjust the left pointer to search in the right half.
        } else if (nums[mid] < target) {
            left = mid + 1; // If target is greater than mid, search in the right half.
        } else {
            right = mid - 1; // If target is less than mid, search in the left half.
        }
    }

    result[0] = leftMostIndex; // Update the result array with the leftmost and rightmost indices of the target.
    result[1] = rightMostIndex;
    return result; // Return the result array.
}
```
------------------------------------------------------------

8. Sorted Array to Binary Search Tree (Question #108) [Easy]:
Given an integer array `nums` where the elements are sorted in ascending order, convert it to a height-balanced binary search tree (BST). A height-balanced BST is a binary tree in which the depth of the two subtrees of every node never differs by more than one.

Input: nums = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: [0,-10,5,null,-3,null,9] is also accepted:


Approach:
The given problem requires converting a sorted integer array into a height-balanced binary search tree (BST). 
A height-balanced BST is a binary tree in which the difference in the heights of the left and right subtrees of 
every node is at most one.

To construct a height-balanced BST, we can follow a recursive approach:
The main thing to notice here is Array is Sorted so the root will be always the middle element of the array

1. Find the middle element of the sorted array. This element will be the root of the BST.
2. Recursively construct the left subtree using the elements to the left of the middle element.
3. Recursively construct the right subtree using the elements to the right of the middle element.
4. Return the root node of the constructed BST.

Time Complexity (TC):
The time complexity of this algorithm is O(N), where N is the number of elements in the `nums` array. 
This is because each element of the array is visited once to construct the corresponding node in the BST.

Space Complexity (SC):
The space complexity of this algorithm is O(log N) due to the recursive call stack. In a balanced binary search tree, 
the maximum depth of the recursion is log N.

Code:

```java
public TreeNode sortedArrayToBST(int[] nums) {
    if (nums.length == 0) {
        return null; // If the input array is empty, return null as there are no nodes to create the BST.
    }

    return createTree(nums, 0, nums.length - 1); // Call the helper function to create the BST with the entire array.
}

public TreeNode createTree(int[] nums, int start, int end) {
    if (start > end) {
        return null; // Base case: If the start index becomes greater than the end index, return null.
    }

    int mid = (start + end) / 2; // Calculate the middle index.

    TreeNode node = new TreeNode(nums[mid]); // Create a new node with the middle element as the value.

    // Recursively construct the left and right subtrees using the elements to the left and right of the middle element.
    node.left = createTree(nums, start, mid - 1);
    node.right = createTree(nums, mid + 1, end);

    return node; // Return the root node of the constructed BST.
}
```
------------------------------------------------------------

9. Implement Binary Search (Question #702) [Medium]:
Given a sorted (in ascending order) integer array `nums` and a target value `target`, write a function to implement binary search iteratively and return the index of the target if it exists in the array. If the target is not found, return -1.

Given an integer array sorted in ascending order, write a function to search target in nums.  If target exists, then return its index, otherwise return -1. However, the array size is unknown to you. You may only access the array using an ArrayReader interface, where ArrayReader.get(k) returns the element of the array at index k (0-indexed).

You may assume all integers in the array are less than 10000, and if you access the array out of bounds, ArrayReader.get will return 2147483647.

 

Example 1:

Input: array = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4
Example 2:

Input: array = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1
 

Note:

You may assume that all elements in the array are unique.
The value of each element in the array will be in the range [-9999, 9999].


public int search(ArrayReader reader, int target) {
    int left = 0, right = 20000;
    while (left < right) {
        int mid = left + right >> 1;
        if (reader.get(mid) >= target) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return reader.get(left) == target ? left : -1;
}

-------------------------------------------------------------
-------------------------------------------------------------
##Sliding Window

1. Maximum Average Subarray I - (Maximum Sum Subarray of Size K) (easy) - LeetCode #643
You are given an integer array nums consisting of n elements, and an integer k.

Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer 
with a calculation error less than 10-5 will be accepted.

Example 1:

Input: nums = [1,12,-5,-6,50,3], k = 4
Output: 12.75000
Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75
Example 2:

Input: nums = [5], k = 1
Output: 5.00000

Approach:
The problem requires finding a contiguous subarray of length `k` with the maximum average value. To do this efficiently, we can use a sliding window approach.

1. Initialize two pointers, `left` and `right`, both set to 0.
2. Calculate the sum of the first `k` elements (i.e., the sum of the first window) and store it in the `window` variable.
3. Calculate the average of the current window, `window / k`, and set it as the initial `ans`.
4. Move the `right` pointer to `k` to create the first window of length `k`.
5. For each subsequent window, keep adding the next element (`nums[right]`) and removing the leftmost element (`nums[right - k]`) from the window sum. Calculate the average for each window and update the `ans` if a larger average is found.
6. Continue this process until the `right` pointer reaches the end of the array.

Code:
```java
public double findMaxAverage(int[] nums, int k) {
    int left = 0; // Left pointer for the sliding window
    int n = nums.length; // Length of the array
    double ans = 0; // Variable to store the answer (maximum average)
    double window = 0; // Variable to store the sum of the current window

    // Calculate the sum of the first window (first k elements)
    for (int i = 0; i < k; i++) {
        window += nums[i];
    }

    // Initialize the answer with the average of the first window
    ans = window / k;

    // Start moving the right pointer to form the subsequent windows
    for (int right = k; right < n; right++) {
        // Add the next element and remove the leftmost element from the window sum
        window += nums[right] - nums[right - k];
        // Update the answer if a larger average is found
        ans = Math.max(ans, window / k);
    }

    return ans; // Return the maximum average found
}
```

Time Complexity (TC):
The time complexity of this algorithm is O(n), where n is the number of elements in the `nums` array. We iterate through the array once to calculate the initial window sum, and then we move the `right` pointer from `k` to `n` to form the subsequent windows. Each iteration takes constant time.

Space Complexity (SC):
The space complexity of this algorithm is O(1) because we use only a constant amount of extra space to store the variables, regardless of the size of the input array.

-----------------------------------------------------

2. Minimum Window Substring (hard) - LeetCode #76

Given two strings s and t of lengths m and n respectively, return the minimum window 
substring
 of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string "".

The testcases will be generated such that the answer is unique.

 

Example 1:

Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
Example 2:

Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.
Example 3:

Input: s = "a", t = "aa"
Output: ""
Explanation: Both 'a's from t must be included in the window.
Since the largest window of s only has one 'a', return empty string.


Solution:

1. Initialize two pointers, `left` and `right`, to track the window boundaries. Set them both to 0 initially.

2. Create two frequency maps, `targetMap` and `windowMap`, to track the character frequencies of the target string `t` and the current window in string `s`, respectively. Initially, both maps should be empty.

3. Populate the `targetMap` by iterating through the characters of string `t`. For each character, update its frequency in the map.

4. Initialize variables to track the minimum window length (`minWindowLength`), the starting index of the minimum window (`minWindowStart`), and a counter to keep track of the characters in `t` that have been matched in the current window (`matchedCount`). Set the `matchedCount` to 0 initially.

5. Start iterating through the string `s` using the `right` pointer:
   - For each character encountered, update its frequency in the `windowMap`.
   - If the character is present in the `targetMap` and its frequency in the `windowMap` is less than or equal to its frequency in the `targetMap`, increment the `matchedCount` by 1.

6. Check if all characters in `t` have been matched in the current window:
   - If the `matchedCount` is equal to the length of the target string `t`, it means all characters in `t` have been matched. In this case, we have found a valid window.
   - Update the minimum window length and the starting index of the minimum window if necessary.

7. Shrink the window by moving the `left` pointer:
   - While the `left` pointer can be moved and the current window still contains all characters from `t`, update the `windowMap` and `matchedCount` accordingly.
   - Check if the updated window is still valid (contains all characters from `t`).
   - If the updated window is still valid, update the minimum window length and the starting index of the minimum window if necessary.

8. Repeat steps 5 to 7 until the `right` pointer reaches the end of the string `s`.

9. After the loop, check if a valid window was found. If so, return the substring of `s` that corresponds to the minimum window length, starting from the `minWindowStart` index. Otherwise, return an empty string.

Code:

```java
public String minWindow(String s, String t) {
    HashMap<Character, Integer> targetMap = new HashMap<>(); // Frequency map for target string t
    HashMap<Character, Integer> windowMap = new HashMap<>(); // Frequency map for current window in s

    // Populate the targetMap with character frequencies from string t
    for (char ch : t.toCharArray()) {
        targetMap.put(ch, targetMap.getOrDefault(ch, 0) + 1);
    }

    int left = 0;                  // Left pointer of the window
    int right = 0;                 // Right pointer of the window
    int minWindowStart = 0;        // Starting index of the minimum window
    int minWindowLength = Integer.MAX_VALUE; // Minimum window length
    int matchedCount = 0;          // Counter to track matched characters

    // Iterate through the string s using the right pointer
    while (right < s.length()) {
        char rightChar = s.charAt(right);
        windowMap.put(rightChar, windowMap.getOrDefault(rightChar, 0) + 1); // Update the frequency of the character in the window map

        // If the current character is present in targetMap and its frequency in the window map is <= its frequency in targetMap
        if (targetMap.containsKey(rightChar) && windowMap.get(rightChar) <= targetMap.get(rightChar)) {
            matchedCount++; // Increment matchedCount as a character from t is matched
        }

        // Check if all characters from t have been matched in the current window
        while (matchedCount == t.length()) {
            // Update the minimum window length and starting index if necessary
            if (right - left + 1 < minWindowLength) {
                minWindowLength = right - left + 1;
                minWindowStart = left;
            }

            // Shrink the window from the left side
            char leftChar = s.charAt(left);
            windowMap.put(leftChar, windowMap.get(leftChar) - 1); // Update the frequency of the character in the window map

            // If the current character was one of the characters from t, decrement the matchedCount
            if (targetMap.containsKey(leftChar) && windowMap.get(leftChar) < targetMap.get(leftChar)) {
                matchedCount--;
            }

            left++; // Move the left pointer to shrink the window
        }

        right++; // Move the right pointer to expand the window
    }

    // Check if a valid window was found
    if (minWindowLength != Integer.MAX_VALUE) {
        return s.substring(minWindowStart, minWindowStart + minWindowLength);
    } else {
        return "";
    }
}
```

Time and Space Complexity :

The time complexity of this solution is O(n), where n is the length of the string `s`. The two pointers, `left` and `right`, 
traverse the string `s` only once. Additionally, the frequency maps and comparisons have constant time complexity since the 
number of characters is limited (128 ASCII characters). Therefore, the overall time complexity is linear, meeting the complexity requirement of O(n).

-----------------------------------------------------
4. Fruit Into Baskets (medium) - LeetCode #904

You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces.

You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:

You only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.
Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.
Once you reach a tree with fruit that cannot fit in your baskets, you must stop.
Given the integer array fruits, return the maximum number of fruits you can pick.



Example 1:

Input: fruits = [1,2,1]
Output: 3
Explanation: We can pick from all 3 trees.
Example 2:

Input: fruits = [0,1,2,2]
Output: 3
Explanation: We can pick from trees [1,2,2].
If we had started at the first tree, we would only pick from trees [0,1].
Example 3:

Input: fruits = [1,2,3,2,2]
Output: 4
Explanation: We can pick from trees [2,3,2,2].
If we had started at the first tree, we would only pick from trees [1,2].



brute force :

The brute force solution for the Fruit Into Baskets problem involves trying all possible combinations 
of two fruit types and counting the maximum number of fruits we can pick. Here's the basic outline of the brute force approach:

Initialize a variable maxFruits to store the maximum number of fruits we can pick.

Start a nested loop to iterate over all possible starting points for the two fruit types. The outer loop will 
consider the starting point of the first fruit type, and the inner loop will consider the starting point of the second fruit type.

For each combination of starting points, iterate through the array and pick fruits until we encounter a third 
fruit type (different from the two starting types). Count the number of fruits we picked during this iteration.

Update the maxFruits variable with the maximum number of fruits found during the iterations.

Continue the nested loops until all possible combinations are tried.

Finally, return the maxFruits value as the result.

The time complexity of this brute force solution is O(n^3), where n is the length of the input array. 
This is because we are trying all possible combinations of two fruit types and iterating through the 
array for each combination. The overall solution is not efficient for large inputs and should be avoided in practice.
class Solution {
    public int totalFruit(int[] tree) {
        int n = tree.length;
        int maxFruits = 0;

        // Iterate through all possible starting points for the first fruit type
        for (int i = 0; i < n; i++) {
            // Iterate through all possible starting points for the second fruit type
            for (int j = i + 1; j < n; j++) {
                int firstFruit = tree[i];
                int secondFruit = tree[j];
                int count = 0;

                // Iterate through the array and count the number of fruits we can pick
                for (int k = 0; k < n; k++) {
                    if (tree[k] == firstFruit || tree[k] == secondFruit) {
                        count++;
                    } else {
                        break; // Encounter a third fruit type, stop counting
                    }
                }

                // Update the maximum number of fruits
                maxFruits = Math.max(maxFruits, count);
            }
        }

        return maxFruits;
    }
}

optimized :

Initialize two pointers, left and right, to mark the start and end of the current window, respectively. Also, 
initialize a maxFruits variable to store the maximum number of fruits we can pick.

Start iterating through the array with the right pointer. For each element tree[right], do the following:

a. Add the current fruit type to a frequency map. The frequency map will keep track of the count of each fruit 
type in the current window.

b. If the size of the frequency map becomes larger than 2 (i.e., there are more than two types of fruits in the window), 
we need to shrink the window from the left side until there are at most two types of fruits.

c. Update the maxFruits variable with the maximum number of fruits found so far (i.e., the length of the current window).

Continue the iteration until the right pointer reaches the end of the array.

Finally, return the maxFruits value as the result.

The sliding window approach helps us avoid unnecessary iterations and significantly improves the efficiency of the solution. 
The frequency map allows us to quickly determine the number of fruit types in the current window and decide when to 
shrink or expand the window efficiently.

Here's the optimized solution in Java:


class Solution {
    public int totalFruit(int[] tree) {
        int n = tree.length;
        int maxFruits = 0;
        int left = 0;
        HashMap<Integer, Integer> fruitFrequency = new HashMap<>();

        for (int right = 0; right < n; right++) {
            // Add the current fruit type to the frequency map
            fruitFrequency.put(tree[right], fruitFrequency.getOrDefault(tree[right], 0) + 1);

            // Shrink the window from the left side if there are more than 2 fruit types
            while (fruitFrequency.size() > 2) {
                fruitFrequency.put(tree[left], fruitFrequency.get(tree[left]) - 1);
                if (fruitFrequency.get(tree[left]) == 0) {
                    fruitFrequency.remove(tree[left]);
                }
                left++;
            }

            // Update the maximum number of fruits
            maxFruits = Math.max(maxFruits, right - left + 1);
        }

        return maxFruits;
    }
}

The time complexity of the optimized solution is O(n), where n is the length of the input array. This is because 
we iterate through the array once, and each element is processed by both the left and right pointers exactly once. 
The overall solution is much more efficient than the brute force approach and is suitable for large inputs.

-------------------------------------------------------
5. Longest Repeating Character Replacement (medium) - LeetCode #424

You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.

Return the length of the longest substring containing the same letter you can get after performing the above operations.

 

Example 1:

Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.
Example 2:

Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
There may exists other ways to achive this answer too.


Brute Force Approach:

In the brute force approach, we consider all possible substrings and calculate the maximum length of the substring 
that can be obtained by replacing characters to make all characters the same. We try all possible replacement counts 
(from 0 to the length of the substring) for each character in the substring.

Here's the basic outline of the brute force approach:

Initialize a variable maxLength to store the maximum length of the substring.

Start two nested loops to consider all possible substrings. The outer loop will represent the starting index of the 
substring, and the inner loop will represent the ending index of the substring.

For each substring, create a frequency map to count the occurrences of each character.

Start another loop to try all possible replacement counts (from 0 to the length of the substring) for each character 
in the substring.

Update the maxLength variable with the maximum length of the substring obtained after replacements.

Continue the nested loops until all possible substrings and replacement counts are considered.

Finally, return the maxLength value as the result.

The time complexity of this brute force approach is O(n^3), where n is the length of the input string. 
This is because we consider all possible substrings, and for each substring, we may need to try all possible 
replacement counts for each character in the substring.

class Solution {
    public int characterReplacement(String s, int k) {
        int n = s.length();
        int maxLength = 0;

        // Iterate through all possible substrings
        for (int left = 0; left < n; left++) {
            for (int right = left; right < n; right++) {
                String substring = s.substring(left, right + 1);
                int maxCount = getMaxCharacterCount(substring);

                // Calculate the number of characters that need replacement
                int replacementsNeeded = substring.length() - maxCount;

                // Check if the replacements needed are less than or equal to k
                if (replacementsNeeded <= k) {
                    // Update the maximum length of the substring found so far
                    maxLength = Math.max(maxLength, substring.length());
                }
            }
        }

        return maxLength;
    }

    private int getMaxCharacterCount(String s) {
        int maxCount = 0;
        HashMap<Character, Integer> charFrequency = new HashMap<>();

        for (char ch : s.toCharArray()) {
            charFrequency.put(ch, charFrequency.getOrDefault(ch, 0) + 1);
            maxCount = Math.max(maxCount, charFrequency.get(ch));
        }

        return maxCount;
    }
}


Optimized Approach:

The optimized solution for the Longest Repeating Character Replacement problem uses the sliding window 
approach to efficiently find the maximum length of the substring with at most k replacements. 

Here's how the optimized solution works:

Initialize two pointers, left and right, to mark the start and end of the current window, respectively.

Initialize a maxCount variable to store the maximum count of any character in the current window.

Start iterating through the string with the right pointer. For each character s[right], do the following:

a. Increment the count of the current character in the frequency map.

b. Update the maxCount with the maximum frequency of any character in the frequency map.

c. If the size of the current window (i.e., the length of the substring from left to right) minus maxCount is greater 
than k, then it means we have more than k characters that need replacement. In this case, we need to shrink the window 
from the left side.

d. Update the maximum length of the substring found so far (i.e., the length of the current window).

Continue the iteration until the right pointer reaches the end of the string.

Finally, return the maximum length of the substring found as the result.

The sliding window approach helps us avoid unnecessary iterations and significantly improves the efficiency of 
the solution. The frequency map allows us to quickly determine the maximum count of any character in the current 
window and decide when to shrink or expand the window efficiently.

class Solution {
    public int characterReplacement(String s, int k) {
        int n = s.length();
        int maxLength = 0;
        int maxCount = 0;
        int left = 0;
        HashMap<Character, Integer> charFrequency = new HashMap<>();

        for (int right = 0; right < n; right++) {
            char rightChar = s.charAt(right);
            charFrequency.put(rightChar, charFrequency.getOrDefault(rightChar, 0) + 1);
            maxCount = Math.max(maxCount, charFrequency.get(rightChar));

            // If the number of characters that need replacement is greater than k, shrink the window
            while (right - left + 1 - maxCount > k) {
                char leftChar = s.charAt(left);
                charFrequency.put(leftChar, charFrequency.get(leftChar) - 1);
                left++;
                // Update maxCount after removing a character from the window
                maxCount = charFrequency.values().stream().max(Integer::compare).orElse(0);
            }

            // Update the maximum length of the substring found so far
            maxLength = Math.max(maxLength, right - left + 1);
        }

        return maxLength;
    }
}


-------------------------------------------------------
6. Permutation in String (medium) - LeetCode #567


Brute force
In the brute force approach, we generate all possible permutations of the first string s1 and check if any of those permutations is a substring of the second string s2. We can use backtracking to generate all permutations of s1 and then check if each permutation is a substring of s2.

Here's the basic outline of the brute force approach:

Generate all permutations of the first string s1.

For each permutation of s1, check if it is a substring of s2. If we find a match, return true.

If we don't find any match after checking all permutations, return false.

The time complexity of this brute force approach is O((n+m)!), where n is the length of s1, and m is the length of s2. This is because we generate all permutations of s1, which takes (n!) time, and then for each permutation, we check if it is a substring of s2, which takes O(m) time.


class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int n = s1.length();
        int m = s2.length();
        if (n > m) {
            return false;
        }

        // Generate all permutations of s1
        List<String> permutations = new ArrayList<>();
        generatePermutations(s1.toCharArray(), 0, n - 1, permutations);

        // Check if any permutation is a substring of s2
        for (String permutation : permutations) {
            if (s2.contains(permutation)) {
                return true;
            }
        }

        return false;
    }

    private void generatePermutations(char[] chars, int left, int right, List<String> permutations) {
        if (left == right) {
            permutations.add(new String(chars));
        } else {
            for (int i = left; i <= right; i++) {
                swap(chars, left, i);
                generatePermutations(chars, left + 1, right, permutations);
                swap(chars, left, i); // Backtrack
            }
        }
    }

    private void swap(char[] chars, int i, int j) {
        char temp = chars[i];
        chars[i] = chars[j];
        chars[j] = temp;
    }
}


-------------------------------------------------------
7. Longest Substring Without Repeating Characters (medium) - LeetCode #3

Given a string s, find the length of the longest substring without repeating characters.

Example 1:

Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
Example 2:

Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
Example 3:

Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.

In the brute force approach, we consider all possible substrings of the input string s and check if each substring has all unique characters. We keep track of the maximum length of such substrings and return that as the result.

Algorithm:

Initialize a variable maxLength to store the maximum length of the substring without repeating characters. Set it to 0 initially.

Iterate through all possible starting positions of the substring using an outer loop.

For each starting position, use an inner loop to iterate through all possible ending positions of the substring.

Within the inner loop, check if the current substring from the starting to ending positions has all unique characters. If it does, update maxLength to the maximum of its current value and the length of the current substring.

Continue the inner loop until all possible ending positions have been considered for the given starting position.

Continue the outer loop until all possible starting positions have been considered.

After both loops, the maxLength variable will hold the length of the longest substring without repeating characters.

Return maxLength as the result.

Complexity Analysis:

The time complexity of the brute force approach is O(n^3) because we have two nested loops for iterating through all possible substrings, and each loop takes O(n) time.

The space complexity is O(1) as we are not using any additional data structures.

class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        int maxLength = 0;

        for (int start = 0; start < n; start++) {
            for (int end = start + 1; end <= n; end++) {
                if (isUnique(s, start, end)) {
                    maxLength = Math.max(maxLength, end - start);
                }
            }
        }

        return maxLength;
    }

    private boolean isUnique(String s, int start, int end) {
        Set<Character> charSet = new HashSet<>();
        for (int i = start; i < end; i++) {
            char ch = s.charAt(i);
            if (charSet.contains(ch)) {
                return false;
            }
            charSet.add(ch);
        }
        return true;
    }
}


Optimized : 
Algorithm:

Initialize a HashSet called set to keep track of characters in the current window.

Initialize three variables i, j, and max to represent the current window's start position, end position, and the maximum length of the substring without repeating characters. Set i = j = max = 0 initially.

Start iterating through the string s using the i pointer:

Check if the character at the i pointer is not already present in the set.

If it is not present, it means adding this character to the current window will not result in any repeating characters. So, we can expand the window by moving the i pointer one step to the right and add the character to the set.

Update the max variable with the maximum of its current value and the size of the set. This represents the length of the current substring without repeating characters.

Move the i pointer one step to the right.

If the character at the i pointer is already present in the set, it means we have encountered a repeating character. In this case, we need to shrink the window from the left side to eliminate the repeating character.

Remove the character at the j pointer from the set.

Move the j pointer one step to the right.

Continue the iteration until the i pointer reaches the end of the string s.

After the loop, the max variable will hold the length of the longest substring without repeating characters.

Return max as the result.

Explanation:

The given solution uses a sliding window approach to efficiently find the length of the longest substring without repeating characters. The HashSet called set is used to maintain the characters in the current window. The i pointer moves to expand the window, and the j pointer moves to shrink the window when a repeating character is encountered.

As we iterate through the string s, the set keeps track of the unique characters in the current window. When we encounter a repeating character, we remove characters from the set starting from the left side of the window (pointed by j) until the repeating character is no longer present. This process ensures that we have a new window with no repeating characters.

While updating the window, we keep track of the max variable by calculating the length of the current window (which is i - j) and updating max if needed. The max variable will eventually hold the length of the longest substring without repeating characters.

Complexity Analysis:

The time complexity of the given solution is O(n), where n is the length of the input string s. This is because we traverse the string once from left to right.

The space complexity is O(k), where k is the size of the character set (in this case, the number of unique characters in the input string). Since the character set is limited to ASCII characters (256 characters), the space complexity is considered constant.

public int lengthOfLongestSubstring(String s) {
    HashSet<Character> set = new HashSet<>();
    int i=0, j=0, max=0;
    while(i<s.length())
    {
        if(!set.contains(s.charAt(i)))
        {
           set.add(s.charAt(i));
           max= Math.max(max, set.size());
           i++;
        }
        else
        {
           set.remove(s.charAt(j));
           j++;
        }
    }
    return max;
}


-------------------------------------------------------
8. Find All Anagrams in a String (medium) - LeetCode #438

Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

 

Example 1:

Input: s = "cbaebabacd", p = "abc"
Output: [0,6]
Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".
Example 2:

Input: s = "abab", p = "ab"
Output: [0,1,2]
Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".

Brute force : 

In the brute force approach, we consider all possible substrings of the string s with the same length as the string p, and for each substring, we check if it is an anagram of p. We keep track of the start indices of all such anagrams and return them as the result.

Algorithm:

Initialize an empty list called anagramIndices to store the start indices of the anagrams of p in s.

Calculate the lengths of the strings s and p and store them in variables n and m, respectively.

Iterate through all possible starting positions of the substring in s using an outer loop with the pointer i ranging from 0 to n - m.

For each starting position i, extract the substring of length m starting from i in s. This substring represents the current window.

Check if the current window (substring) is an anagram of p by comparing the character frequencies of both strings.

To do this, initialize two arrays charFrequencyS and charFrequencyP of size 26 (to represent each lowercase English alphabet).

For the current window in s, increment the count of each character in charFrequencyS.

For the string p, increment the count of each character in charFrequencyP.

Check if charFrequencyS is equal to charFrequencyP. If they are equal, it means the current window is an anagram of p, so add the current start index i to the anagramIndices list.

After the loop, return the anagramIndices list as the result.

Complexity Analysis:

The time complexity of the brute force approach is O((n-m) * m), where n is the length of s and m is the length of p. The outer loop runs (n-m) times, and for each iteration, we compare m characters of both strings.

The space complexity is O(1) since we are using fixed-size arrays to store character frequencies.

Brute Force Implementation:
import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> anagramIndices = new ArrayList<>();
        int n = s.length();
        int m = p.length();

        for (int i = 0; i <= n - m; i++) {
            if (isAnagram(s.substring(i, i + m), p)) {
                anagramIndices.add(i);
            }
        }

        return anagramIndices;
    }

    private boolean isAnagram(String s, String p) {
        int[] charFrequencyS = new int[26];
        int[] charFrequencyP = new int[26];

        for (int i = 0; i < s.length(); i++) {
            charFrequencyS[s.charAt(i) - 'a']++;
            charFrequencyP[p.charAt(i) - 'a']++;
        }

        for (int i = 0; i < 26; i++) {
            if (charFrequencyS[i] != charFrequencyP[i]) {
                return false;
            }
        }

        return true;
    }
}




Optimized:
Sliding Window with Frequency Map

Algorithm:

Initialize an empty list called anagramIndices to store the start indices of the anagrams of p in s.

Calculate the lengths of the strings s and p and store them in variables n and m, respectively.

Create two integer arrays charFrequencyS and charFrequencyP of size 26 (to represent each lowercase English alphabet) to keep track of character frequencies in s and p, respectively.

Populate charFrequencyP with the character frequencies of string p.

Start iterating through the string s using the right pointer:

Increment the frequency of the character at the right pointer in charFrequencyS.

If the current window (substring) size becomes greater than m, we need to shrink the window from the left side. Decrement the frequency of the character at the left pointer in charFrequencyS and move the left pointer one step to the right.

Check if the charFrequencyS is equal to charFrequencyP. If they are equal, it means the current window is an anagram of p, so add the current start index left to the anagramIndices list.

Move the right pointer one step to the right to expand the window.

After the loop, return the anagramIndices list as the result.

Complexity Analysis:

The time complexity of the optimized approach is O(n), where n is the length of the input string s. This is because we traverse the string once from left to right, and each character is processed exactly twice (once by the left pointer and once by the right pointer).

The space complexity is O(1) since we are using fixed-size arrays to store character frequencies.

Optimized Implementation:


class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> anagramIndices = new ArrayList<>();
        int n = s.length();
        int m = p.length();

        int[] charFrequencyS = new int[26];
        int[] charFrequencyP = new int[26];

        // Populate charFrequencyP with character frequencies of string p
        for (char ch : p.toCharArray()) {
            charFrequencyP[ch - 'a']++;
        }

        int left = 0;
        for (int right = 0; right < n; right++) {
            char rightChar = s.charAt(right);
            charFrequencyS[rightChar - 'a']++;

            // Shrink the window from the left side if its size becomes greater than m
            if (right - left + 1 > m) {
                char leftChar = s.charAt(left);
                charFrequencyS[leftChar - 'a']--;
                left++;
            }

            // Check if the current window is an anagram
            if (isAnagram(charFrequencyS, charFrequencyP)) {
                anagramIndices.add(left);
            }
        }

        return anagramIndices;
    }

    private boolean isAnagram(int[] charFrequencyS, int[] charFrequencyP) {
        for (int i = 0; i < 26; i++) {
            if (charFrequencyS[i] != charFrequencyP[i]) {
                return false;
            }
        }
        return true;
    }
}

-------------------------------------------------------
9. Subarrays with K Different Integers (hard) - LeetCode #992

-------------------------------------------------------
10. Minimum Size Subarray Sum (medium) - LeetCode #209

Given an array of positive integers nums and a positive integer target, return the minimal length of a 
subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.

Example 1:

Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.
Example 2:

Input: target = 4, nums = [1,4,4]
Output: 1
Example 3:

Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0

Algorithm:

The given solution uses a sliding window approach to find the minimum size subarray whose sum is greater than or equal to the given target. The idea is to keep a window whose sum is greater than or equal to the target and continuously shrink the window from the left side until the sum becomes less than the target. During this process, we keep track of the minimum window size encountered so far.

Explanation:

Initialize two pointers start and end to represent the window. Set start and end to 0 initially.

Initialize a variable sum to keep track of the sum of elements in the current window. Set sum to 0 initially.

Initialize a variable min to store the minimum size of the subarray whose sum is greater than or equal to the target. Set min to Integer.MAX_VALUE initially.

Iterate through the array nums using the start pointer:

Add the value at the start pointer to the current sum.

Check if the sum is greater than or equal to the target.

If sum is greater than or equal to the target, it means the current window's sum satisfies the condition. So, we update the min variable with the minimum of its current value and the window size (start - end + 1).

Shrink the window from the left side by moving the end pointer one step to the right and subtracting the value at the end pointer from the current sum.

Continue the inner loop until the sum becomes less than the target.

After the loop, return the min variable as the result. If min is still Integer.MAX_VALUE, it means no subarray satisfies the condition, so return 0.

Time Complexity:

The time complexity of the given solution is O(n), where n is the length of the input array nums. This is because both start and end pointers traverse the array from left to right exactly once.

Space Complexity:

The space complexity is O(1) because the solution uses a constant amount of extra space to store the variables start, end, sum, and min.

Implementation:

class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int start = 0, end = 0;
        int sum = 0;
        int min = Integer.MAX_VALUE;
        
        for (start = 0; start < nums.length; start++) {
            sum += nums[start];
            while (sum >= target) {
                min = Math.min(min, (start - end + 1));
                sum -= nums[end++];
            }
        }
        
        return min == Integer.MAX_VALUE ? 0 : min;
    }
}

-------------------------------------------------------
11. Shortest Subarray with Sum at Least K (hard) - LeetCode #862

-------------------------------------------------------
12. Replace the Substring for Balanced String (medium) - LeetCode #1234

You are given a string s of length n containing only four kinds of characters: 'Q', 'W', 'E', and 'R'.

A string is said to be balanced if each of its characters appears n / 4 times where n is the length of the string.

Return the minimum length of the substring that can be replaced with any other string of the same length to make s balanced. 
If s is already balanced, return 0.

Example 1:

Input: s = "QWER"
Output: 0
Explanation: s is already balanced.
Example 2:

Input: s = "QQWE"
Output: 1
Explanation: We need to replace a 'Q' to 'R', so that "RQWE" (or "QRWE") is balanced.
Example 3:

Input: s = "QQQW"
Output: 2
Explanation: We can replace the first "QQ" to "ER". 


Approach :
Calculate the expected count count of each character in a balanced string. Since there are four kinds of characters ('Q', 'W', 'E', and 'R'), the expected count for each character is n / 4, where n is the length of the string s.

Create a HashMap charFrequency to store the character frequencies in the string. Loop through each character in the string s and populate the HashMap, incrementing the count for each character.

Initialize two pointers, left and right, to represent the window. These pointers will help us track the substring that needs to be replaced.

Start traversing the string from left to right using the right pointer. For each character at the right pointer, decrement its count in the charFrequency HashMap.

Move the right pointer to the right to expand the window.

Enter a loop to shrink the window from the left side. This loop runs as long as the window is balanced (i.e., the character frequencies are within the expected counts).

Inside the loop, calculate the length of the current window (right - left) and update minLength with the minimum of its current value and the length of the current window.

Increment the count of the character at the left pointer in the charFrequency HashMap, effectively removing it from the window.

Move the left pointer to the right to shrink the window further.

Return the minLength as the result.

The isBalanced helper function checks if the current window is balanced. It iterates through the values (character frequencies) of the charFrequency HashMap and returns false if any character's count exceeds the expected count.

Code :

class Solution {
    public int balancedString(String s) {
        int n = s.length();
        int count = n / 4;
        int minLength = n;
        
        // Calculate the expected count of each character in a balanced string
        HashMap<Character, Integer> charFrequency = new HashMap<>();
        for (char ch : s.toCharArray()) {
            charFrequency.put(ch, charFrequency.getOrDefault(ch, 0) + 1);
        }
        
        // Initialize pointers to represent the window
        int left = 0;
        int right = 0;
        
        // Traverse the string to find the minimum length of the substring to replace
        while (right < n) {
            char rightChar = s.charAt(right);
            charFrequency.put(rightChar, charFrequency.get(rightChar) - 1);
            right++;
            
            // Shrink the window from the left side if it is balanced
            while (left < n && isBalanced(charFrequency, count)) {
                minLength = Math.min(minLength, right - left);
                char leftChar = s.charAt(left);
                charFrequency.put(leftChar, charFrequency.get(leftChar) + 1);
                left++;
            }
        }
        
        return minLength;
    }
    
    // Helper function to check if the current window is balanced
    private boolean isBalanced(HashMap<Character, Integer> charFrequency, int count) {
        for (int freq : charFrequency.values()) {
            if (freq > count) {
                return false;
            }
        }
        return true;
    }
}

TC and SC :
TC = O(N) and SC = O(1)

-------------------------------------------------------
14. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit (medium) - LeetCode #1438


Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.

 

Example 1:

Input: nums = [8,2,4,7], limit = 4
Output: 2 
Explanation: All subarrays are: 
[8] with maximum absolute diff |8-8| = 0 <= 4.
[8,2] with maximum absolute diff |8-2| = 6 > 4. 
[8,2,4] with maximum absolute diff |8-2| = 6 > 4.
[8,2,4,7] with maximum absolute diff |8-2| = 6 > 4.
[2] with maximum absolute diff |2-2| = 0 <= 4.
[2,4] with maximum absolute diff |2-4| = 2 <= 4.
[2,4,7] with maximum absolute diff |2-7| = 5 > 4.
[4] with maximum absolute diff |4-4| = 0 <= 4.
[4,7] with maximum absolute diff |4-7| = 3 <= 4.
[7] with maximum absolute diff |7-7| = 0 <= 4. 
Therefore, the size of the longest subarray is 2.
Example 2:

Input: nums = [10,1,2,4,7,2], limit = 5
Output: 4 
Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.
Example 3:

Input: nums = [4,2,2,2,4,4,2,2], limit = 0
Output: 3


Explanation:

We use a TreeMap freqMap to keep track of the frequencies of elements in the current window. The TreeMap is sorted based on the elements' natural order, allowing us to efficiently access the minimum and maximum elements within the window.

The left and right pointers are used to represent the window boundaries, just like in the previous solutions.

We traverse the array from left to right using the right pointer and perform the following steps:

For each element at the right pointer, add it to the freqMap and update its frequency count.

Calculate the absolute difference between the maximum and minimum elements in the current window (freqMap.lastKey() - freqMap.firstKey()).

While the absolute difference is greater than the limit, it means the current window is invalid, and we need to adjust the left pointer and update the frequency map.

We decrement the frequency count of the element at the left pointer and remove it from the freqMap if its frequency becomes 0. We increment the left pointer until the absolute difference becomes less than or equal to the limit.

After adjusting the window, we update the maxWindowSize with the maximum of its current value and the size of the current window (right - left + 1).

After the loop, we return the maxWindowSize as the result.

Time Complexity:
The time complexity of this approach is O(n * log(n)), where n is the size of the input array nums. Both the left and right pointers traverse the array exactly once. For each right pointer, we perform insertion and deletion operations on the TreeMap, which take O(log(n)) time. In the worst case, the TreeMap can have n distinct elements, resulting in an overall time complexity of O(n * log(n)).

Space Complexity:
The space complexity is O(n), where n is the size of the input array nums. In the worst case, the TreeMap can have n distinct elements.


Code:
import java.util.TreeMap;

class Solution {
    public int longestSubarray(int[] nums, int limit) {
        TreeMap<Integer, Integer> freqMap = new TreeMap<>();
        int left = 0;
        int maxWindowSize = 0;

        for (int right = 0; right < nums.length; right++) {
            freqMap.put(nums[right], freqMap.getOrDefault(nums[right], 0) + 1);

            // While the absolute difference between the minimum and maximum elements in the current window
            // is greater than the limit, adjust the left pointer and update the frequency map.
            while (freqMap.lastKey() - freqMap.firstKey() > limit) {
                freqMap.put(nums[left], freqMap.get(nums[left]) - 1);
                if (freqMap.get(nums[left]) == 0) {
                    freqMap.remove(nums[left]);
                }
                left++;
            }

            // Update the maxWindowSize
            maxWindowSize = Math.max(maxWindowSize, right - left + 1);
        }

        return maxWindowSize;
    }
}


-------------------------------------------------------
15. Max Consecutive Ones III (medium) - LeetCode #1004

Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.

Example 1:

Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
Output: 6
Explanation: [1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
Example 2:

Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
Output: 10
Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.

BRUTE FORCE:

Initialize a variable maxConsecutiveOnes to keep track of the maximum length of consecutive 1's found so far.
Use a nested loop to consider all possible subarrays with at most k flips.
For each subarray, maintain two variables flipsLeft and consecutiveOnes. flipsLeft represents the number of flips available, and consecutiveOnes counts the consecutive 1's in the subarray.
If the current element is 1, increment consecutiveOnes.
If the current element is 0 and there are flips available (flipsLeft > 0), we can consider flipping it to 1. Increment consecutiveOnes and decrement flipsLeft.
If the current element is 0, and no more flips are available (flipsLeft == 0), we cannot consider flipping it, so we break the inner loop.
Update maxConsecutiveOnes with the maximum of its current value and consecutiveOnes.
After both loops, return the maxConsecutiveOnes as the result.
Time Complexity:
The time complexity of the brute force approach is O(n^2), where n is the length of the input array nums. The nested loops consider all possible subarrays, leading to a quadratic time complexity.

Space Complexity:
The space complexity is O(1) since we are using only a few variables to keep track of the state, and we are not using any additional data structures with a size dependent on the input.

class Solution {
    public int longestOnes(int[] nums, int k) {
        int maxConsecutiveOnes = 0;

        for (int i = 0; i < nums.length; i++) {
            int flipsLeft = k;
            int consecutiveOnes = 0;

            for (int j = i; j < nums.length; j++) {
                if (nums[j] == 1) {
                    consecutiveOnes++;
                } else {
                    if (flipsLeft > 0) {
                        consecutiveOnes++;
                        flipsLeft--;
                    } else {
                        break;
                    }
                }

                maxConsecutiveOnes = Math.max(maxConsecutiveOnes, consecutiveOnes);
            }
        }

        return maxConsecutiveOnes;
    }
}


OPTIMIZED SLIDING WINDOW:
Algorithm:

Initialize left and right pointers to represent the window boundaries.
Initialize a variable maxConsecutiveOnes to keep track of the maximum length of consecutive 1's found so far.
Initialize a variable flipsLeft to represent the number of flips available.
Traverse the array using the right pointer.
If the current element is 0, decrement flipsLeft.
While flipsLeft becomes negative (i.e., the number of flips used exceeds the allowed k flips), we need to move the left pointer to shrink the window. If the element at the left pointer is 0, increment flipsLeft to free up a flip. Move the left pointer to the right to shrink the window.
Update maxConsecutiveOnes with the maximum of its current value and the size of the current window (right - left + 1).
After the loop, return the maxConsecutiveOnes as the result.
Time Complexity:
The time complexity of the optimized approach is O(n), where n is the length of the input array nums. Both the left and right pointers traverse the array exactly once. The while loop inside the for loop performs constant-time operations, and the overall time complexity is linear.

Space Complexity:
The space complexity is O(1) since we are using only a few variables to keep track of the state, and we are not using any additional data structures with a size dependent on the input.

class Solution {
    public int longestOnes(int[] nums, int k) {
        int left = 0;
        int maxConsecutiveOnes = 0;
        int flipsLeft = k;

        for (int right = 0; right < nums.length; right++) {
            if (nums[right] == 0) {
                flipsLeft--;
            }

            while (flipsLeft < 0) {
                if (nums[left] == 0) {
                    flipsLeft++;
                }
                left++;
            }

            maxConsecutiveOnes = Math.max(maxConsecutiveOnes, right - left + 1);
        }

        return maxConsecutiveOnes;
    }
}

-------------------------------------------------------------
-------------------------------------------------------------
##Heap


1. Kth Largest Element in an Array (Question #215) [Medium]:
Given an integer array nums and an integer k, return the kth largest element in the array.

Note that it is the kth largest element in the sorted order, not the kth distinct element.

Can you solve it without sorting?


Example 1:

Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
Example 2:

Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4

Approach:
The min heap will keep track of the k largest elements seen so far, with the smallest element at the top (root) of the heap. When the heap contains k elements, the smallest element will be the kth largest element among all elements seen so far.

1. We initialize an empty priority queue (`queue`) which acts as a min-heap.

2. We iterate through each element `i` in the input `nums` array.

3. If the priority queue (`queue`) has already k elements, we check if the smallest element (top element) in the min heap (`queue.peek()`) is less than the current element `i`. If it is, it means `i` is larger than the smallest element, so we remove the smallest element from the min heap and add the current element `i` to the heap. This ensures that we keep track of the k largest elements in the min heap at all times.

4. If the priority queue has less than k elements, we simply add the current element `i` to the min heap.

5. After processing all elements in the input array, the top element of the min heap (`queue.poll()`) will be the kth largest element.

Time Complexity (TC):
The time complexity of this algorithm is O(N log K), where N is the number of elements in the input array and K is the value of `k`. For each element, we perform heap operations (`offer()` and `poll()`), which take O(log K) time in the worst case. Since we have N elements, the overall time complexity is O(N log K).

Space Complexity (SC):
The space complexity of this algorithm is O(K) because we use a min heap (PriorityQueue) to store at most k elements at any given time.

```java
public int findKthLargest(int[] nums, int k) {
    PriorityQueue<Integer> queue = new PriorityQueue<>();

    for (int i : nums) {
        if (queue.size() == k) {
            // If the priority queue (min heap) has already k elements, compare the smallest element with the current element i.
            // If i is greater than the smallest element (i.e., the top element of the min heap), remove the smallest element and add i to the heap.
            if (queue.peek() < i) {
                queue.poll(); // Remove the smallest element from the min heap.
                queue.offer(i); // Add the current element i to the min heap.
            }
        } else {
            queue.offer(i); // If the priority queue has less than k elements, simply add the current element i to the min heap.
        }
    }

    return queue.poll(); // After processing all elements, the top element of the min heap will be the kth largest element.
}
```


1. **Kth Largest Element in an Array**
   - LeetCode #215

2. **Merge k Sorted Lists**
   - LeetCode #23

3. **Top K Frequent Elements**
   - LeetCode #347

4. **Find Median from Data Stream**
   - LeetCode #295

5. **Kth Smallest Element in a BST**
   - LeetCode #230

6. **Sliding Window Maximum**
   - LeetCode #239

7. **Find K Pairs with Smallest Sums**
   - LeetCode #373

8. **Sort Characters By Frequency**
   - LeetCode #451

9. **Find K Closest Elements**
   - LeetCode #658

10. **Top K Frequent Words**
    - LeetCode #692

11. **Find Median from Data Stream**
    - LeetCode #295

12. **Last Stone Weight**
    - LeetCode #1046

13. **Find Kth Smallest Pair Distance**
    - LeetCode #719

14. **K Closest Points to Origin**
    - LeetCode #973

15. **Smallest Range Covering Elements from K Lists**
    - LeetCode #632

16. **Kth Largest Element in a Stream**
    - LeetCode #703

17. **Find the Kth Smallest Sum of a Matrix With Sorted Rows**
    - LeetCode #1439

18. **Find K Pairs with Smallest Sums**
    - LeetCode #373

19. **Find Kth Smallest Element in a Sorted Matrix**
    - LeetCode #378

20. **Find K Closest Elements**
    - LeetCode #658

--------------------------------------------------------------
--------------------------------------------------------------

##LinkedList

1. Reverse Linked List - LeetCode #206

2. **Detect Cycle in a Linked List**
   - LeetCode #141

3. **Find the Middle of a Linked List**
   - LeetCode #876

4. **Merge Two Sorted Lists**
   - LeetCode #21

5. **Remove Nth Node From End of List**
   - LeetCode #19

6. **Add Two Numbers as Linked Lists**
   - LeetCode #2

7. **Palindrome Linked List**
   - LeetCode #234

8. **Intersection of Two Linked Lists**
   - LeetCode #160

9. **Linked List Cycle II**
   - LeetCode #142

10. **Remove Duplicates from Sorted List**
    - LeetCode #83

11. **Flatten a Multilevel Doubly Linked List**
    - LeetCode #430

12. **Rotate List**
    - LeetCode #61

13. **Sort List**
    - LeetCode #148

14. **Swap Nodes in Pairs**
    - LeetCode #24

15. **Copy List with Random Pointer**
    - LeetCode #138

16. **Reverse Nodes in k-Group**
    - LeetCode #25

17. **Delete Node in a Linked List**
    - LeetCode #237

18. **Odd Even Linked List**
    - LeetCode #328

19. **Convert Sorted List to Binary Search Tree**
    - LeetCode #109

20. **Remove Linked List Elements**
    - LeetCode #203

--------------------------------------------------------------
--------------------------------------------------------------
#Tree

1. **Binary Tree Inorder Traversal**
   - LeetCode #94

2. **Validate Binary Search Tree**
   - LeetCode #98

3. **Maximum Depth of Binary Tree**
   - LeetCode #104

4. **Symmetric Tree**
   - LeetCode #101

5. **Binary Tree Level Order Traversal**
   - LeetCode #102

6. **Path Sum**
   - LeetCode #112

7. **Construct Binary Tree from Preorder and Inorder Traversal**
   - LeetCode #105

8. **Construct Binary Tree from Inorder and Postorder Traversal**
   - LeetCode #106

9. **Lowest Common Ancestor of a Binary Tree**
   - LeetCode #236

10. **Binary Tree Maximum Path Sum**
    - LeetCode #124

11. **Binary Tree Zigzag Level Order Traversal**
    - LeetCode #103

12. **Invert Binary Tree**
    - LeetCode #226

13. **Same Tree**
    - LeetCode #100

14. **Binary Tree Right Side View**
    - LeetCode #199

15. **Binary Tree Preorder Traversal**
    - LeetCode #144

16. **Binary Tree Postorder Traversal**
    - LeetCode #145

17. **Binary Search Tree Iterator**
    - LeetCode #173

18. **Kth Smallest Element in a BST**
    - LeetCode #230

19. **Subtree of Another Tree**
    - LeetCode #572

20. **Binary Tree Cameras**
    - LeetCode #968

--------------------------------------------------------------
--------------------------------------------------------------
#Array

1. **Two Sum**
   - LeetCode #1

2. **Best Time to Buy and Sell Stock**
   - LeetCode #121

3. **Contains Duplicate**
   - LeetCode #217

4. **Product of Array Except Self**
   - LeetCode #238

5. **Maximum Subarray**
   - LeetCode #53

6. **Move Zeroes**
   - LeetCode #283

7. **3Sum**
   - LeetCode #15

8. **Merge Intervals**
   - LeetCode #56

9. **Rotate Array**
   - LeetCode #189

10. **Group Anagrams**
    - LeetCode #49

11. **Valid Sudoku**
    - LeetCode #36

12. **Container With Most Water**
    - LeetCode #11

13. **Minimum Size Subarray Sum**
    - LeetCode #209

14. **Search in Rotated Sorted Array**
    - LeetCode #33

15. **Find First and Last Position of Element in Sorted Array**
    - LeetCode #34

16. **Set Matrix Zeroes**
    - LeetCode #73

17. **Jump Game**
    - LeetCode #55

18. **Majority Element**
    - LeetCode #169

19. **Missing Number**
    - LeetCode #268

20. **Valid Parentheses**
    - LeetCode #20

--------------------------------------------------------------
--------------------------------------------------------------

#Stack

1. **Valid Parentheses**
   - LeetCode #20

2. **Min Stack**
   - LeetCode #155

3. **Evaluate Reverse Polish Notation**
   - LeetCode #150

4. **Decode String**
   - LeetCode #394

5. **Longest Valid Parentheses**
   - LeetCode #32

6. **Implement Queue using Stacks**
   - LeetCode #232

7. **Next Greater Element I**
   - LeetCode #496

8. **Daily Temperatures**
   - LeetCode #739

9. **Remove All Adjacent Duplicates In String**
   - LeetCode #1047

10. **Backspace String Compare**
    - LeetCode #844

11. **Implement Stack using Queues**
    - LeetCode #225

12. **Online Stock Span**
    - LeetCode #901

13. **Valid Parenthesis String**
    - LeetCode #678

14. **Remove Outermost Parentheses**
    - LeetCode #1021

15. **Score of Parentheses**
    - LeetCode #856

16. **Largest Rectangle in Histogram**
    - LeetCode #84

17. **Baseball Game**
    - LeetCode #682

18. **Flood Fill**
    - LeetCode #733

19. **Maximal Rectangle**
    - LeetCode #85

20. **Trapping Rain Water**
    - LeetCode #42

--------------------------------------------------------------
--------------------------------------------------------------

#Queue

1. **Implement Queue using Stacks**
   - LeetCode #232

2. **Queue Reconstruction by Height**
   - LeetCode #406

3. **Design Circular Queue**
   - LeetCode #622

4. **Sliding Window Maximum**
   - LeetCode #239

5. **Implement Stack using Queues**
   - LeetCode #225

6. **Moving Average from Data Stream**
   - LeetCode #346

7. **Number of Recent Calls**
   - LeetCode #933

8. **Design Circular Deque**
   - LeetCode #641

9. **The Maze**
   - LeetCode #490

10. **Shortest Path in Binary Matrix**
    - LeetCode #1091

11. **Perfect Squares**
    - LeetCode #279

12. **Binary Tree Right Side View**
    - LeetCode #199

13. **Rotten Oranges**
    - LeetCode #994

14. **As Far from Land as Possible**
    - LeetCode #1162

15. **Moving Average from Data Stream**
    - LeetCode #346

16. **Snakes and Ladders**
    - LeetCode #909

17. **Open the Lock**
    - LeetCode #752

18. **Implement Stack using Queues**
    - LeetCode #225

19. **Sliding Window Maximum**
    - LeetCode #239

20. **Design Circular Queue**
    - LeetCode #622

--------------------------------------------------------------
--------------------------------------------------------------

##HashMap

--------------------------------------------------------------
1. Two Sum (Question #1):
Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.
Example:
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: The sum of 2 and 7 equals 9, so the output is [0,1].

public int[] twoSum(int[] nums, int target) {
    HashMap<Integer, Integer> map = new HashMap<>();

    for (int i = 0; i < nums.length; i++){
        int complement = target - nums[i];
        if (map.containsKey(complement)){
            return new int[] {map.get(complement), i};
        }
        map.put(nums[i], i);
    }
    return new int[]{};
}

-------------------------------------------------

2. **Valid Anagram**
   - LeetCode #242

3. **Two Sum III - Data Structure Design**
   - LeetCode #170

4. **Contains Duplicate**
   - LeetCode #217

5. **Longest Substring Without Repeating Characters**
   - LeetCode #3

6. **Most Common Word**
   - LeetCode #819

7. **Word Pattern**
   - LeetCode #290

8. **First Unique Character in a String**
   - LeetCode #387

9. **Minimum Window Substring**
   - LeetCode #76

10. **Group Anagrams**
    - LeetCode #49

11. **Subarray Sum Equals K**
    - LeetCode #560

12. **Intersection of Two Arrays II**
    - LeetCode #350

13. **Find All Anagrams in a String**
    - LeetCode #438

14. **Longest Consecutive Sequence**
    - LeetCode #128

15. **Isomorphic Strings**
    - LeetCode #205

16. **Top K Frequent Elements**
    - LeetCode #347

17. **Sort Characters By Frequency**
    - LeetCode #451

18. **Minimum Index Sum of Two Lists**
    - LeetCode #599

19. **Two Sum IV - Input is a BST**
    - LeetCode #653

20. **Fraction to Recurring Decimal**
    - LeetCode #166


