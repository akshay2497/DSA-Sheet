##Algorithm - Two Pointers
----------------------------------------------------------
1. Container With Most Water (Question #11):
Given `n` non-negative integers `height`, where each represents a point at coordinate `(i, height[i])`, n vertical lines are drawn such that the two endpoints of the line `i` are at `(i, height[i])` and `(i, 0)`. Find two lines, which, together with the x-axis, forms a container, such that the container contains the most water.
Example:
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The maximum area is obtained by choosing the second and sixth vertical lines.

Approach :
Initialize two pointers, start and end, pointing to the first and last indices of the array.
Initialize a variable maxArea to keep track of the maximum water area encountered so far.
While the start pointer is less than the end pointer:
Calculate the current water area using the formula: area = (end - start) * min(height[start], height[end]).
Update maxArea if the current area is greater than the previous maximum.
Move the pointer that points to the smaller height inward, as moving the pointer with the larger height won't increase the area.
Repeat step 3 until the pointers meet, indicating that all possible areas have been considered.
Return the maxArea as the result.

In this solution, we iterate through the array once using the two-pointer technique, resulting in a time complexity of O(n), where n is the number of elements in the array. The space complexity is O(1) as we only use a constant amount of extra space.

Java code :

public int maxArea(int[] height) {
    int n = height.length;
    int start = 0;
    int end = n - 1;
    int maxWaterArea = Integer.MIN_VALUE;

    while (start < end) {
        int minHeight = Math.min(height[start], height[end]);
        int currWaterArea = (end - start) * minHeight;
        maxWaterArea = Math.max(maxWaterArea, currWaterArea);

        if (height[start] < height[end])
            start++;
        else 
            end--;
    }

    return maxWaterArea;
}
----------------------------------------------------------------
2. Three Sum (Question #15):
Given an array `nums` of `n` integers, find all unique triplets in the array which gives the sum of `0`.
Example:
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]

Approach:
To solve the Three Sum problem (Question #15), you can use the two-pointer technique combined with sorting the array. Here's how you can approach it:

1. Sort the given array in non-decreasing order. This step allows us to use the two-pointer technique effectively.
2. Iterate through the array from left to right, considering each element as a potential first element of the triplet.
   - Skip duplicate elements to avoid duplicate triplets.
   - For each element, set two pointers, `left` and `right`, initially pointing to the next element and the last element, respectively.
   - While `left` is less than `right`, calculate the sum of the three elements (current element + `nums[left]` + `nums[right]`).
     - If the sum is equal to zero, add the triplet `[nums[i], nums[left], nums[right]]` to the result set.
     - If the sum is less than zero, increment `left` to increase the sum.
     - If the sum is greater than zero, decrement `right` to decrease the sum.
     - Skip duplicate elements for `left` and `right` to avoid duplicate triplets.
3. Repeat step 2 until all elements have been considered as potential first elements.
4. Return the list of unique triplets that sum to zero.

In this solution, we sort the array first, which takes O(nlogn) time. Then, we iterate through the array using the two-pointer technique, resulting in a time complexity of O(n^2). The space complexity is O(1) as we only use a constant amount of extra space.

public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    if (nums.length < 3) {
        return result;
    }
    Arrays.sort(nums);
    int n = nums.length;

    for (int i = 0; i < n-2; i++){
        //Check if i is not 0 and i-1 element should not be same to i'th
        //element else skip that triplet
        if (i > 0 && nums[i] == nums[i-1]) {
            continue;
        }
        int left = i+1;
        int right = n-1;

        while (left < right) {
            int target = nums[i] + nums[left] + nums[right];
            if (target == 0) {
                result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                //avoid duplicates on left ptr
                while(left < right && nums[left] == nums[left+1]) {
                    left++;
                }

                //avoid duplicates on right ptr
                while(left < right && nums[right] == nums[right-1]) {
                    right--;
                }
                left++;
                right--;
            } else if (target < 0){
                left++;
            } else {
                right--;
            }
        }
    }
    return result;
}
----------------------------------------------------------------

3. Remove Duplicates from Sorted Array (Question #26):
Given a sorted array `nums`, remove the duplicates in-place such that each element appears only once and returns the new length.
Example:
Input: nums = [1,1,2]
Output: 2

Approach
1. Initialize two pointers, `ptr1` and `ptr2`, both initially set to 0 and 1 respectively. 
2. Iterate till ptr2 < array length
3. if nums[ptr1] == nums[ptr2] that means duplicates increment ptr2
4. if nums[ptr1] != nums[ptr2] that means distinct elements increment ptr1 and swap elements on both pointers increment both pointers
5. finally return ptr1+1 value that will be your total distinct elements

TC : O(N) - SC : O(1)

public int removeDuplicates(int[] nums) {
    if (nums.length < 2){
        return nums.length;
    }
    int n = nums.length;
    int ptr1 = 0;
    int ptr2 = 1;
    while (ptr2 < n) {
        if (nums[ptr1] == nums[ptr2]) {
            ptr2++;
        } else {
            ptr1++;
            int temp = nums[ptr2];
            nums[ptr2] = nums[ptr1];
            nums[ptr1] = temp;
            ptr2++;
        }
    }
    return ++ptr1;
}
----------------------------------------------------

4. Linked List Cycle II (Question #142):
Given a linked list, return the node where the cycle begins. If there is no cycle, return `null`.
Example:
Input: head = [3,2,0,-4], pos = 1
Output: the node with value 2
Explanation: There is a cycle in the linked list, where the tail connects to the second node.

To solve the Linked List Cycle II problem (Question #142), you can use the Floyd's Tortoise and Hare algorithm, also known as the "fast and slow pointers" technique. Here's how you can approach it:

1. Initialize two pointers, `slow` and `fast`, both initially set to the head of the linked list.
2. Move `slow` one step at a time and `fast` two steps at a time through the linked list.
3. Continue moving the pointers until they meet or `fast` reaches the end of the linked list (i.e., it becomes `null`).
   - If `fast` becomes `null`, it means there is no cycle in the linked list. Return `null`.
   - If `slow` and `fast` meet, it indicates the presence of a cycle in the linked list.
4. Reset the `slow` pointer to the head of the linked list and keep `fast` at the meeting point.
5. Move both pointers one step at a time until they meet again. The meeting point will be the start of the cycle.
6. Return the node at which the cycle starts.


Proof : 

1. Once the `fast` and `slow` pointers meet inside the cycle, let's say the distance from the head of the linked list to the start of the cycle is `D`, and the distance from the start of the cycle to the meeting point of the two pointers is `K`.

2. When the `fast` pointer catches up to the `slow` pointer, it has traveled twice the distance as the `slow` pointer. Therefore, the `fast` pointer has traveled a total distance of `D + K + C` (where `C` represents the number of complete cycles the `fast` pointer made within the cycle), while the `slow` pointer has traveled a distance of `D + K`.

3. Since the `fast` pointer moves twice as fast as the `slow` pointer, we can express their respective distances as follows: `2(D + K) = D + K + C`, which simplifies to `D + K = C`. This equation tells us that the distance from the head of the linked list to the start of the cycle is equal to the number of complete cycles within the cycle.

4. By resetting the `slow` pointer to the head of the linked list and keeping the `fast` pointer at the meeting point, and then moving both pointers one step at a time, the `slow` pointer will travel a distance of `D` to reach the start of the cycle, while the `fast` pointer will travel a distance of `C` within the cycle.

5. As the `slow` and `fast` pointers continue moving, they will eventually meet again at the start of the cycle. This is because the `slow` pointer has traveled a distance of `D`, while the `fast` pointer has traveled a distance of `C`, and we know from step 3 that `D` is equal to `C`.

In this solution, we use two pointers to detect the cycle and find the node where the cycle starts. The time complexity of this algorithm is O(n), where n is the number of nodes in the linked list. The space complexity is O(1) as we only use a constant amount of extra space.

Code : 
public ListNode detectCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;

    while(fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (fast == slow){
            break;
        }
    }

    if (fast == null || fast.next == null){
        return null;
    }

    slow = head;

    while (slow != fast) {
        slow = slow.next;
        fast = fast.next;
    }

    return slow;
}
-------------------------------------------------------------
5. Reverse Linked List II (Question #92):
Reverse a linked list from position `m` to `n`. Do it in one-pass and without using extra memory.
Example:
Input: 1 -> 2 -> 3 -> 4 -> 5, m = 2, n = 4
Output: 1 -> 4 -> 3 -> 2 -> 5

--------------------------------------------------------------

6. Longest Palindromic Substring (Question #5):
Given a string `s`, return the longest palindromic substring in `s`.
Example:
Input: "babad"
Output: "bab" or "aba"

class Solution {
    int totalSubStringLength = 0;
    int startPoint = 0;

    public String longestPalindrome(String s) {
        int n = s.length();

        // Iterate through each character of the input string
        for (int i = 0; i < n; i++) {
            findPalindrome(s, i, i);      // Consider current character as the center of a palindrome with an odd length
            findPalindrome(s, i, i+1);    // Consider current character and the next character as the center of a palindrome with an even length
        }

        // Return the longest palindromic substring using the startPoint and totalSubStringLength variables
        return s.substring(startPoint, startPoint + totalSubStringLength);
    }

    public void findPalindrome(String s, int start, int end) {
        // Expand around the center indices until the characters are equal or the boundary is reached
        while (start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end)) {
            start--;
            end++;
        }

        // Check if the length of the current palindrome is greater than the stored length
        if (totalSubStringLength < end - start - 1) {
            startPoint = start + 1;                          // Update the starting index of the longest palindrome
            totalSubStringLength = end - start - 1;          // Update the length of the longest palindrome
        }
    }
}

1. The class defines two member variables: `totalSubStringLength` and `startPoint`.
   - `totalSubStringLength` stores the length of the longest palindromic substring found so far.
   - `startPoint` stores the starting index of the longest palindromic substring found so far.

2. The `longestPalindrome` method takes the input string `s` and returns the longest palindromic substring in `s`.

3. The method initializes `totalSubStringLength` and `startPoint` to 0.

4. The method iterates through each character of the input string `s` using a `for` loop.

5. For each character at index `i`, the method calls the `findPalindrome` method twice:
   - The first call considers the current character as the center of a palindrome with an odd length.
   - The second call considers the current character and the next character as the center of a palindrome with an even length.

6. The `findPalindrome` method is responsible for expanding around the center indices to find the length of the palindrome.

7. The `findPalindrome` method uses a `while` loop to expand the palindrome by checking if the characters at indices `start` and `end` are equal. It continues expanding as long as the characters are equal and there are characters available on both sides.

8. After the `while` loop, the `findPalindrome` method checks if the length of the current palindrome (given by `end - start - 1`) is greater than the stored length (`totalSubStringLength`).

9. If the length of the current palindrome is indeed longer, the `findPalindrome` method updates `startPoint` with the new starting index (`start + 1`) and `totalSubStringLength` with the new length (`end - start - 1`).

10. The `longestPalindrome` method returns the substring of `s` starting from `startPoint` and with a length of `totalSubStringLength`, representing the longest palindromic substring found in the input string.

The provided code is another valid implementation for finding the Longest Palindromic Substring. Here's an explanation of the code, with a focus on the specific block you mentioned:

```java
if (totalSubStringLength < end - start - 1) {
    startPoint = start + 1;
    totalSubStringLength = end - start - 1;
}
```

This block of code is responsible for updating the variables `startPoint` and `totalSubStringLength` when a longer palindromic substring is found.

- `totalSubStringLength` keeps track of the length of the longest palindromic substring found so far.
- `startPoint` stores the starting index of the longest palindromic substring found so far.

Here's how the block works:

1. The block is inside the `findPalindrome` method, which is called for each character in the string `s`.

2. The `while` loop inside `findPalindrome` expands the palindromic substring by checking if the characters at indices `start` and `end` are equal. It continues expanding as long as the characters are equal and there are characters available on both sides.

3. After the `while` loop, the block checks if the length of the current palindrome (given by `end - start - 1`) is greater than the stored length (`totalSubStringLength`).

4. If the length of the current palindrome is indeed longer, the block updates `startPoint` with the new starting index (`start + 1`) and `totalSubStringLength` with the new length (`end - start - 1`).

By updating these variables, the block ensures that `startPoint` and `totalSubStringLength` always store the starting index and length of the longest palindromic substring found so far during the iterations.

After the iterations are complete, the `longestPalindrome` method returns the substring of `s` starting from `startPoint` and with a length of `totalSubStringLength`, representing the longest palindromic substring found in the input string.


Time complexity Explanation

1. The `longestPalindrome` method contains a `for` loop that iterates through each character of the input string. Since there are n characters in the string, this loop has a time complexity of O(n).

2. Inside the `for` loop, the `findPalindrome` method is called twice for each character. This results in a nested loop structure where, in the worst case, each iteration of the outer loop triggers a loop iteration in the `findPalindrome` method.

3. The `findPalindrome` method contains a `while` loop that expands around the center indices until the characters are no longer equal or the boundary of the string is reached. This expansion process has a time complexity of O(n) in the worst case, where n is the length of the string.

4. Since the `findPalindrome` method is called twice for each character in the `longestPalindrome` method, and the expansion process within each call has a time complexity of O(n), the overall time complexity of the `longestPalindrome` method is O(n * n) = O(n^2).

Therefore, the overall time complexity of the provided `Solution` class is O(n^2), where n is the length of the input string `s`.

--------------------------------------------------------------

7. Merge Intervals (Question #56):
Given an array of intervals `intervals` where `intervals[i] = [start_i, end_i]`, merge all overlapping intervals.
Example:
Input: [[1, 3], [2, 6], [8, 10], [15, 18]]
Output: [[1, 6], [8, 10], [15, 18]]

Solution:

1. Sort the intervals based on the starting points. This ensures that overlapping intervals will be adjacent to each other after sorting.

2. Initialize an empty list to store the merged intervals.

3. Iterate through the sorted intervals. For each interval, check if it overlaps with the previous merged interval or if it is non-overlapping.

4. If the current interval overlaps with the previous merged interval, update the end point of the merged interval if necessary to include the current interval.

5. If the current interval is non-overlapping, add the previous merged interval to the result list and set the current interval as the new merged interval.

6. After iterating through all intervals, add the last merged interval to the result list.

7. Return the result list containing the merged intervals.

```java
public int[][] merge(int[][] intervals) {
    if (intervals == null || intervals.length == 0) {
        return new int[0][];
    }

    // Sort the intervals based on the starting points
    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

    List<int[]> mergedIntervals = new ArrayList<>();
    int[] currentInterval = intervals[0];

    // Iterate through the sorted intervals
    for (int i = 1; i < intervals.length; i++) {
        int[] interval = intervals[i];

        // If the current interval overlaps with the previous merged interval, update the end point if necessary
        if (interval[0] <= currentInterval[1]) {
            currentInterval[1] = Math.max(currentInterval[1], interval[1]);
        }
        // If the current interval is non-overlapping, add the previous merged interval to the result list
        else {
            mergedIntervals.add(currentInterval);
            currentInterval = interval;
        }
    }

    // Add the last merged interval to the result list
    mergedIntervals.add(currentInterval);

    // Convert the list to a 2D array
    int[][] result = new int[mergedIntervals.size()][2];
    for (int i = 0; i < mergedIntervals.size(); i++) {
        result[i] = mergedIntervals.get(i);
    }

    return result;
}
```

Time and Space complexity:
The time complexity of this solution is O(n log n), where n is the number of intervals. The sorting step takes O(n log n) time, and the merging step iterates through the sorted intervals once, which takes O(n) time. The space complexity is O(n) as we store the merged intervals in a list.

--------------------------------------------------------------

8. Valid Parentheses (Question #20):
Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['`, `']'`, determine if the input string is valid.
Example:
Input: "{[]}"
Output: true

Solution:

1. The `isValid` method takes a string `s` as input and returns a boolean value indicating whether the parentheses in `s` are valid.

2. The method initializes a `Stack` data structure named `stack` to keep track of the opening parentheses encountered.

3. It also initializes a variable `n` with the length of the input string `s`.

4. The method iterates through each character of the input string using a `for` loop.

5. For each character, the method checks if it is an opening parenthesis (`(`, `[`, `{`). If so, it pushes the character onto the stack.

6. If the character is a closing parenthesis (`)`, `]`, `}`), the method checks if the stack is empty. If it is, this means there is no matching opening parenthesis for the current closing parenthesis, so the string is invalid, and the method returns `false`.

7. If the stack is not empty, the method pops the top character from the stack and compares it with the current closing parenthesis. If they do not match, this means the parentheses are not in the correct order, and the method returns `false`.

8. If all parentheses are matched and valid, the method continues the loop until all characters in the string are processed.

9. After the loop, the method checks if there are any remaining opening parentheses in the stack. If there are, this means the string is invalid because some opening parentheses were not closed, and the method returns `false`. Otherwise, it returns `true`.

The code follows a straightforward approach using a stack to track the opening parentheses encountered. It compares each closing parenthesis with the top of the stack to ensure that they match. If the stack is empty or the parentheses do not match, it returns `false`. Otherwise, if all parentheses are valid, it returns `true`.

Time and Space complexity :

The time complexity of this implementation is O(n), where n is the length of the input string `s`, as we iterate through each character once. The space complexity is O(n) as we use a stack to store opening parentheses, and in the worst case, all characters in `s` could be opening parentheses.

```Java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();

        int n = s.length();

        for (int i = 0; i < n; i++) {
            char currChar = s.charAt(i);

            if (currChar == '(' || currChar == '[' || currChar == '{') {
                stack.push(currChar);
            } else {
                if (stack.isEmpty()){
                    return false;
                }
                char poppedChar = stack.pop();
                if (currChar == ')' && poppedChar != '('){
                    return false;
                } else if (currChar == ']' && poppedChar != '[') {
                    return false;
                } else if (currChar == '}' && poppedChar != '{'){
                    return false;
                }
            }
        }
        return stack.size() > 0 ? false : true;
    }
}
```

--------------------------------------------------------------

9. Minimum Window Substring (Question #76):
Given two strings `s` and `t`, return the minimum window in `s` which will contain all the characters in `t` in complexity `O(n)`.
Example:
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"

Solution:

1. Initialize two pointers, `left` and `right`, to track the window boundaries. Set them both to 0 initially.

2. Create two frequency maps, `targetMap` and `windowMap`, to track the character frequencies of the target string `t` and the current window in string `s`, respectively. Initially, both maps should be empty.

3. Populate the `targetMap` by iterating through the characters of string `t`. For each character, update its frequency in the map.

4. Initialize variables to track the minimum window length (`minWindowLength`), the starting index of the minimum window (`minWindowStart`), and a counter to keep track of the characters in `t` that have been matched in the current window (`matchedCount`). Set the `matchedCount` to 0 initially.

5. Start iterating through the string `s` using the `right` pointer:
   - For each character encountered, update its frequency in the `windowMap`.
   - If the character is present in the `targetMap` and its frequency in the `windowMap` is less than or equal to its frequency in the `targetMap`, increment the `matchedCount` by 1.

6. Check if all characters in `t` have been matched in the current window:
   - If the `matchedCount` is equal to the length of the target string `t`, it means all characters in `t` have been matched. In this case, we have found a valid window.
   - Update the minimum window length and the starting index of the minimum window if necessary.

7. Shrink the window by moving the `left` pointer:
   - While the `left` pointer can be moved and the current window still contains all characters from `t`, update the `windowMap` and `matchedCount` accordingly.
   - Check if the updated window is still valid (contains all characters from `t`).
   - If the updated window is still valid, update the minimum window length and the starting index of the minimum window if necessary.

8. Repeat steps 5 to 7 until the `right` pointer reaches the end of the string `s`.

9. After the loop, check if a valid window was found. If so, return the substring of `s` that corresponds to the minimum window length, starting from the `minWindowStart` index. Otherwise, return an empty string.

Code:

```java
public String minWindow(String s, String t) {
    int[] targetMap = new int[128];  // Frequency map for target string t
    int[] windowMap = new int[128];  // Frequency map for current window in s

    // Populate the targetMap with character frequencies from string t
    for (char ch : t.toCharArray()) {
        targetMap[ch]++;
    }

    int left = 0;                 // Left pointer of the window
    int right = 0;                // Right pointer of the window
    int minWindowStart = 0;       // Starting index of the minimum window
    int minWindowLength = Integer.MAX_VALUE;  // Minimum window length
    int matchedCount = 0;         // Counter to track matched characters

    // Iterate through the string s using the right pointer
    while (right < s.length()) {
        char rightChar = s.charAt(right);
        windowMap[rightChar]++;  // Update the frequency of the character in the window map

        // If the current character is present in targetMap and its frequency in the window map is <= its frequency in targetMap
        if (targetMap[rightChar] > 0 && windowMap[rightChar] <= targetMap[rightChar]) {
            matchedCount++;  // Increment matchedCount as a character from t is matched
        }

        // Check if all characters from t have been matched in the current window
        while (matchedCount == t.length()) {
            // Update the minimum window length and starting index if necessary
            if (right - left + 1 < minWindowLength) {
                minWindowLength = right - left + 1;
                minWindowStart = left;
            }

            // Shrink the window from the left side
            char leftChar = s.charAt(left);
            windowMap[leftChar]--;  // Update the frequency of the character in the window map

            // If the current character was one of the characters from t, decrement the matchedCount
            if (targetMap[leftChar] > 0 && windowMap[leftChar] < targetMap[leftChar]) {
                matchedCount--;
            }

            left++;  // Move the left pointer to shrink the window
        }

        right++;  // Move the right pointer to expand the window
    }

    // Check if a valid window was found
    if (minWindowLength != Integer.MAX_VALUE) {
        return s.substring(minWindowStart, minWindowStart + minWindowLength);
    } else {
        return "";
    }
}
```

Time and Space Complexity :

The time complexity of this solution is O(n), where n is the length of the string `s`. The two pointers, `left` and `right`, traverse the string `s` only once. Additionally, the frequency maps and comparisons have constant time complexity since the number of characters is limited (128 ASCII characters). Therefore, the overall time complexity is linear, meeting the complexity requirement of O(n).

--------------------------------------------------------------

10. Remove Element (Question #27):
Given an array `nums` and a value `val`, remove all instances of that value in-place and return the new length.
Example:
Input: nums = [3, 2, 2, 3], val = 3
Output: 2

Solution:
In this solution, we use two pointers: `left` and `right`. The `left` pointer keeps track of the position where the non-val elements should be placed, and the `right` pointer iterates through the array to check each element.

The algorithm works as follows:

1. Initialize the `left` and `right` pointers to 0.
2. Iterate through the array with the `right` pointer.
3. If the element at the `right` pointer is not equal to `val`, it is a non-val element.
   - Assign the non-val element to the `left` pointer position in the array.
   - Increment the `left` pointer.
4. Increment the `right` pointer.
5. Repeat steps 3-4 until the end of the array.
6. Return the value of `left`, which represents the count of elements in `nums` that are not equal to `val`.

The time complexity of this solution is O(n), where n is the length of the input array `nums`. The algorithm iterates through the array only once, making it efficient.

TC = O(N) SC = O(1)

Code:
```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int left = 0; // Left pointer
        int right = 0; // Right pointer

        while (right < nums.length) {
            if (nums[right] != val) {
                nums[left] = nums[right];
                left++;
            }
            right++;
        }

        return left;
    }
}
```

--------------------------------------------------------------

11. Find the Index of the First Occurrence in a String (Question #28):
Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Example:
Input: haystack = "hello", needle = "ll"
Output: 2

Solution:
In this solution, we use two pointers: `i` for haystack and `j` for needle. The algorithm iterates through the haystack, comparing the characters with the needle.

The algorithm works as follows:

1. Check if the needle is empty. If so, it is always present at index 0 in haystack, so we return 0.
2. Set the lengths of the haystack and needle to variables `m` and `n`, respectively.
3. Iterate through the haystack from index 0 to index `m - n`.
4. Check if the current character in haystack matches the first character in needle.
5. If there's a match, store the starting index in the variable `start`.
6. Check if the remaining characters in haystack match the corresponding characters in needle.
7. If all characters in needle have matched, return the starting index `start` as the first occurrence of needle in haystack.
8. If not all characters have matched, reset the `i` pointer to the `start` index for the next iteration.
9. Repeat steps 4-8 until the end of the haystack is reached.
10. If needle is not part of haystack, return -1.

The time complexity of this solution is O((m-n) * n), where `m` is the length of the haystack and `n` is the length of the needle. In the worst case, the algorithm will compare each character in the haystack with the needle.

TC = O(N)

Code:

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle.isEmpty()) {
            return 0; // If needle is empty, it is always present at index 0 in haystack
        }
        
        int m = haystack.length();
        int n = needle.length();
        
        for (int i = 0; i <= m - n; i++) {
            int j = 0; // Needle pointer
            
            // Check if the current character in haystack matches the first character in needle
            if (haystack.charAt(i) == needle.charAt(j)) {
                int start = i; // Store the starting index in haystack
                
                // Check if the remaining characters in haystack match the corresponding characters in needle
                while (j < n && i < m && haystack.charAt(i) == needle.charAt(j)) {
                    i++;
                    j++;
                }
                
                // If j reaches the end of needle, it means all characters have matched
                if (j == n) {
                    return start; // Return the starting index of the first occurrence of needle in haystack
                }
                
                // Reset i to the starting index in haystack for the next iteration
                i = start;
            }
        }
        
        return -1; // Needle is not part of haystack
    }
}
```

--------------------------------------------------------------

12. Next Permutation (Question #31):
Implement `next permutation`, which rearranges numbers into the lexicographically next greater permutation of numbers.
Example:
Input: nums = [1, 2, 3]
Output: [1, 3, 2]

--------------------------------------------------------------

13. Remove Nth Node From End of List (Question #19):
Given the `head` of a linked list, remove the `nth` node from the end of the list and return its head.
Example:
Input: 1 -> 2 -> 3 -> 4 -> 5, n = 2
Output: 1 -> 2 -> 3 -> 5

Solution:

The solution uses two pointers, `leftPtr` and `rightPtr`, to remove the `nth` node from the end of the linked list. Here's the explanation of the solution:

1. Create a `dummyPtr` as a dummy node with a value of 0 and set its `next` pointer to the `head` of the linked list. This is done to handle the edge case where the `nth` node to be removed is the first node in the list.

2. Initialize the `leftPtr` to the `dummyPtr` and the `rightPtr` to the `head`.

3. Move the `rightPtr` `n` steps forward. This ensures that the distance between the `leftPtr` and `rightPtr` is exactly `n` nodes.

4. While `rightPtr` is not null, move both the `leftPtr` and `rightPtr` one step forward. This continues until the `rightPtr` reaches the end of the list.

5. At this point, the `leftPtr` will be pointing to the node just before the `nth` node from the end.

6. Update the `leftPtr` to skip the `nth` node by adjusting its `next` pointer to point to the node after the `nth` node.

7. Finally, return the `dummyPtr.next`, which is the updated head of the linked list.

Code : 

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummyPtr = new ListNode(0, head); // Create a dummy node
    ListNode leftPtr = dummyPtr; // Initialize left pointer to the dummy node
    ListNode rightPtr = head; // Initialize right pointer to the head

    while (n > 0 && rightPtr != null) {
        rightPtr = rightPtr.next; // Move right pointer n steps forward
        n--;
    }

    while (rightPtr != null) {
        rightPtr = rightPtr.next; // Move both pointers one step forward
        leftPtr = leftPtr.next;
    }

    leftPtr.next = leftPtr.next.next; // Skip the nth node by adjusting the next pointer of leftPtr

    return dummyPtr.next; // Return the head of the updated linked list
}
```

The time complexity of this solution is O(L), where L is the length of the linked list. The algorithm iterates through the linked list only once, performing a constant number of operations at each node. Therefore, the time complexity is linear in the length of the linked list.


--------------------------------------------------------------

14. Rotate Array (Question #189):
Given an array, rotate the array to the right by `k` steps, where `k` is non-negative.
Example:
Input: nums = [1, 2, 3, 4, 5, 6, 7], k = 3
Output: [5, 6, 7, 1, 2, 3, 4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]


Solution : 

The solution uses a reverse technique to rotate the array in-place. Here's the explanation of the solution:

1. In the `rotate` function, start by updating the value of `k` to `k % nums.length`. This is done to handle cases where `k` is larger than the length of the array. Taking the modulus ensures that `k` is within the valid range.

2. Initialize the variable `N` to `nums.length - 1`. This represents the last index of the array.

3. Call the `reverse` function three times:
   a. Reverse the entire array using `reverse(nums, 0, N)`. This step effectively reverses the entire array.
   b. Reverse the first `k` elements of the array using `reverse(nums, 0, k - 1)`. This step reverses the subarray containing the first `k` elements.
   c. Reverse the remaining elements of the array using `reverse(nums, k, N)`. This step reverses the subarray containing the remaining elements after the first `k` elements.

The `reverse` function is a helper function used to reverse a subarray within the array. It takes the array, the left index, and the right index as parameters.


Code : 

```java
public void rotate(int[] nums, int k) {
    k = k % nums.length; // Handle cases where k is larger than the length of the array
    int N = nums.length - 1; // Last index of the array
    
    reverse(nums, 0, N); // Reverse the entire array
    reverse(nums, 0, k - 1); // Reverse the first k elements
    reverse(nums, k, N); // Reverse the remaining elements
}

public void reverse(int[] arr, int left, int right) {
    while (left <= right) {
        int temp = arr[left]; // Swap elements at left and right indices
        arr[left] = arr[right];
        arr[right] = temp;
        left++; // Move left pointer towards the right
        right--; // Move right pointer towards the left
    }
}
```
Time and Space Complexity :

The time complexity of this solution is O(N), where N is the length of the array. The algorithm performs three reversals, each of which takes O(N/2) time. However, in big O notation, we ignore constant factors, so the overall time complexity is simplified to O(N).

The space complexity of the solution is O(1) since the algorithm operates in-place without using any additional data structures.

--------------------------------------------------------------
--------------------------------------------------------------

##Binary Search Algorithm


1. Binary Search (Question #704) [Easy]:
Given a sorted (in ascending order) integer array `nums` and a target value `target`, write a function to implement binary search and      return the index of the target in the array. If the target is not found, return -1.

2. First Bad Version (Question #278) [Easy]:
You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product is causing problems. Each version is denoted by a positive integer. You have a function `isBadVersion(version)` that returns whether a particular version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the `isBadVersion()` function.

3. Find Minimum in Rotated Sorted Array (Question #153) [Medium]:
Suppose an array of length `n` is rotated at an unknown pivot index and initially sorted in ascending order. Find the minimum element in the array. You may assume that the array does not contain duplicates.

4. Search in Rotated Sorted Array (Question #33) [Medium]:
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. You are given a target value to search for. If found in the array, return its index; otherwise, return -1. You may assume no duplicate exists in the array.


5. Search Insert Position (Question #35) [Easy]:
Given a sorted array of distinct integers `nums` and a target value `target`, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

6. Find Peak Element (Question #162) [Medium]:
A peak element in an array is an element that is strictly greater than its neighbors. Given an integer array `nums`, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.

7. Search for a Range (Question #34) [Medium]:
Given an array of integers `nums` sorted in ascending order, find the starting and ending position of a given target value `target`. If the target is not found in the array, return `[-1, -1]`.

8. Sorted Array to Binary Search Tree (Question #108) [Easy]:
Given an integer array `nums` where the elements are sorted in ascending order, convert it to a height-balanced binary search tree (BST). A height-balanced BST is a binary tree in which the depth of the two subtrees of every node never differs by more than one.

9. Implement Binary Search (Question #702) [Medium]:
Given a sorted (in ascending order) integer array `nums` and a target value `target`, write a function to implement binary search iteratively and return the index of the target if it exists in the array. If the target is not found, return -1.

10. Find First and Last Position of Element in Sorted Array (Question #349) [Medium]:
Given an array of integers `nums` sorted in ascending order, find the starting and ending position of a given target value `target`. If the target is not found in the array, return `[-1, -1]`.

11. Word Search (Question #79) [Medium]:
Given a 2D board of letters and a word, determine if the word exists in the grid. The word can be constructed from adjacent letters horizontally or vertically. Each letter on the board can only be used once.

12. Maximum Subarray (Question #11) [Medium]:
Given an integer array `nums`, find the contiguous subarray (containing at least one number) with the largest sum and return its sum.

13. Kth Largest Element in an Array (Question #215) [Medium]:
Given an integer array `nums` and an integer `k`, return the `kth` largest element in the array.


--------------------------------------------------------------
--------------------------------------------------------------

##HashMap

1. Two Sum (Question #1):
Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.
Example:
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: The sum of 2 and 7 equals 9, so the output is [0,1].

public int[] twoSum(int[] nums, int target) {
    HashMap<Integer, Integer> map = new HashMap<>();

    for (int i = 0; i < nums.length; i++){
        int complement = target - nums[i];
        if (map.containsKey(complement)){
            return new int[] {map.get(complement), i};
        }
        map.put(nums[i], i);
    }
    return new int[]{};
}
