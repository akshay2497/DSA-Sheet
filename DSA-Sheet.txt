##Algorithm - Two Pointers
----------------------------------------------------------
1. Container With Most Water (Question #11):
Given `n` non-negative integers `height`, where each represents a point at coordinate `(i, height[i])`, n vertical lines are drawn such that the two endpoints of the line `i` are at `(i, height[i])` and `(i, 0)`. Find two lines, which, together with the x-axis, forms a container, such that the container contains the most water.
Example:
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The maximum area is obtained by choosing the second and sixth vertical lines.

Approach :
Initialize two pointers, start and end, pointing to the first and last indices of the array.
Initialize a variable maxArea to keep track of the maximum water area encountered so far.
While the start pointer is less than the end pointer:
Calculate the current water area using the formula: area = (end - start) * min(height[start], height[end]).
Update maxArea if the current area is greater than the previous maximum.
Move the pointer that points to the smaller height inward, as moving the pointer with the larger height won't increase the area.
Repeat step 3 until the pointers meet, indicating that all possible areas have been considered.
Return the maxArea as the result.

In this solution, we iterate through the array once using the two-pointer technique, resulting in a time complexity of O(n), where n is the number of elements in the array. The space complexity is O(1) as we only use a constant amount of extra space.

Java code :

public int maxArea(int[] height) {
    int n = height.length;
    int start = 0;
    int end = n - 1;
    int maxWaterArea = Integer.MIN_VALUE;

    while (start < end) {
        int minHeight = Math.min(height[start], height[end]);
        int currWaterArea = (end - start) * minHeight;
        maxWaterArea = Math.max(maxWaterArea, currWaterArea);

        if (height[start] < height[end])
            start++;
        else 
            end--;
    }

    return maxWaterArea;
}
----------------------------------------------------------------
2. Three Sum (Question #15):
Given an array `nums` of `n` integers, find all unique triplets in the array which gives the sum of `0`.
Example:
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]

Approach:
To solve the Three Sum problem (Question #15), you can use the two-pointer technique combined with sorting the array. Here's how you can approach it:

1. Sort the given array in non-decreasing order. This step allows us to use the two-pointer technique effectively.
2. Iterate through the array from left to right, considering each element as a potential first element of the triplet.
   - Skip duplicate elements to avoid duplicate triplets.
   - For each element, set two pointers, `left` and `right`, initially pointing to the next element and the last element, respectively.
   - While `left` is less than `right`, calculate the sum of the three elements (current element + `nums[left]` + `nums[right]`).
     - If the sum is equal to zero, add the triplet `[nums[i], nums[left], nums[right]]` to the result set.
     - If the sum is less than zero, increment `left` to increase the sum.
     - If the sum is greater than zero, decrement `right` to decrease the sum.
     - Skip duplicate elements for `left` and `right` to avoid duplicate triplets.
3. Repeat step 2 until all elements have been considered as potential first elements.
4. Return the list of unique triplets that sum to zero.

In this solution, we sort the array first, which takes O(nlogn) time. Then, we iterate through the array using the two-pointer technique, resulting in a time complexity of O(n^2). The space complexity is O(1) as we only use a constant amount of extra space.

public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    if (nums.length < 3) {
        return result;
    }
    Arrays.sort(nums);
    int n = nums.length;

    for (int i = 0; i < n-2; i++){
        //Check if i is not 0 and i-1 element should not be same to i'th
        //element else skip that triplet
        if (i > 0 && nums[i] == nums[i-1]) {
            continue;
        }
        int left = i+1;
        int right = n-1;

        while (left < right) {
            int target = nums[i] + nums[left] + nums[right];
            if (target == 0) {
                result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                //avoid duplicates on left ptr
                while(left < right && nums[left] == nums[left+1]) {
                    left++;
                }

                //avoid duplicates on right ptr
                while(left < right && nums[right] == nums[right-1]) {
                    right--;
                }
                left++;
                right--;
            } else if (target < 0){
                left++;
            } else {
                right--;
            }
        }
    }
    return result;
}
----------------------------------------------------------------

3. Remove Duplicates from Sorted Array (Question #26):
Given a sorted array `nums`, remove the duplicates in-place such that each element appears only once and returns the new length.
Example:
Input: nums = [1,1,2]
Output: 2

Approach
1. Initialize two pointers, `ptr1` and `ptr2`, both initially set to 0 and 1 respectively. 
2. Iterate till ptr2 < array length
3. if nums[ptr1] == nums[ptr2] that means duplicates increment ptr2
4. if nums[ptr1] != nums[ptr2] that means distinct elements increment ptr1 and swap elements on both pointers increment both pointers
5. finally return ptr1+1 value that will be your total distinct elements

TC : O(N) - SC : O(1)

public int removeDuplicates(int[] nums) {
    if (nums.length < 2){
        return nums.length;
    }
    int n = nums.length;
    int ptr1 = 0;
    int ptr2 = 1;
    while (ptr2 < n) {
        if (nums[ptr1] == nums[ptr2]) {
            ptr2++;
        } else {
            ptr1++;
            int temp = nums[ptr2];
            nums[ptr2] = nums[ptr1];
            nums[ptr1] = temp;
            ptr2++;
        }
    }
    return ++ptr1;
}
----------------------------------------------------

4. Linked List Cycle II (Question #142):
Given a linked list, return the node where the cycle begins. If there is no cycle, return `null`.
Example:
Input: head = [3,2,0,-4], pos = 1
Output: the node with value 2
Explanation: There is a cycle in the linked list, where the tail connects to the second node.

To solve the Linked List Cycle II problem (Question #142), you can use the Floyd's Tortoise and Hare algorithm, also known as the "fast and slow pointers" technique. Here's how you can approach it:

1. Initialize two pointers, `slow` and `fast`, both initially set to the head of the linked list.
2. Move `slow` one step at a time and `fast` two steps at a time through the linked list.
3. Continue moving the pointers until they meet or `fast` reaches the end of the linked list (i.e., it becomes `null`).
   - If `fast` becomes `null`, it means there is no cycle in the linked list. Return `null`.
   - If `slow` and `fast` meet, it indicates the presence of a cycle in the linked list.
4. Reset the `slow` pointer to the head of the linked list and keep `fast` at the meeting point.
5. Move both pointers one step at a time until they meet again. The meeting point will be the start of the cycle.
6. Return the node at which the cycle starts.


Proof : 

1. Once the `fast` and `slow` pointers meet inside the cycle, let's say the distance from the head of the linked list to the start of the cycle is `D`, and the distance from the start of the cycle to the meeting point of the two pointers is `K`.

2. When the `fast` pointer catches up to the `slow` pointer, it has traveled twice the distance as the `slow` pointer. Therefore, the `fast` pointer has traveled a total distance of `D + K + C` (where `C` represents the number of complete cycles the `fast` pointer made within the cycle), while the `slow` pointer has traveled a distance of `D + K`.

3. Since the `fast` pointer moves twice as fast as the `slow` pointer, we can express their respective distances as follows: `2(D + K) = D + K + C`, which simplifies to `D + K = C`. This equation tells us that the distance from the head of the linked list to the start of the cycle is equal to the number of complete cycles within the cycle.

4. By resetting the `slow` pointer to the head of the linked list and keeping the `fast` pointer at the meeting point, and then moving both pointers one step at a time, the `slow` pointer will travel a distance of `D` to reach the start of the cycle, while the `fast` pointer will travel a distance of `C` within the cycle.

5. As the `slow` and `fast` pointers continue moving, they will eventually meet again at the start of the cycle. This is because the `slow` pointer has traveled a distance of `D`, while the `fast` pointer has traveled a distance of `C`, and we know from step 3 that `D` is equal to `C`.

In this solution, we use two pointers to detect the cycle and find the node where the cycle starts. The time complexity of this algorithm is O(n), where n is the number of nodes in the linked list. The space complexity is O(1) as we only use a constant amount of extra space.

Code : 
public ListNode detectCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;

    while(fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (fast == slow){
            break;
        }
    }

    if (fast == null || fast.next == null){
        return null;
    }

    slow = head;

    while (slow != fast) {
        slow = slow.next;
        fast = fast.next;
    }

    return slow;
}
-------------------------------------------------------------
5. Reverse Linked List II (Question #92):
Reverse a linked list from position `m` to `n`. Do it in one-pass and without using extra memory.
Example:
Input: 1 -> 2 -> 3 -> 4 -> 5, m = 2, n = 4
Output: 1 -> 4 -> 3 -> 2 -> 5

--------------------------------------------------------------

6. Longest Palindromic Substring (Question #5):
Given a string `s`, return the longest palindromic substring in `s`.
Example:
Input: "babad"
Output: "bab" or "aba"

class Solution {
    int totalSubStringLength = 0;
    int startPoint = 0;

    public String longestPalindrome(String s) {
        int n = s.length();

        // Iterate through each character of the input string
        for (int i = 0; i < n; i++) {
            findPalindrome(s, i, i);      // Consider current character as the center of a palindrome with an odd length
            findPalindrome(s, i, i+1);    // Consider current character and the next character as the center of a palindrome with an even length
        }

        // Return the longest palindromic substring using the startPoint and totalSubStringLength variables
        return s.substring(startPoint, startPoint + totalSubStringLength);
    }

    public void findPalindrome(String s, int start, int end) {
        // Expand around the center indices until the characters are equal or the boundary is reached
        while (start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end)) {
            start--;
            end++;
        }

        // Check if the length of the current palindrome is greater than the stored length
        if (totalSubStringLength < end - start - 1) {
            startPoint = start + 1;                          // Update the starting index of the longest palindrome
            totalSubStringLength = end - start - 1;          // Update the length of the longest palindrome
        }
    }
}

1. The class defines two member variables: `totalSubStringLength` and `startPoint`.
   - `totalSubStringLength` stores the length of the longest palindromic substring found so far.
   - `startPoint` stores the starting index of the longest palindromic substring found so far.

2. The `longestPalindrome` method takes the input string `s` and returns the longest palindromic substring in `s`.

3. The method initializes `totalSubStringLength` and `startPoint` to 0.

4. The method iterates through each character of the input string `s` using a `for` loop.

5. For each character at index `i`, the method calls the `findPalindrome` method twice:
   - The first call considers the current character as the center of a palindrome with an odd length.
   - The second call considers the current character and the next character as the center of a palindrome with an even length.

6. The `findPalindrome` method is responsible for expanding around the center indices to find the length of the palindrome.

7. The `findPalindrome` method uses a `while` loop to expand the palindrome by checking if the characters at indices `start` and `end` are equal. It continues expanding as long as the characters are equal and there are characters available on both sides.

8. After the `while` loop, the `findPalindrome` method checks if the length of the current palindrome (given by `end - start - 1`) is greater than the stored length (`totalSubStringLength`).

9. If the length of the current palindrome is indeed longer, the `findPalindrome` method updates `startPoint` with the new starting index (`start + 1`) and `totalSubStringLength` with the new length (`end - start - 1`).

10. The `longestPalindrome` method returns the substring of `s` starting from `startPoint` and with a length of `totalSubStringLength`, representing the longest palindromic substring found in the input string.

The provided code is another valid implementation for finding the Longest Palindromic Substring. Here's an explanation of the code, with a focus on the specific block you mentioned:

```java
if (totalSubStringLength < end - start - 1) {
    startPoint = start + 1;
    totalSubStringLength = end - start - 1;
}
```

This block of code is responsible for updating the variables `startPoint` and `totalSubStringLength` when a longer palindromic substring is found.

- `totalSubStringLength` keeps track of the length of the longest palindromic substring found so far.
- `startPoint` stores the starting index of the longest palindromic substring found so far.

Here's how the block works:

1. The block is inside the `findPalindrome` method, which is called for each character in the string `s`.

2. The `while` loop inside `findPalindrome` expands the palindromic substring by checking if the characters at indices `start` and `end` are equal. It continues expanding as long as the characters are equal and there are characters available on both sides.

3. After the `while` loop, the block checks if the length of the current palindrome (given by `end - start - 1`) is greater than the stored length (`totalSubStringLength`).

4. If the length of the current palindrome is indeed longer, the block updates `startPoint` with the new starting index (`start + 1`) and `totalSubStringLength` with the new length (`end - start - 1`).

By updating these variables, the block ensures that `startPoint` and `totalSubStringLength` always store the starting index and length of the longest palindromic substring found so far during the iterations.

After the iterations are complete, the `longestPalindrome` method returns the substring of `s` starting from `startPoint` and with a length of `totalSubStringLength`, representing the longest palindromic substring found in the input string.


Time complexity Explanation

1. The `longestPalindrome` method contains a `for` loop that iterates through each character of the input string. Since there are n characters in the string, this loop has a time complexity of O(n).

2. Inside the `for` loop, the `findPalindrome` method is called twice for each character. This results in a nested loop structure where, in the worst case, each iteration of the outer loop triggers a loop iteration in the `findPalindrome` method.

3. The `findPalindrome` method contains a `while` loop that expands around the center indices until the characters are no longer equal or the boundary of the string is reached. This expansion process has a time complexity of O(n) in the worst case, where n is the length of the string.

4. Since the `findPalindrome` method is called twice for each character in the `longestPalindrome` method, and the expansion process within each call has a time complexity of O(n), the overall time complexity of the `longestPalindrome` method is O(n * n) = O(n^2).

Therefore, the overall time complexity of the provided `Solution` class is O(n^2), where n is the length of the input string `s`.

--------------------------------------------------------------

7. Merge Intervals (Question #56):
Given an array of intervals `intervals` where `intervals[i] = [start_i, end_i]`, merge all overlapping intervals.
Example:
Input: [[1, 3], [2, 6], [8, 10], [15, 18]]
Output: [[1, 6], [8, 10], [15, 18]]

Solution:

1. Sort the intervals based on the starting points. This ensures that overlapping intervals will be adjacent to each other after sorting.

2. Initialize an empty list to store the merged intervals.

3. Iterate through the sorted intervals. For each interval, check if it overlaps with the previous merged interval or if it is non-overlapping.

4. If the current interval overlaps with the previous merged interval, update the end point of the merged interval if necessary to include the current interval.

5. If the current interval is non-overlapping, add the previous merged interval to the result list and set the current interval as the new merged interval.

6. After iterating through all intervals, add the last merged interval to the result list.

7. Return the result list containing the merged intervals.

```java
public int[][] merge(int[][] intervals) {
    if (intervals == null || intervals.length == 0) {
        return new int[0][];
    }

    // Sort the intervals based on the starting points
    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

    List<int[]> mergedIntervals = new ArrayList<>();
    int[] currentInterval = intervals[0];

    // Iterate through the sorted intervals
    for (int i = 1; i < intervals.length; i++) {
        int[] interval = intervals[i];

        // If the current interval overlaps with the previous merged interval, update the end point if necessary
        if (interval[0] <= currentInterval[1]) {
            currentInterval[1] = Math.max(currentInterval[1], interval[1]);
        }
        // If the current interval is non-overlapping, add the previous merged interval to the result list
        else {
            mergedIntervals.add(currentInterval);
            currentInterval = interval;
        }
    }

    // Add the last merged interval to the result list
    mergedIntervals.add(currentInterval);

    // Convert the list to a 2D array
    int[][] result = new int[mergedIntervals.size()][2];
    for (int i = 0; i < mergedIntervals.size(); i++) {
        result[i] = mergedIntervals.get(i);
    }

    return result;
}
```

Time and Space complexity:
The time complexity of this solution is O(n log n), where n is the number of intervals. The sorting step takes O(n log n) time, and the merging step iterates through the sorted intervals once, which takes O(n) time. The space complexity is O(n) as we store the merged intervals in a list.

--------------------------------------------------------------

8. Valid Parentheses (Question #20):
Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['`, `']'`, determine if the input string is valid.
Example:
Input: "{[]}"
Output: true

Solution:

1. The `isValid` method takes a string `s` as input and returns a boolean value indicating whether the parentheses in `s` are valid.

2. The method initializes a `Stack` data structure named `stack` to keep track of the opening parentheses encountered.

3. It also initializes a variable `n` with the length of the input string `s`.

4. The method iterates through each character of the input string using a `for` loop.

5. For each character, the method checks if it is an opening parenthesis (`(`, `[`, `{`). If so, it pushes the character onto the stack.

6. If the character is a closing parenthesis (`)`, `]`, `}`), the method checks if the stack is empty. If it is, this means there is no matching opening parenthesis for the current closing parenthesis, so the string is invalid, and the method returns `false`.

7. If the stack is not empty, the method pops the top character from the stack and compares it with the current closing parenthesis. If they do not match, this means the parentheses are not in the correct order, and the method returns `false`.

8. If all parentheses are matched and valid, the method continues the loop until all characters in the string are processed.

9. After the loop, the method checks if there are any remaining opening parentheses in the stack. If there are, this means the string is invalid because some opening parentheses were not closed, and the method returns `false`. Otherwise, it returns `true`.

The code follows a straightforward approach using a stack to track the opening parentheses encountered. It compares each closing parenthesis with the top of the stack to ensure that they match. If the stack is empty or the parentheses do not match, it returns `false`. Otherwise, if all parentheses are valid, it returns `true`.

Time and Space complexity :

The time complexity of this implementation is O(n), where n is the length of the input string `s`, as we iterate through each character once. The space complexity is O(n) as we use a stack to store opening parentheses, and in the worst case, all characters in `s` could be opening parentheses.

```Java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();

        int n = s.length();

        for (int i = 0; i < n; i++) {
            char currChar = s.charAt(i);

            if (currChar == '(' || currChar == '[' || currChar == '{') {
                stack.push(currChar);
            } else {
                if (stack.isEmpty()){
                    return false;
                }
                char poppedChar = stack.pop();
                if (currChar == ')' && poppedChar != '('){
                    return false;
                } else if (currChar == ']' && poppedChar != '[') {
                    return false;
                } else if (currChar == '}' && poppedChar != '{'){
                    return false;
                }
            }
        }
        return stack.size() > 0 ? false : true;
    }
}
```

--------------------------------------------------------------

9. Minimum Window Substring (Question #76):
Given two strings `s` and `t`, return the minimum window in `s` which will contain all the characters in `t` in complexity `O(n)`.
Example:
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"

Solution:

1. Initialize two pointers, `left` and `right`, to track the window boundaries. Set them both to 0 initially.

2. Create two frequency maps, `targetMap` and `windowMap`, to track the character frequencies of the target string `t` and the current window in string `s`, respectively. Initially, both maps should be empty.

3. Populate the `targetMap` by iterating through the characters of string `t`. For each character, update its frequency in the map.

4. Initialize variables to track the minimum window length (`minWindowLength`), the starting index of the minimum window (`minWindowStart`), and a counter to keep track of the characters in `t` that have been matched in the current window (`matchedCount`). Set the `matchedCount` to 0 initially.

5. Start iterating through the string `s` using the `right` pointer:
   - For each character encountered, update its frequency in the `windowMap`.
   - If the character is present in the `targetMap` and its frequency in the `windowMap` is less than or equal to its frequency in the `targetMap`, increment the `matchedCount` by 1.

6. Check if all characters in `t` have been matched in the current window:
   - If the `matchedCount` is equal to the length of the target string `t`, it means all characters in `t` have been matched. In this case, we have found a valid window.
   - Update the minimum window length and the starting index of the minimum window if necessary.

7. Shrink the window by moving the `left` pointer:
   - While the `left` pointer can be moved and the current window still contains all characters from `t`, update the `windowMap` and `matchedCount` accordingly.
   - Check if the updated window is still valid (contains all characters from `t`).
   - If the updated window is still valid, update the minimum window length and the starting index of the minimum window if necessary.

8. Repeat steps 5 to 7 until the `right` pointer reaches the end of the string `s`.

9. After the loop, check if a valid window was found. If so, return the substring of `s` that corresponds to the minimum window length, starting from the `minWindowStart` index. Otherwise, return an empty string.

Code:

```java
public String minWindow(String s, String t) {
    int[] targetMap = new int[128];  // Frequency map for target string t
    int[] windowMap = new int[128];  // Frequency map for current window in s

    // Populate the targetMap with character frequencies from string t
    for (char ch : t.toCharArray()) {
        targetMap[ch]++;
    }

    int left = 0;                 // Left pointer of the window
    int right = 0;                // Right pointer of the window
    int minWindowStart = 0;       // Starting index of the minimum window
    int minWindowLength = Integer.MAX_VALUE;  // Minimum window length
    int matchedCount = 0;         // Counter to track matched characters

    // Iterate through the string s using the right pointer
    while (right < s.length()) {
        char rightChar = s.charAt(right);
        windowMap[rightChar]++;  // Update the frequency of the character in the window map

        // If the current character is present in targetMap and its frequency in the window map is <= its frequency in targetMap
        if (targetMap[rightChar] > 0 && windowMap[rightChar] <= targetMap[rightChar]) {
            matchedCount++;  // Increment matchedCount as a character from t is matched
        }

        // Check if all characters from t have been matched in the current window
        while (matchedCount == t.length()) {
            // Update the minimum window length and starting index if necessary
            if (right - left + 1 < minWindowLength) {
                minWindowLength = right - left + 1;
                minWindowStart = left;
            }

            // Shrink the window from the left side
            char leftChar = s.charAt(left);
            windowMap[leftChar]--;  // Update the frequency of the character in the window map

            // If the current character was one of the characters from t, decrement the matchedCount
            if (targetMap[leftChar] > 0 && windowMap[leftChar] < targetMap[leftChar]) {
                matchedCount--;
            }

            left++;  // Move the left pointer to shrink the window
        }

        right++;  // Move the right pointer to expand the window
    }

    // Check if a valid window was found
    if (minWindowLength != Integer.MAX_VALUE) {
        return s.substring(minWindowStart, minWindowStart + minWindowLength);
    } else {
        return "";
    }
}
```

Time and Space Complexity :

The time complexity of this solution is O(n), where n is the length of the string `s`. The two pointers, `left` and `right`, traverse the string `s` only once. Additionally, the frequency maps and comparisons have constant time complexity since the number of characters is limited (128 ASCII characters). Therefore, the overall time complexity is linear, meeting the complexity requirement of O(n).

--------------------------------------------------------------

10. Remove Element (Question #27):
Given an array `nums` and a value `val`, remove all instances of that value in-place and return the new length.
Example:
Input: nums = [3, 2, 2, 3], val = 3
Output: 2

Solution:
In this solution, we use two pointers: `left` and `right`. The `left` pointer keeps track of the position where the non-val elements should be placed, and the `right` pointer iterates through the array to check each element.

The algorithm works as follows:

1. Initialize the `left` and `right` pointers to 0.
2. Iterate through the array with the `right` pointer.
3. If the element at the `right` pointer is not equal to `val`, it is a non-val element.
   - Assign the non-val element to the `left` pointer position in the array.
   - Increment the `left` pointer.
4. Increment the `right` pointer.
5. Repeat steps 3-4 until the end of the array.
6. Return the value of `left`, which represents the count of elements in `nums` that are not equal to `val`.

The time complexity of this solution is O(n), where n is the length of the input array `nums`. The algorithm iterates through the array only once, making it efficient.

TC = O(N) SC = O(1)

Code:
```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int left = 0; // Left pointer
        int right = 0; // Right pointer

        while (right < nums.length) {
            if (nums[right] != val) {
                nums[left] = nums[right];
                left++;
            }
            right++;
        }

        return left;
    }
}
```

--------------------------------------------------------------

11. Find the Index of the First Occurrence in a String (Question #28):
Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Example:
Input: haystack = "hello", needle = "ll"
Output: 2

Solution:
In this solution, we use two pointers: `i` for haystack and `j` for needle. The algorithm iterates through the haystack, comparing the characters with the needle.

The algorithm works as follows:

1. Check if the needle is empty. If so, it is always present at index 0 in haystack, so we return 0.
2. Set the lengths of the haystack and needle to variables `m` and `n`, respectively.
3. Iterate through the haystack from index 0 to index `m - n`.
4. Check if the current character in haystack matches the first character in needle.
5. If there's a match, store the starting index in the variable `start`.
6. Check if the remaining characters in haystack match the corresponding characters in needle.
7. If all characters in needle have matched, return the starting index `start` as the first occurrence of needle in haystack.
8. If not all characters have matched, reset the `i` pointer to the `start` index for the next iteration.
9. Repeat steps 4-8 until the end of the haystack is reached.
10. If needle is not part of haystack, return -1.

The time complexity of this solution is O((m-n) * n), where `m` is the length of the haystack and `n` is the length of the needle. In the worst case, the algorithm will compare each character in the haystack with the needle.

TC = O(N)

Code:

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle.isEmpty()) {
            return 0; // If needle is empty, it is always present at index 0 in haystack
        }
        
        int m = haystack.length();
        int n = needle.length();
        
        for (int i = 0; i <= m - n; i++) {
            int j = 0; // Needle pointer
            
            // Check if the current character in haystack matches the first character in needle
            if (haystack.charAt(i) == needle.charAt(j)) {
                int start = i; // Store the starting index in haystack
                
                // Check if the remaining characters in haystack match the corresponding characters in needle
                while (j < n && i < m && haystack.charAt(i) == needle.charAt(j)) {
                    i++;
                    j++;
                }
                
                // If j reaches the end of needle, it means all characters have matched
                if (j == n) {
                    return start; // Return the starting index of the first occurrence of needle in haystack
                }
                
                // Reset i to the starting index in haystack for the next iteration
                i = start;
            }
        }
        
        return -1; // Needle is not part of haystack
    }
}
```

--------------------------------------------------------------

12. Next Permutation (Question #31):
Implement `next permutation`, which rearranges numbers into the lexicographically next greater permutation of numbers.
Example:
Input: nums = [1, 2, 3]
Output: [1, 3, 2]

--------------------------------------------------------------

13. Remove Nth Node From End of List (Question #19):
Given the `head` of a linked list, remove the `nth` node from the end of the list and return its head.
Example:
Input: 1 -> 2 -> 3 -> 4 -> 5, n = 2
Output: 1 -> 2 -> 3 -> 5

Solution:

The solution uses two pointers, `leftPtr` and `rightPtr`, to remove the `nth` node from the end of the linked list. Here's the explanation of the solution:

1. Create a `dummyPtr` as a dummy node with a value of 0 and set its `next` pointer to the `head` of the linked list. This is done to handle the edge case where the `nth` node to be removed is the first node in the list.

2. Initialize the `leftPtr` to the `dummyPtr` and the `rightPtr` to the `head`.

3. Move the `rightPtr` `n` steps forward. This ensures that the distance between the `leftPtr` and `rightPtr` is exactly `n` nodes.

4. While `rightPtr` is not null, move both the `leftPtr` and `rightPtr` one step forward. This continues until the `rightPtr` reaches the end of the list.

5. At this point, the `leftPtr` will be pointing to the node just before the `nth` node from the end.

6. Update the `leftPtr` to skip the `nth` node by adjusting its `next` pointer to point to the node after the `nth` node.

7. Finally, return the `dummyPtr.next`, which is the updated head of the linked list.

Code : 

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummyPtr = new ListNode(0, head); // Create a dummy node
    ListNode leftPtr = dummyPtr; // Initialize left pointer to the dummy node
    ListNode rightPtr = head; // Initialize right pointer to the head

    while (n > 0 && rightPtr != null) {
        rightPtr = rightPtr.next; // Move right pointer n steps forward
        n--;
    }

    while (rightPtr != null) {
        rightPtr = rightPtr.next; // Move both pointers one step forward
        leftPtr = leftPtr.next;
    }

    leftPtr.next = leftPtr.next.next; // Skip the nth node by adjusting the next pointer of leftPtr

    return dummyPtr.next; // Return the head of the updated linked list
}
```

The time complexity of this solution is O(L), where L is the length of the linked list. The algorithm iterates through the linked list only once, performing a constant number of operations at each node. Therefore, the time complexity is linear in the length of the linked list.


--------------------------------------------------------------

14. Rotate Array (Question #189):
Given an array, rotate the array to the right by `k` steps, where `k` is non-negative.
Example:
Input: nums = [1, 2, 3, 4, 5, 6, 7], k = 3
Output: [5, 6, 7, 1, 2, 3, 4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]


Solution : 

The solution uses a reverse technique to rotate the array in-place. Here's the explanation of the solution:

1. In the `rotate` function, start by updating the value of `k` to `k % nums.length`. This is done to handle cases where `k` is larger than the length of the array. Taking the modulus ensures that `k` is within the valid range.

2. Initialize the variable `N` to `nums.length - 1`. This represents the last index of the array.

3. Call the `reverse` function three times:
   a. Reverse the entire array using `reverse(nums, 0, N)`. This step effectively reverses the entire array.
   b. Reverse the first `k` elements of the array using `reverse(nums, 0, k - 1)`. This step reverses the subarray containing the first `k` elements.
   c. Reverse the remaining elements of the array using `reverse(nums, k, N)`. This step reverses the subarray containing the remaining elements after the first `k` elements.

The `reverse` function is a helper function used to reverse a subarray within the array. It takes the array, the left index, and the right index as parameters.


Code : 

```java
public void rotate(int[] nums, int k) {
    k = k % nums.length; // Handle cases where k is larger than the length of the array
    int N = nums.length - 1; // Last index of the array
    
    reverse(nums, 0, N); // Reverse the entire array
    reverse(nums, 0, k - 1); // Reverse the first k elements
    reverse(nums, k, N); // Reverse the remaining elements
}

public void reverse(int[] arr, int left, int right) {
    while (left <= right) {
        int temp = arr[left]; // Swap elements at left and right indices
        arr[left] = arr[right];
        arr[right] = temp;
        left++; // Move left pointer towards the right
        right--; // Move right pointer towards the left
    }
}
```
Time and Space Complexity :

The time complexity of this solution is O(N), where N is the length of the array. The algorithm performs three reversals, each of which takes O(N/2) time. However, in big O notation, we ignore constant factors, so the overall time complexity is simplified to O(N).

The space complexity of the solution is O(1) since the algorithm operates in-place without using any additional data structures.

--------------------------------------------------------------
--------------------------------------------------------------

##Binary Search Algorithm


1. Binary Search (Question #704) [Easy]:
Given a sorted (in ascending order) integer array `nums` and a target value `target`, write a function to implement binary search and      return the index of the target in the array. If the target is not found, return -1.


Solution :
1. Initialize variables `left` and `right` as the start and end indices of the input array.
2. Perform binary search by repeatedly dividing the search space until `left` is less than or equal to `right`.
3. Calculate the middle index `mid` using `(left + right) / 2` to find the mid-point of the current search space.
4. Check if the element at index `mid` is equal to the target. If so, return `mid`, as we found the target.
5. If the element at index `mid` is less than the target, move the left pointer to `mid + 1` to search the right half of the current search space.
6. If the element at index `mid` is greater than the target, move the right pointer to `mid - 1` to search the left half of the current search space.
7. Repeat steps 3 to 6 until `left` becomes greater than `right`.

Time Complexity (TC): The time complexity of this binary search algorithm is O(log n), where n is the number of elements in the input array. Binary search efficiently reduces the search space by half in each iteration, resulting in logarithmic time complexity.

Space Complexity (SC): The space complexity is O(1) since the algorithm only uses a constant amount of extra space to store the variables `left`, `right`, and `mid`, regardless of the size of the input array.

Code:

```java
public int search(int[] nums, int target) {
    // Get the length of the input array
    int n = nums.length;
    
    // Initialize the left and right pointers for binary search
    int left = 0, right = n - 1;
    
    // Binary search loop
    while (left <= right) {
        // Calculate the mid index using the left and right pointers
        int mid = left + (right - left) / 2;
        
        // If the middle element is the target, return its index
        if (nums[mid] == target) {
            return mid;
        }

        // If the middle element is less than the target, ignore the left half
        if (nums[mid] < target) {
            left = mid + 1;
        }
        // If the middle element is greater than the target, ignore the right half
        else {
            right = mid - 1;
        }
    }

    // If the target is not found, return -1
    return -1;
}

Recursive : 
public int search(int[] nums, int target) {
    return binarySearch(nums, target, 0, nums.length - 1);
}

private int binarySearch(int[] nums, int target, int left, int right) {
    if (left > right) {
        return -1; // Base case: Target not found
    }

    int mid = left + (right - left) / 2;

    if (nums[mid] == target) {
        return mid; // Base case: Target found
    } else if (nums[mid] < target) {
        // Recursive call to search the right half
        return binarySearch(nums, target, mid + 1, right);
    } else {
        // Recursive call to search the left half
        return binarySearch(nums, target, left, mid - 1);
    }
}

```

----------------------------------------------------------

2. First Bad Version (Question #278) [Easy]:
You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

Example 1:

Input: n = 5, bad = 4
Output: 4
Explanation:
call isBadVersion(3) -> false
call isBadVersion(5) -> true
call isBadVersion(4) -> true
Then 4 is the first bad version.
Example 2:

Input: n = 1, bad = 1
Output: 1

Solution:
1. Initialize the `left` and `right` pointers to the first and last versions (1 and `n`) in the range to be searched.
2. Initialize the `ans` variable to store the answer, i.e., the index of the first bad version.
3. Perform binary search using the `while` loop, which continues as long as the `left` pointer is less than or equal to the `right` pointer.
4. Calculate the middle index `mid` using `(left + right) / 2` to divide the search space.
5. Check if the middle version `mid` is bad using the `isBadVersion()` function.
6. If the middle version is bad, update the `ans` to `mid` as we found a possible candidate for the first bad version, and continue searching the left half to find the first occurrence of the bad version.
7. If the middle version is not bad, continue searching the right half.
8. Repeat steps 4 to 7 until the `left` pointer becomes greater than the `right` pointer, indicating that we have found the first bad version.
9. Return the `ans` as the index of the first bad version.

Time Complexity (TC): The time complexity of this binary search algorithm is O(log n), where `n` is the number of versions. Binary search efficiently reduces the search space by half in each iteration, resulting in logarithmic time complexity.

Space Complexity (SC): The space complexity is O(1) since the algorithm only uses a constant amount of extra space to store the variables `left`, `right`, `ans`, and `mid`, regardless of the size of the input `n`.

Code: 

```java
public int firstBadVersion(int n) {
    // Initialize left and right pointers to search the versions
    int left = 1, right = n;
    
    // Initialize a variable to store the answer (first bad version)
    int ans = 0;

    // Binary search loop
    while (left <= right) {
        // Calculate the middle index using the left and right pointers
        int mid = left + (right - left) / 2;

        // Check if the middle version is bad (using the provided isBadVersion() function)
        if (isBadVersion(mid)) {
            // If the middle version is bad, update the answer to mid and search the left half
            ans = mid;
            right = mid - 1;
        } else {
            // If the middle version is not bad, search the right half
            left = mid + 1;
        }
    }

    // Return the first bad version found
    return ans;
}
```
-----------------------------------------------------------

3. Find Minimum in Rotated Sorted Array (Question #153) [Medium]:
Suppose an array of length `n` is rotated at an unknown pivot index and initially sorted in ascending order. Find the minimum element in the array. You may assume that the array does not contain duplicates.

Solution:
1. The binary search algorithm is used to find the minimum element in a rotated sorted array.
2. Initialize `left` and `right` pointers to the first and last elements of the array, respectively.
3. Perform binary search using the `while` loop, which continues as long as `left` is less than `right`.
4. Calculate the middle index `mid` using `(left + right) / 2`.
5. Check if the element at the middle index `mid` is greater than the element at the right index `right`. If true, it means that the minimum element is on the right side of `mid`, so we update `left = mid + 1`.
6. Check if the element at the middle index `mid` is less than the element at the right index `right`. If true, it means that the minimum element is either `mid` or on the left side of `mid`, so we update `right = mid`.
7. If the element at the middle index `mid` is equal to the element at the right index `right`, it means there are duplicate elements. In this case, we can safely ignore the rightmost element as it will not affect the minimum element, so we update `right--` to exclude the duplicate element.
8. Repeat steps 4 to 7 until `left` becomes equal to `right`, indicating that we have found the minimum element.
9. Return the element at the `left` index, which is the minimum element.

Time Complexity (TC): The time complexity of this binary search algorithm is O(log n), where `n` is the number of elements in the array. Binary search efficiently reduces the search space by half in each iteration, resulting in logarithmic time complexity.

Space Complexity (SC): The space complexity is O(1) since the algorithm only uses a constant amount of extra space to store the variables `left`, `right`, and `mid`, regardless of the size of the input array.

Code:

```java
public int findMin(int[] nums) {
    int left = 0;
    int right = nums.length - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;

        // Check if the middle element is greater than the rightmost element
        // If true, the minimum element is on the right side, 
        // so we update the left pointer
        if (nums[mid] > nums[right]) {
            left = mid + 1;
        }
        // Check if the middle element is less than the rightmost element
        // If true, the minimum element is either the middle element or 
        // on the left side
        // So we update the right pointer to mid since mid can be 
        // a potential candidate for the minimum element
        else if (nums[mid] < nums[right]) {
            right = mid;
        }
        // If the middle element is equal to the rightmost element
        // We can safely ignore the rightmost element as it will 
        // not affect the minimum element
        // So we update the right pointer to exclude the duplicate element
        // Below case is puerly to avoid duplicates in the array
        else {
            right--;
        }
    }

    // The left pointer will point to the minimum element
    return nums[left];
}
```

---------------------------------------------------------

4. Search in Rotated Sorted Array (Question #33) [Medium]:
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. You are given a target value to search for. If found in the array, return its index; otherwise, return -1. You may assume no duplicate exists in the array.

There is an integer array nums sorted in ascending order (with distinct values).

Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].

Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.

You must write an algorithm with O(log n) runtime complexity.

Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
Example 3:

Input: nums = [1], target = 0
Output: -1

Solution:

The given code implements a modified version of binary search to find the target element in a rotated sorted array. The algorithm exploits the fact that at least one half of the rotated array will always be sorted.

1. Initialize the left pointer to the beginning of the array (`0`) and the right pointer to the end of the array (`nums.length - 1`).
2. Use a while loop to perform binary search until the left and right pointers meet or cross each other.
3. Calculate the middle index (`mid`) in each iteration.
4. Check if the element at `mid` is equal to the target. If yes, return the index (`mid`).
5. Check if the left half or the right half is sorted by comparing the values at `left` and `mid`. This step helps in identifying which half to search for the target.
6. Adjust the pointers accordingly to continue the binary search in the sorted half that potentially contains the target element.
7. If the target is not found, the loop will terminate, and the function will return `-1`.

Time Complexity (TC):
The time complexity of this algorithm is O(log N) where N is the number of elements in the `nums` array. This is because binary search reduces the search space by half in each iteration.

Space Complexity (SC):
The space complexity of this algorithm is O(1) because it uses a constant amount of extra space for the variables (`left`, `right`, `mid`, and `target`) regardless of the size of the input array.

```java
public int search(int[] nums, int target) {
    int left = 0; // Initialize the left pointer to the start of the array.
    int right = nums.length - 1; // Initialize the right pointer to the end of the array.

    while (left <= right) { // Perform binary search until left and right pointers meet.
        int mid = (left + right) / 2; // Calculate the middle index.

        if (nums[mid] == target) { // If the middle element is the target, return its index.
            return mid;
        }

        if (nums[left] <= nums[mid]) { // Check if the left half is sorted.
            if (target >= nums[left] && target < nums[mid]) {
                // If the target lies in the left sorted half, adjust the right pointer.
                right = mid - 1;
            } else {
                // If the target doesn't lie in the left sorted half, adjust the left pointer.
                left = mid + 1;
            }
        } else {
            // The right half is sorted.
            if (target <= nums[right] && target > nums[mid]) {
                // If the target lies in the right sorted half, adjust the left pointer.
                left = mid + 1;
            } else {
                // If the target doesn't lie in the right sorted half, adjust the right pointer.
                right = mid - 1;
            }
        }
    }

    return -1; // Return -1 if the target is not found in the array.
}
```
--------------------------------------------------

5. Search Insert Position (Question #35) [Easy]:
Given a sorted array of distinct integers `nums` and a target value `target`, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

Example 1:

Input: nums = [1,3,5,6], target = 5
Output: 2
Example 2:

Input: nums = [1,3,5,6], target = 2
Output: 1
Example 3:

Input: nums = [1,3,5,6], target = 7
Output: 4

Solution:
The given code implements a modified version of binary search to find the index where the target should be inserted in the sorted array.

1. Initialize the left pointer to the beginning of the array (`0`) and the right pointer to the end of the array (`n - 1`).
2. Initialize a variable `lastLessValueIndex` to keep track of the index where the target would be inserted if it's not found in the array.
3. Use a while loop to perform binary search until the left and right pointers meet or cross each other.
4. Calculate the middle index (`mid`) in each iteration.
5. Check if the element at `mid` is equal to the target. If yes, return the index (`mid`) since the target is found in the array.
6. If the element at `mid` is less than the target, update `lastLessValueIndex` to `mid + 1` since the target would be inserted after the current `mid` element.
7. If the element at `mid` is greater than the target, adjust the right pointer to search in the left half of the array.
8. If the target is not found, the loop will terminate, and the function will return `lastLessValueIndex`.

Time Complexity (TC):
The time complexity of this algorithm is O(log N) where N is the number of elements in the `nums` array. This is because binary search reduces the search space by half in each iteration.

Space Complexity (SC):
The space complexity of this algorithm is O(1) because it uses a constant amount of extra space for the variables (`left`, `right`, `mid`, and `lastLessValueIndex`) regardless of the size of the input array.

```java
public int searchInsert(int[] nums, int target) {
    int n = nums.length; // Get the length of the input array.

    int left = 0, right = n - 1; // Initialize the left and right pointers.
    int lastLessValueIndex = 0; // Initialize a variable to store the index where the target would be inserted.

    while (left <= right) { // Perform binary search until the left and right pointers meet or cross each other.
        int mid = (right + left) / 2; // Calculate the middle index.

        if (nums[mid] == target) { // If the middle element is the target, return its index.
            return mid;
        }

        if (nums[mid] < target) { // If the middle element is less than the target, update the lastLessValueIndex and adjust the left pointer.
            lastLessValueIndex = mid + 1;
            left = mid + 1;
        } else {
            // If the middle element is greater than the target, adjust the right pointer.
            right = mid - 1;
        }
    }

    return lastLessValueIndex; // Return the index where the target would be inserted.
}
```
------------------------------------------------------------

6. Find Peak Element (Question #162) [Medium]:

A peak element is an element that is strictly greater than its neighbors.

Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.

You may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.

You must write an algorithm that runs in O(log n) time.

 

Example 1:

Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
Example 2:

Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.


Solution:

1. The first part of the code checks for special cases:
   - If there's only one element in the array, it is the peak element.
   - If the first element is greater than the second, it is the peak element.
   - If the last element is greater than the second-to-last, it is the peak element.
   These checks handle the edge cases and optimize the algorithm for arrays that have a peak at the start or end.

2. After handling the special cases, the algorithm proceeds with binary search to find a peak element in the remaining portion of the array. The binary search process continues until the left and right pointers meet or cross each other.

3. In each iteration of the binary search loop, the middle element (mid) is checked to see if it is a peak element (greater than its adjacent elements). If it is a peak element, its index is returned.

4. If the middle element is not a peak element, the algorithm determines whether it is in an increasing or decreasing sequence by comparing it with its adjacent element. Based on this information, the left or right pointer is adjusted to search for a peak in the appropriate direction.

Time Complexity (TC):
The time complexity of this algorithm is O(log N) because binary search reduces the search space by half in each iteration, where N is the number of elements in the `nums` array.

Space Complexity (SC):
The space complexity of this algorithm is O(1) because it uses a constant amount of extra space for the variables (`left`, `right`, `mid`, and `n`) regardless of the size of the input array.

```java
public int findPeakElement(int[] nums) {
    int n = nums.length;
    if (n == 1) {
        return 0; // If there's only one element in the array, it is the peak element.
    }

    if (nums[0] > nums[1]) {
        return 0; // If the first element is greater than the second, it is the peak element.
    }

    if (nums[n - 1] > nums[n - 2]) {
        return n - 1; // If the last element is greater than the second-to-last, it is the peak element.
    }

    int left = 1; // Initialize the left pointer to the second element.
    int right = n - 2; // Initialize the right pointer to the second-to-last element.

    while (left <= right) { // Perform binary search until the left and right pointers meet or cross each other.
        int mid = (left + right) / 2; // Calculate the middle index.

        // Check if the middle element is a peak element (greater than its adjacent elements).
        if (nums[mid] > nums[mid + 1] && nums[mid] > nums[mid - 1]) {
            return mid; // If the middle element is a peak, return its index.
        }

        // If the middle element is in an increasing sequence, move the left pointer to mid + 1.
        if (nums[mid] < nums[mid + 1]) {
            left = mid + 1;
        } else if (nums[mid] > nums[mid + 1]) {
            // If the middle element is in a decreasing sequence, move the right pointer to mid - 1.
            right = mid - 1;
        }
    }

    return -1; // Return -1 if a peak element is not found in the array.
}
```

------------------------------------------------------------

7. Search for a Range (Question #34) [Medium]:

Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.

If target is not found in the array, return [-1, -1].

You must write an algorithm with O(log n) runtime complexity.

Example 1:

Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
Example 2:

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
Example 3:

Input: nums = [], target = 0
Output: [-1,-1]

Solution:
The given code aims to find the first and last occurrences of the target element in a sorted array. The algorithm utilizes two binary search loops to find these occurrences.

1. The first binary search loop is used to find the leftmost occurrence of the target. It works in a similar way to standard binary search, but when the target is found, it continues searching on the left side to find the leftmost occurrence.
2. The second binary search loop is used to find the rightmost occurrence of the target. It also works similarly to standard binary search, but when the target is found, it continues searching on the right side to find the rightmost occurrence.

Time Complexity (TC):
The time complexity of this algorithm is O(log N) for each binary search loop, where N is the number of elements in the `nums` array. Since we have two binary search loops, the overall time complexity remains O(log N).

Space Complexity (SC):
The space complexity of this algorithm is O(1) because it uses a constant amount of extra space for the variables (`left`, `right`, `mid`, `result`, `leftMostIndex`, and `rightMostIndex`) regardless of the size of the input array.


```java
public int[] searchRange(int[] nums, int target) {
    int n = nums.length;
    if (n == 0) {
        return new int[]{-1, -1}; // If the input array is empty, return [-1, -1].
    }

    int left = 0;
    int right = nums.length - 1;

    int[] result = {-1, -1}; // Initialize the result array with [-1, -1].
    int leftMostIndex = -1; // Initialize variables to store the leftmost and rightmost indices of the target.
    int rightMostIndex = -1;

    // First, we'll find the leftmost occurrence of the target using binary search.
    while (left <= right) {
        int mid = (right + left) / 2;

        if (nums[mid] == target) {
            leftMostIndex = mid; // If target found, store the index in leftMostIndex and continue searching on the left side.
            right = mid - 1; // Adjust the right pointer to search in the left half.
        } else if (nums[mid] < target) {
            left = mid + 1; // If target is greater than mid, search in the right half.
        } else {
            right = mid - 1; // If target is less than mid, search in the left half.
        }
    }

    left = 0;
    right = nums.length - 1;

    // Now, we'll find the rightmost occurrence of the target using binary search.
    while (left <= right) {
        int mid = (right + left) / 2;

        if (nums[mid] == target) {
            rightMostIndex = mid; // If target found, store the index in rightMostIndex and continue searching on the right side.
            left = mid + 1; // Adjust the left pointer to search in the right half.
        } else if (nums[mid] < target) {
            left = mid + 1; // If target is greater than mid, search in the right half.
        } else {
            right = mid - 1; // If target is less than mid, search in the left half.
        }
    }

    result[0] = leftMostIndex; // Update the result array with the leftmost and rightmost indices of the target.
    result[1] = rightMostIndex;
    return result; // Return the result array.
}
```
------------------------------------------------------------

8. Sorted Array to Binary Search Tree (Question #108) [Easy]:
Given an integer array `nums` where the elements are sorted in ascending order, convert it to a height-balanced binary search tree (BST). A height-balanced BST is a binary tree in which the depth of the two subtrees of every node never differs by more than one.

Input: nums = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: [0,-10,5,null,-3,null,9] is also accepted:


Approach:
The given problem requires converting a sorted integer array into a height-balanced binary search tree (BST). A height-balanced BST is a binary tree in which the difference in the heights of the left and right subtrees of every node is at most one.

To construct a height-balanced BST, we can follow a recursive approach:
The main thing to notice here is Array is Sorted so the root will be always the middle element of the array

1. Find the middle element of the sorted array. This element will be the root of the BST.
2. Recursively construct the left subtree using the elements to the left of the middle element.
3. Recursively construct the right subtree using the elements to the right of the middle element.
4. Return the root node of the constructed BST.

Time Complexity (TC):
The time complexity of this algorithm is O(N), where N is the number of elements in the `nums` array. This is because each element of the array is visited once to construct the corresponding node in the BST.

Space Complexity (SC):
The space complexity of this algorithm is O(log N) due to the recursive call stack. In a balanced binary search tree, the maximum depth of the recursion is log N.

Code:

```java
public TreeNode sortedArrayToBST(int[] nums) {
    if (nums.length == 0) {
        return null; // If the input array is empty, return null as there are no nodes to create the BST.
    }

    return createTree(nums, 0, nums.length - 1); // Call the helper function to create the BST with the entire array.
}

public TreeNode createTree(int[] nums, int start, int end) {
    if (start > end) {
        return null; // Base case: If the start index becomes greater than the end index, return null.
    }

    int mid = (start + end) / 2; // Calculate the middle index.

    TreeNode node = new TreeNode(nums[mid]); // Create a new node with the middle element as the value.

    // Recursively construct the left and right subtrees using the elements to the left and right of the middle element.
    node.left = createTree(nums, start, mid - 1);
    node.right = createTree(nums, mid + 1, end);

    return node; // Return the root node of the constructed BST.
}
```
------------------------------------------------------------

9. Implement Binary Search (Question #702) [Medium]:
Given a sorted (in ascending order) integer array `nums` and a target value `target`, write a function to implement binary search iteratively and return the index of the target if it exists in the array. If the target is not found, return -1.

Given an integer array sorted in ascending order, write a function to search target in nums.  If target exists, then return its index, otherwise return -1. However, the array size is unknown to you. You may only access the array using an ArrayReader interface, where ArrayReader.get(k) returns the element of the array at index k (0-indexed).

You may assume all integers in the array are less than 10000, and if you access the array out of bounds, ArrayReader.get will return 2147483647.

 

Example 1:

Input: array = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4
Example 2:

Input: array = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1
 

Note:

You may assume that all elements in the array are unique.
The value of each element in the array will be in the range [-9999, 9999].


public int search(ArrayReader reader, int target) {
    int left = 0, right = 20000;
    while (left < right) {
        int mid = left + right >> 1;
        if (reader.get(mid) >= target) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return reader.get(left) == target ? left : -1;
}

-------------------------------------------------------------
-------------------------------------------------------------
##Sliding Window

1. Maximum Average Subarray I - (Maximum Sum Subarray of Size K) (easy) - LeetCode #643
You are given an integer array nums consisting of n elements, and an integer k.

Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10-5 will be accepted.

Example 1:

Input: nums = [1,12,-5,-6,50,3], k = 4
Output: 12.75000
Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75
Example 2:

Input: nums = [5], k = 1
Output: 5.00000

Approach:
The problem requires finding a contiguous subarray of length `k` with the maximum average value. To do this efficiently, we can use a sliding window approach.

1. Initialize two pointers, `left` and `right`, both set to 0.
2. Calculate the sum of the first `k` elements (i.e., the sum of the first window) and store it in the `window` variable.
3. Calculate the average of the current window, `window / k`, and set it as the initial `ans`.
4. Move the `right` pointer to `k` to create the first window of length `k`.
5. For each subsequent window, keep adding the next element (`nums[right]`) and removing the leftmost element (`nums[right - k]`) from the window sum. Calculate the average for each window and update the `ans` if a larger average is found.
6. Continue this process until the `right` pointer reaches the end of the array.

Code:
```java
public double findMaxAverage(int[] nums, int k) {
    int left = 0; // Left pointer for the sliding window
    int n = nums.length; // Length of the array
    double ans = 0; // Variable to store the answer (maximum average)
    double window = 0; // Variable to store the sum of the current window

    // Calculate the sum of the first window (first k elements)
    for (int i = 0; i < k; i++) {
        window += nums[i];
    }

    // Initialize the answer with the average of the first window
    ans = window / k;

    // Start moving the right pointer to form the subsequent windows
    for (int right = k; right < n; right++) {
        // Add the next element and remove the leftmost element from the window sum
        window += nums[right] - nums[right - k];
        // Update the answer if a larger average is found
        ans = Math.max(ans, window / k);
    }

    return ans; // Return the maximum average found
}
```

Time Complexity (TC):
The time complexity of this algorithm is O(n), where n is the number of elements in the `nums` array. We iterate through the array once to calculate the initial window sum, and then we move the `right` pointer from `k` to `n` to form the subsequent windows. Each iteration takes constant time.

Space Complexity (SC):
The space complexity of this algorithm is O(1) because we use only a constant amount of extra space to store the variables, regardless of the size of the input array.

-----------------------------------------------------

2. Minimum Window Substring (hard) - LeetCode #76
3. Longest Substring with At Most Two Distinct Characters (medium) - LeetCode #159
4. Fruit Into Baskets (medium) - LeetCode #904
5. Longest Repeating Character Replacement (medium) - LeetCode #424
6. Permutation in String (medium) - LeetCode #567
7. Longest Substring Without Repeating Characters (medium) - LeetCode #3
8. Find All Anagrams in a String (medium) - LeetCode #438
9. Subarrays with K Different Integers (hard) - LeetCode #992
10. Minimum Size Subarray Sum (medium) - LeetCode #209
11. Shortest Subarray with Sum at Least K (hard) - LeetCode #862
12. Replace the Substring for Balanced String (medium) - LeetCode #1234
13. Find K-Length Substrings With No Repeated Characters (medium) - LeetCode #1100
14. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit (medium) - LeetCode #1438
15. Max Consecutive Ones III (medium) - LeetCode #1004


-------------------------------------------------------------
-------------------------------------------------------------
##Heap

1. Kth Largest Element in an Array (Question #215) [Medium]:
Given an integer array nums and an integer k, return the kth largest element in the array.

Note that it is the kth largest element in the sorted order, not the kth distinct element.

Can you solve it without sorting?


Example 1:

Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
Example 2:

Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4

Approach:
The min heap will keep track of the k largest elements seen so far, with the smallest element at the top (root) of the heap. When the heap contains k elements, the smallest element will be the kth largest element among all elements seen so far.

1. We initialize an empty priority queue (`queue`) which acts as a min-heap.

2. We iterate through each element `i` in the input `nums` array.

3. If the priority queue (`queue`) has already k elements, we check if the smallest element (top element) in the min heap (`queue.peek()`) is less than the current element `i`. If it is, it means `i` is larger than the smallest element, so we remove the smallest element from the min heap and add the current element `i` to the heap. This ensures that we keep track of the k largest elements in the min heap at all times.

4. If the priority queue has less than k elements, we simply add the current element `i` to the min heap.

5. After processing all elements in the input array, the top element of the min heap (`queue.poll()`) will be the kth largest element.

Time Complexity (TC):
The time complexity of this algorithm is O(N log K), where N is the number of elements in the input array and K is the value of `k`. For each element, we perform heap operations (`offer()` and `poll()`), which take O(log K) time in the worst case. Since we have N elements, the overall time complexity is O(N log K).

Space Complexity (SC):
The space complexity of this algorithm is O(K) because we use a min heap (PriorityQueue) to store at most k elements at any given time.

```java
public int findKthLargest(int[] nums, int k) {
    PriorityQueue<Integer> queue = new PriorityQueue<>();

    for (int i : nums) {
        if (queue.size() == k) {
            // If the priority queue (min heap) has already k elements, compare the smallest element with the current element i.
            // If i is greater than the smallest element (i.e., the top element of the min heap), remove the smallest element and add i to the heap.
            if (queue.peek() < i) {
                queue.poll(); // Remove the smallest element from the min heap.
                queue.offer(i); // Add the current element i to the min heap.
            }
        } else {
            queue.offer(i); // If the priority queue has less than k elements, simply add the current element i to the min heap.
        }
    }

    return queue.poll(); // After processing all elements, the top element of the min heap will be the kth largest element.
}
```
--------------------------------------------------------------
--------------------------------------------------------------

##HashMap

1. Two Sum (Question #1):
Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.
Example:
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: The sum of 2 and 7 equals 9, so the output is [0,1].

public int[] twoSum(int[] nums, int target) {
    HashMap<Integer, Integer> map = new HashMap<>();

    for (int i = 0; i < nums.length; i++){
        int complement = target - nums[i];
        if (map.containsKey(complement)){
            return new int[] {map.get(complement), i};
        }
        map.put(nums[i], i);
    }
    return new int[]{};
}
