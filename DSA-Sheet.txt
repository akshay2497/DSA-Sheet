##Algorithm - Two Pointers
----------------------------------------------------------
1. Container With Most Water (Question #11):
Given `n` non-negative integers `height`, where each represents a point at coordinate `(i, height[i])`, n vertical lines are drawn such that the two endpoints of the line `i` are at `(i, height[i])` and `(i, 0)`. Find two lines, which, together with the x-axis, forms a container, such that the container contains the most water.
Example:
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The maximum area is obtained by choosing the second and sixth vertical lines.

Approach :
Initialize two pointers, start and end, pointing to the first and last indices of the array.
Initialize a variable maxArea to keep track of the maximum water area encountered so far.
While the start pointer is less than the end pointer:
Calculate the current water area using the formula: area = (end - start) * min(height[start], height[end]).
Update maxArea if the current area is greater than the previous maximum.
Move the pointer that points to the smaller height inward, as moving the pointer with the larger height won't increase the area.
Repeat step 3 until the pointers meet, indicating that all possible areas have been considered.
Return the maxArea as the result.

In this solution, we iterate through the array once using the two-pointer technique, resulting in a time complexity of O(n), where n is the number of elements in the array. The space complexity is O(1) as we only use a constant amount of extra space.

Java code :

public int maxArea(int[] height) {
    int n = height.length;
    int start = 0;
    int end = n - 1;
    int maxWaterArea = Integer.MIN_VALUE;

    while (start < end) {
        int minHeight = Math.min(height[start], height[end]);
        int currWaterArea = (end - start) * minHeight;
        maxWaterArea = Math.max(maxWaterArea, currWaterArea);

        if (height[start] < height[end])
            start++;
        else 
            end--;
    }

    return maxWaterArea;
}
----------------------------------------------------------------
2. Three Sum (Question #15):
Given an array `nums` of `n` integers, find all unique triplets in the array which gives the sum of `0`.
Example:
Input: nums = [-1,0,1,2,-1,-4]
Output: [[-1,-1,2],[-1,0,1]]

Approach:
To solve the Three Sum problem (Question #15), you can use the two-pointer technique combined with sorting the array. Here's how you can approach it:

1. Sort the given array in non-decreasing order. This step allows us to use the two-pointer technique effectively.
2. Iterate through the array from left to right, considering each element as a potential first element of the triplet.
   - Skip duplicate elements to avoid duplicate triplets.
   - For each element, set two pointers, `left` and `right`, initially pointing to the next element and the last element, respectively.
   - While `left` is less than `right`, calculate the sum of the three elements (current element + `nums[left]` + `nums[right]`).
     - If the sum is equal to zero, add the triplet `[nums[i], nums[left], nums[right]]` to the result set.
     - If the sum is less than zero, increment `left` to increase the sum.
     - If the sum is greater than zero, decrement `right` to decrease the sum.
     - Skip duplicate elements for `left` and `right` to avoid duplicate triplets.
3. Repeat step 2 until all elements have been considered as potential first elements.
4. Return the list of unique triplets that sum to zero.

In this solution, we sort the array first, which takes O(nlogn) time. Then, we iterate through the array using the two-pointer technique, resulting in a time complexity of O(n^2). The space complexity is O(1) as we only use a constant amount of extra space.

public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> result = new ArrayList<>();
    if (nums.length < 3) {
        return result;
    }
    Arrays.sort(nums);
    int n = nums.length;

    for (int i = 0; i < n-2; i++){
        //Check if i is not 0 and i-1 element should not be same to i'th
        //element else skip that triplet
        if (i > 0 && nums[i] == nums[i-1]) {
            continue;
        }
        int left = i+1;
        int right = n-1;

        while (left < right) {
            int target = nums[i] + nums[left] + nums[right];
            if (target == 0) {
                result.add(Arrays.asList(nums[i], nums[left], nums[right]));

                //avoid duplicates on left ptr
                while(left < right && nums[left] == nums[left+1]) {
                    left++;
                }

                //avoid duplicates on right ptr
                while(left < right && nums[right] == nums[right-1]) {
                    right--;
                }
                left++;
                right--;
            } else if (target < 0){
                left++;
            } else {
                right--;
            }
        }
    }
    return result;
}
----------------------------------------------------------------

3. Remove Duplicates from Sorted Array (Question #26):
Given a sorted array `nums`, remove the duplicates in-place such that each element appears only once and returns the new length.
Example:
Input: nums = [1,1,2]
Output: 2

Approach
1. Initialize two pointers, `ptr1` and `ptr2`, both initially set to 0 and 1 respectively. 
2. Iterate till ptr2 < array length
3. if nums[ptr1] == nums[ptr2] that means duplicates increment ptr2
4. if nums[ptr1] != nums[ptr2] that means distinct elements increment ptr1 and swap elements on both pointers increment both pointers
5. finally return ptr1+1 value that will be your total distinct elements

TC : O(N) - SC : O(1)

public int removeDuplicates(int[] nums) {
    if (nums.length < 2){
        return nums.length;
    }
    int n = nums.length;
    int ptr1 = 0;
    int ptr2 = 1;
    while (ptr2 < n) {
        if (nums[ptr1] == nums[ptr2]) {
            ptr2++;
        } else {
            ptr1++;
            int temp = nums[ptr2];
            nums[ptr2] = nums[ptr1];
            nums[ptr1] = temp;
            ptr2++;
        }
    }
    return ++ptr1;
}
----------------------------------------------------

4. Linked List Cycle II (Question #142):
Given a linked list, return the node where the cycle begins. If there is no cycle, return `null`.
Example:
Input: head = [3,2,0,-4], pos = 1
Output: the node with value 2
Explanation: There is a cycle in the linked list, where the tail connects to the second node.

To solve the Linked List Cycle II problem (Question #142), you can use the Floyd's Tortoise and Hare algorithm, also known as the "fast and slow pointers" technique. Here's how you can approach it:

1. Initialize two pointers, `slow` and `fast`, both initially set to the head of the linked list.
2. Move `slow` one step at a time and `fast` two steps at a time through the linked list.
3. Continue moving the pointers until they meet or `fast` reaches the end of the linked list (i.e., it becomes `null`).
   - If `fast` becomes `null`, it means there is no cycle in the linked list. Return `null`.
   - If `slow` and `fast` meet, it indicates the presence of a cycle in the linked list.
4. Reset the `slow` pointer to the head of the linked list and keep `fast` at the meeting point.
5. Move both pointers one step at a time until they meet again. The meeting point will be the start of the cycle.
6. Return the node at which the cycle starts.


Proof : 

1. Once the `fast` and `slow` pointers meet inside the cycle, let's say the distance from the head of the linked list to the start of the cycle is `D`, and the distance from the start of the cycle to the meeting point of the two pointers is `K`.

2. When the `fast` pointer catches up to the `slow` pointer, it has traveled twice the distance as the `slow` pointer. Therefore, the `fast` pointer has traveled a total distance of `D + K + C` (where `C` represents the number of complete cycles the `fast` pointer made within the cycle), while the `slow` pointer has traveled a distance of `D + K`.

3. Since the `fast` pointer moves twice as fast as the `slow` pointer, we can express their respective distances as follows: `2(D + K) = D + K + C`, which simplifies to `D + K = C`. This equation tells us that the distance from the head of the linked list to the start of the cycle is equal to the number of complete cycles within the cycle.

4. By resetting the `slow` pointer to the head of the linked list and keeping the `fast` pointer at the meeting point, and then moving both pointers one step at a time, the `slow` pointer will travel a distance of `D` to reach the start of the cycle, while the `fast` pointer will travel a distance of `C` within the cycle.

5. As the `slow` and `fast` pointers continue moving, they will eventually meet again at the start of the cycle. This is because the `slow` pointer has traveled a distance of `D`, while the `fast` pointer has traveled a distance of `C`, and we know from step 3 that `D` is equal to `C`.

In this solution, we use two pointers to detect the cycle and find the node where the cycle starts. The time complexity of this algorithm is O(n), where n is the number of nodes in the linked list. The space complexity is O(1) as we only use a constant amount of extra space.

Code : 
public ListNode detectCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;

    while(fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (fast == slow){
            break;
        }
    }

    if (fast == null || fast.next == null){
        return null;
    }

    slow = head;

    while (slow != fast) {
        slow = slow.next;
        fast = fast.next;
    }

    return slow;
}
-------------------------------------------------------------
5. Reverse Linked List II (Question #92):
Reverse a linked list from position `m` to `n`. Do it in one-pass and without using extra memory.
Example:
Input: 1 -> 2 -> 3 -> 4 -> 5, m = 2, n = 4
Output: 1 -> 4 -> 3 -> 2 -> 5

--------------------------------------------------------------

6. Longest Palindromic Substring (Question #5):
Given a string `s`, return the longest palindromic substring in `s`.
Example:
Input: "babad"
Output: "bab" or "aba"

class Solution {
    int totalSubStringLength = 0;
    int startPoint = 0;

    public String longestPalindrome(String s) {
        int n = s.length();

        // Iterate through each character of the input string
        for (int i = 0; i < n; i++) {
            findPalindrome(s, i, i);      // Consider current character as the center of a palindrome with an odd length
            findPalindrome(s, i, i+1);    // Consider current character and the next character as the center of a palindrome with an even length
        }

        // Return the longest palindromic substring using the startPoint and totalSubStringLength variables
        return s.substring(startPoint, startPoint + totalSubStringLength);
    }

    public void findPalindrome(String s, int start, int end) {
        // Expand around the center indices until the characters are equal or the boundary is reached
        while (start >= 0 && end < s.length() && s.charAt(start) == s.charAt(end)) {
            start--;
            end++;
        }

        // Check if the length of the current palindrome is greater than the stored length
        if (totalSubStringLength < end - start - 1) {
            startPoint = start + 1;                          // Update the starting index of the longest palindrome
            totalSubStringLength = end - start - 1;          // Update the length of the longest palindrome
        }
    }
}

1. The class defines two member variables: `totalSubStringLength` and `startPoint`.
   - `totalSubStringLength` stores the length of the longest palindromic substring found so far.
   - `startPoint` stores the starting index of the longest palindromic substring found so far.

2. The `longestPalindrome` method takes the input string `s` and returns the longest palindromic substring in `s`.

3. The method initializes `totalSubStringLength` and `startPoint` to 0.

4. The method iterates through each character of the input string `s` using a `for` loop.

5. For each character at index `i`, the method calls the `findPalindrome` method twice:
   - The first call considers the current character as the center of a palindrome with an odd length.
   - The second call considers the current character and the next character as the center of a palindrome with an even length.

6. The `findPalindrome` method is responsible for expanding around the center indices to find the length of the palindrome.

7. The `findPalindrome` method uses a `while` loop to expand the palindrome by checking if the characters at indices `start` and `end` are equal. It continues expanding as long as the characters are equal and there are characters available on both sides.

8. After the `while` loop, the `findPalindrome` method checks if the length of the current palindrome (given by `end - start - 1`) is greater than the stored length (`totalSubStringLength`).

9. If the length of the current palindrome is indeed longer, the `findPalindrome` method updates `startPoint` with the new starting index (`start + 1`) and `totalSubStringLength` with the new length (`end - start - 1`).

10. The `longestPalindrome` method returns the substring of `s` starting from `startPoint` and with a length of `totalSubStringLength`, representing the longest palindromic substring found in the input string.

The provided code is another valid implementation for finding the Longest Palindromic Substring. Here's an explanation of the code, with a focus on the specific block you mentioned:

```java
if (totalSubStringLength < end - start - 1) {
    startPoint = start + 1;
    totalSubStringLength = end - start - 1;
}
```

This block of code is responsible for updating the variables `startPoint` and `totalSubStringLength` when a longer palindromic substring is found.

- `totalSubStringLength` keeps track of the length of the longest palindromic substring found so far.
- `startPoint` stores the starting index of the longest palindromic substring found so far.

Here's how the block works:

1. The block is inside the `findPalindrome` method, which is called for each character in the string `s`.

2. The `while` loop inside `findPalindrome` expands the palindromic substring by checking if the characters at indices `start` and `end` are equal. It continues expanding as long as the characters are equal and there are characters available on both sides.

3. After the `while` loop, the block checks if the length of the current palindrome (given by `end - start - 1`) is greater than the stored length (`totalSubStringLength`).

4. If the length of the current palindrome is indeed longer, the block updates `startPoint` with the new starting index (`start + 1`) and `totalSubStringLength` with the new length (`end - start - 1`).

By updating these variables, the block ensures that `startPoint` and `totalSubStringLength` always store the starting index and length of the longest palindromic substring found so far during the iterations.

After the iterations are complete, the `longestPalindrome` method returns the substring of `s` starting from `startPoint` and with a length of `totalSubStringLength`, representing the longest palindromic substring found in the input string.


Time complexity Explanation

1. The `longestPalindrome` method contains a `for` loop that iterates through each character of the input string. Since there are n characters in the string, this loop has a time complexity of O(n).

2. Inside the `for` loop, the `findPalindrome` method is called twice for each character. This results in a nested loop structure where, in the worst case, each iteration of the outer loop triggers a loop iteration in the `findPalindrome` method.

3. The `findPalindrome` method contains a `while` loop that expands around the center indices until the characters are no longer equal or the boundary of the string is reached. This expansion process has a time complexity of O(n) in the worst case, where n is the length of the string.

4. Since the `findPalindrome` method is called twice for each character in the `longestPalindrome` method, and the expansion process within each call has a time complexity of O(n), the overall time complexity of the `longestPalindrome` method is O(n * n) = O(n^2).

Therefore, the overall time complexity of the provided `Solution` class is O(n^2), where n is the length of the input string `s`.

--------------------------------------------------------------

7. Merge Intervals (Question #56):
Given an array of intervals `intervals` where `intervals[i] = [start_i, end_i]`, merge all overlapping intervals.
Example:
Input: [[1, 3], [2, 6], [8, 10], [15, 18]]
Output: [[1, 6], [8, 10], [15, 18]]

Solution:

1. Sort the intervals based on the starting points. This ensures that overlapping intervals will be adjacent to each other after sorting.

2. Initialize an empty list to store the merged intervals.

3. Iterate through the sorted intervals. For each interval, check if it overlaps with the previous merged interval or if it is non-overlapping.

4. If the current interval overlaps with the previous merged interval, update the end point of the merged interval if necessary to include the current interval.

5. If the current interval is non-overlapping, add the previous merged interval to the result list and set the current interval as the new merged interval.

6. After iterating through all intervals, add the last merged interval to the result list.

7. Return the result list containing the merged intervals.

```java
public int[][] merge(int[][] intervals) {
    if (intervals == null || intervals.length == 0) {
        return new int[0][];
    }

    // Sort the intervals based on the starting points
    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

    List<int[]> mergedIntervals = new ArrayList<>();
    int[] currentInterval = intervals[0];

    // Iterate through the sorted intervals
    for (int i = 1; i < intervals.length; i++) {
        int[] interval = intervals[i];

        // If the current interval overlaps with the previous merged interval, update the end point if necessary
        if (interval[0] <= currentInterval[1]) {
            currentInterval[1] = Math.max(currentInterval[1], interval[1]);
        }
        // If the current interval is non-overlapping, add the previous merged interval to the result list
        else {
            mergedIntervals.add(currentInterval);
            currentInterval = interval;
        }
    }

    // Add the last merged interval to the result list
    mergedIntervals.add(currentInterval);

    // Convert the list to a 2D array
    int[][] result = new int[mergedIntervals.size()][2];
    for (int i = 0; i < mergedIntervals.size(); i++) {
        result[i] = mergedIntervals.get(i);
    }

    return result;
}
```

Time and Space complexity:
The time complexity of this solution is O(n log n), where n is the number of intervals. The sorting step takes O(n log n) time, and the merging step iterates through the sorted intervals once, which takes O(n) time. The space complexity is O(n) as we store the merged intervals in a list.

--------------------------------------------------------------

8. Valid Parentheses (Question #20):
Given a string `s` containing just the characters `'('`, `')'`, `'{'`, `'}'`, `'['`, `']'`, determine if the input string is valid.
Example:
Input: "{[]}"
Output: true

Solution:

1. The `isValid` method takes a string `s` as input and returns a boolean value indicating whether the parentheses in `s` are valid.

2. The method initializes a `Stack` data structure named `stack` to keep track of the opening parentheses encountered.

3. It also initializes a variable `n` with the length of the input string `s`.

4. The method iterates through each character of the input string using a `for` loop.

5. For each character, the method checks if it is an opening parenthesis (`(`, `[`, `{`). If so, it pushes the character onto the stack.

6. If the character is a closing parenthesis (`)`, `]`, `}`), the method checks if the stack is empty. If it is, this means there is no matching opening parenthesis for the current closing parenthesis, so the string is invalid, and the method returns `false`.

7. If the stack is not empty, the method pops the top character from the stack and compares it with the current closing parenthesis. If they do not match, this means the parentheses are not in the correct order, and the method returns `false`.

8. If all parentheses are matched and valid, the method continues the loop until all characters in the string are processed.

9. After the loop, the method checks if there are any remaining opening parentheses in the stack. If there are, this means the string is invalid because some opening parentheses were not closed, and the method returns `false`. Otherwise, it returns `true`.

The code follows a straightforward approach using a stack to track the opening parentheses encountered. It compares each closing parenthesis with the top of the stack to ensure that they match. If the stack is empty or the parentheses do not match, it returns `false`. Otherwise, if all parentheses are valid, it returns `true`.

Time and Space complexity :

The time complexity of this implementation is O(n), where n is the length of the input string `s`, as we iterate through each character once. The space complexity is O(n) as we use a stack to store opening parentheses, and in the worst case, all characters in `s` could be opening parentheses.

```Java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<>();

        int n = s.length();

        for (int i = 0; i < n; i++) {
            char currChar = s.charAt(i);

            if (currChar == '(' || currChar == '[' || currChar == '{') {
                stack.push(currChar);
            } else {
                if (stack.isEmpty()){
                    return false;
                }
                char poppedChar = stack.pop();
                if (currChar == ')' && poppedChar != '('){
                    return false;
                } else if (currChar == ']' && poppedChar != '[') {
                    return false;
                } else if (currChar == '}' && poppedChar != '{'){
                    return false;
                }
            }
        }
        return stack.size() > 0 ? false : true;
    }
}
```

--------------------------------------------------------------

9. Minimum Window Substring (Question #76):
Given two strings `s` and `t`, return the minimum window in `s` which will contain all the characters in `t` in complexity `O(n)`.
Example:
Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"

Solution:

1. Initialize two pointers, `left` and `right`, to track the window boundaries. Set them both to 0 initially.

2. Create two frequency maps, `targetMap` and `windowMap`, to track the character frequencies of the target string `t` and the current window in string `s`, respectively. Initially, both maps should be empty.

3. Populate the `targetMap` by iterating through the characters of string `t`. For each character, update its frequency in the map.

4. Initialize variables to track the minimum window length (`minWindowLength`), the starting index of the minimum window (`minWindowStart`), and a counter to keep track of the characters in `t` that have been matched in the current window (`matchedCount`). Set the `matchedCount` to 0 initially.

5. Start iterating through the string `s` using the `right` pointer:
   - For each character encountered, update its frequency in the `windowMap`.
   - If the character is present in the `targetMap` and its frequency in the `windowMap` is less than or equal to its frequency in the `targetMap`, increment the `matchedCount` by 1.

6. Check if all characters in `t` have been matched in the current window:
   - If the `matchedCount` is equal to the length of the target string `t`, it means all characters in `t` have been matched. In this case, we have found a valid window.
   - Update the minimum window length and the starting index of the minimum window if necessary.

7. Shrink the window by moving the `left` pointer:
   - While the `left` pointer can be moved and the current window still contains all characters from `t`, update the `windowMap` and `matchedCount` accordingly.
   - Check if the updated window is still valid (contains all characters from `t`).
   - If the updated window is still valid, update the minimum window length and the starting index of the minimum window if necessary.

8. Repeat steps 5 to 7 until the `right` pointer reaches the end of the string `s`.

9. After the loop, check if a valid window was found. If so, return the substring of `s` that corresponds to the minimum window length, starting from the `minWindowStart` index. Otherwise, return an empty string.

Code:

```java
public String minWindow(String s, String t) {
    HashMap<Character, Integer> targetMap = new HashMap<>(); // Frequency map for target string t
    HashMap<Character, Integer> windowMap = new HashMap<>(); // Frequency map for current window in s

    // Populate the targetMap with character frequencies from string t
    for (char ch : t.toCharArray()) {
        targetMap.put(ch, targetMap.getOrDefault(ch, 0) + 1);
    }

    int left = 0;                  // Left pointer of the window
    int right = 0;                 // Right pointer of the window
    int minWindowStart = 0;        // Starting index of the minimum window
    int minWindowLength = Integer.MAX_VALUE; // Minimum window length
    int matchedCount = 0;          // Counter to track matched characters

    // Iterate through the string s using the right pointer
    while (right < s.length()) {
        char rightChar = s.charAt(right);
        windowMap.put(rightChar, windowMap.getOrDefault(rightChar, 0) + 1); // Update the frequency of the character in the window map

        // If the current character is present in targetMap and its frequency in the window map is <= its frequency in targetMap
        if (targetMap.containsKey(rightChar) && windowMap.get(rightChar) <= targetMap.get(rightChar)) {
            matchedCount++; // Increment matchedCount as a character from t is matched
        }

        // Check if all characters from t have been matched in the current window
        while (matchedCount == t.length()) {
            // Update the minimum window length and starting index if necessary
            if (right - left + 1 < minWindowLength) {
                minWindowLength = right - left + 1;
                minWindowStart = left;
            }

            // Shrink the window from the left side
            char leftChar = s.charAt(left);
            windowMap.put(leftChar, windowMap.get(leftChar) - 1); // Update the frequency of the character in the window map

            // If the current character was one of the characters from t, decrement the matchedCount
            if (targetMap.containsKey(leftChar) && windowMap.get(leftChar) < targetMap.get(leftChar)) {
                matchedCount--;
            }

            left++; // Move the left pointer to shrink the window
        }

        right++; // Move the right pointer to expand the window
    }

    // Check if a valid window was found
    if (minWindowLength != Integer.MAX_VALUE) {
        return s.substring(minWindowStart, minWindowStart + minWindowLength);
    } else {
        return "";
    }
}
```

Time and Space Complexity :

The time complexity of this solution is O(n), where n is the length of the string `s`. The two pointers, `left` and `right`, traverse the string `s` only once. Additionally, the frequency maps and comparisons have constant time complexity since the number of characters is limited (128 ASCII characters). Therefore, the overall time complexity is linear, meeting the complexity requirement of O(n).

--------------------------------------------------------------

10. Remove Element (Question #27):
Given an array `nums` and a value `val`, remove all instances of that value in-place and return the new length.
Example:
Input: nums = [3, 2, 2, 3], val = 3
Output: 2

Solution:
In this solution, we use two pointers: `left` and `right`. The `left` pointer keeps track of the position where the non-val elements should be placed, and the `right` pointer iterates through the array to check each element.

The algorithm works as follows:

1. Initialize the `left` and `right` pointers to 0.
2. Iterate through the array with the `right` pointer.
3. If the element at the `right` pointer is not equal to `val`, it is a non-val element.
   - Assign the non-val element to the `left` pointer position in the array.
   - Increment the `left` pointer.
4. Increment the `right` pointer.
5. Repeat steps 3-4 until the end of the array.
6. Return the value of `left`, which represents the count of elements in `nums` that are not equal to `val`.

The time complexity of this solution is O(n), where n is the length of the input array `nums`. The algorithm iterates through the array only once, making it efficient.

TC = O(N) SC = O(1)

Code:
```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int left = 0; // Left pointer
        int right = 0; // Right pointer

        while (right < nums.length) {
            if (nums[right] != val) {
                nums[left] = nums[right];
                left++;
            }
            right++;
        }

        return left;
    }
}
```

--------------------------------------------------------------

11. Find the Index of the First Occurrence in a String (Question #28):
Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.
Example:
Input: haystack = "hello", needle = "ll"
Output: 2

Solution:
In this solution, we use two pointers: `i` for haystack and `j` for needle. The algorithm iterates through the haystack, comparing the characters with the needle.

The algorithm works as follows:

1. Check if the needle is empty. If so, it is always present at index 0 in haystack, so we return 0.
2. Set the lengths of the haystack and needle to variables `m` and `n`, respectively.
3. Iterate through the haystack from index 0 to index `m - n`.
4. Check if the current character in haystack matches the first character in needle.
5. If there's a match, store the starting index in the variable `start`.
6. Check if the remaining characters in haystack match the corresponding characters in needle.
7. If all characters in needle have matched, return the starting index `start` as the first occurrence of needle in haystack.
8. If not all characters have matched, reset the `i` pointer to the `start` index for the next iteration.
9. Repeat steps 4-8 until the end of the haystack is reached.
10. If needle is not part of haystack, return -1.

The time complexity of this solution is O((m-n) * n), where `m` is the length of the haystack and `n` is the length of the needle. In the worst case, the algorithm will compare each character in the haystack with the needle.

TC = O(N)

Code:

```java
class Solution {
    public int strStr(String haystack, String needle) {
        if (needle.isEmpty()) {
            return 0; // If needle is empty, it is always present at index 0 in haystack
        }
        
        int m = haystack.length();
        int n = needle.length();
        
        for (int i = 0; i <= m - n; i++) {
            int j = 0; // Needle pointer
            
            // Check if the current character in haystack matches the first character in needle
            if (haystack.charAt(i) == needle.charAt(j)) {
                int start = i; // Store the starting index in haystack
                
                // Check if the remaining characters in haystack match the corresponding characters in needle
                while (j < n && i < m && haystack.charAt(i) == needle.charAt(j)) {
                    i++;
                    j++;
                }
                
                // If j reaches the end of needle, it means all characters have matched
                if (j == n) {
                    return start; // Return the starting index of the first occurrence of needle in haystack
                }
                
                // Reset i to the starting index in haystack for the next iteration
                i = start;
            }
        }
        
        return -1; // Needle is not part of haystack
    }
}
```

--------------------------------------------------------------

12. Next Permutation (Question #31):
Implement `next permutation`, which rearranges numbers into the lexicographically next greater permutation of numbers.
Example:
Input: nums = [1, 2, 3]
Output: [1, 3, 2]

--------------------------------------------------------------

13. Remove Nth Node From End of List (Question #19):
Given the `head` of a linked list, remove the `nth` node from the end of the list and return its head.
Example:
Input: 1 -> 2 -> 3 -> 4 -> 5, n = 2
Output: 1 -> 2 -> 3 -> 5

Solution:

The solution uses two pointers, `leftPtr` and `rightPtr`, to remove the `nth` node from the end of the linked list. Here's the explanation of the solution:

1. Create a `dummyPtr` as a dummy node with a value of 0 and set its `next` pointer to the `head` of the linked list. This is done to handle the edge case where the `nth` node to be removed is the first node in the list.

2. Initialize the `leftPtr` to the `dummyPtr` and the `rightPtr` to the `head`.

3. Move the `rightPtr` `n` steps forward. This ensures that the distance between the `leftPtr` and `rightPtr` is exactly `n` nodes.

4. While `rightPtr` is not null, move both the `leftPtr` and `rightPtr` one step forward. This continues until the `rightPtr` reaches the end of the list.

5. At this point, the `leftPtr` will be pointing to the node just before the `nth` node from the end.

6. Update the `leftPtr` to skip the `nth` node by adjusting its `next` pointer to point to the node after the `nth` node.

7. Finally, return the `dummyPtr.next`, which is the updated head of the linked list.

Code : 

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummyPtr = new ListNode(0, head); // Create a dummy node
    ListNode leftPtr = dummyPtr; // Initialize left pointer to the dummy node
    ListNode rightPtr = head; // Initialize right pointer to the head

    while (n > 0 && rightPtr != null) {
        rightPtr = rightPtr.next; // Move right pointer n steps forward
        n--;
    }

    while (rightPtr != null) {
        rightPtr = rightPtr.next; // Move both pointers one step forward
        leftPtr = leftPtr.next;
    }

    leftPtr.next = leftPtr.next.next; // Skip the nth node by adjusting the next pointer of leftPtr

    return dummyPtr.next; // Return the head of the updated linked list
}
```

The time complexity of this solution is O(L), where L is the length of the linked list. The algorithm iterates through the linked list only once, performing a constant number of operations at each node. Therefore, the time complexity is linear in the length of the linked list.


--------------------------------------------------------------

14. Rotate Array (Question #189):
Given an array, rotate the array to the right by `k` steps, where `k` is non-negative.
Example:
Input: nums = [1, 2, 3, 4, 5, 6, 7], k = 3
Output: [5, 6, 7, 1, 2, 3, 4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]


Solution : 

The solution uses a reverse technique to rotate the array in-place. Here's the explanation of the solution:

1. In the `rotate` function, start by updating the value of `k` to `k % nums.length`. This is done to handle cases where `k` is larger than the length of the array. Taking the modulus ensures that `k` is within the valid range.

2. Initialize the variable `N` to `nums.length - 1`. This represents the last index of the array.

3. Call the `reverse` function three times:
   a. Reverse the entire array using `reverse(nums, 0, N)`. This step effectively reverses the entire array.
   b. Reverse the first `k` elements of the array using `reverse(nums, 0, k - 1)`. This step reverses the subarray containing the first `k` elements.
   c. Reverse the remaining elements of the array using `reverse(nums, k, N)`. This step reverses the subarray containing the remaining elements after the first `k` elements.

The `reverse` function is a helper function used to reverse a subarray within the array. It takes the array, the left index, and the right index as parameters.


Code : 

```java
public void rotate(int[] nums, int k) {
    k = k % nums.length; // Handle cases where k is larger than the length of the array
    int N = nums.length - 1; // Last index of the array
    
    reverse(nums, 0, N); // Reverse the entire array
    reverse(nums, 0, k - 1); // Reverse the first k elements
    reverse(nums, k, N); // Reverse the remaining elements
}

public void reverse(int[] arr, int left, int right) {
    while (left <= right) {
        int temp = arr[left]; // Swap elements at left and right indices
        arr[left] = arr[right];
        arr[right] = temp;
        left++; // Move left pointer towards the right
        right--; // Move right pointer towards the left
    }
}
```
Time and Space Complexity :

The time complexity of this solution is O(N), where N is the length of the array. The algorithm performs three reversals, each of which takes O(N/2) time. However, in big O notation, we ignore constant factors, so the overall time complexity is simplified to O(N).

The space complexity of the solution is O(1) since the algorithm operates in-place without using any additional data structures.

--------------------------------------------------------------
--------------------------------------------------------------

##Binary Search Algorithm


1. Binary Search (Question #704) [Easy]:
Given a sorted (in ascending order) integer array `nums` and a target value `target`, write a function to implement binary search and      return the index of the target in the array. If the target is not found, return -1.


Solution :
1. Initialize variables `left` and `right` as the start and end indices of the input array.
2. Perform binary search by repeatedly dividing the search space until `left` is less than or equal to `right`.
3. Calculate the middle index `mid` using `(left + right) / 2` to find the mid-point of the current search space.
4. Check if the element at index `mid` is equal to the target. If so, return `mid`, as we found the target.
5. If the element at index `mid` is less than the target, move the left pointer to `mid + 1` to search the right half of the current search space.
6. If the element at index `mid` is greater than the target, move the right pointer to `mid - 1` to search the left half of the current search space.
7. Repeat steps 3 to 6 until `left` becomes greater than `right`.

Time Complexity (TC): The time complexity of this binary search algorithm is O(log n), where n is the number of elements in the input array. Binary search efficiently reduces the search space by half in each iteration, resulting in logarithmic time complexity.

Space Complexity (SC): The space complexity is O(1) since the algorithm only uses a constant amount of extra space to store the variables `left`, `right`, and `mid`, regardless of the size of the input array.

Code:

```java
public int search(int[] nums, int target) {
    // Get the length of the input array
    int n = nums.length;
    
    // Initialize the left and right pointers for binary search
    int left = 0, right = n - 1;
    
    // Binary search loop
    while (left <= right) {
        // Calculate the mid index using the left and right pointers
        int mid = left + (right - left) / 2;
        
        // If the middle element is the target, return its index
        if (nums[mid] == target) {
            return mid;
        }

        // If the middle element is less than the target, ignore the left half
        if (nums[mid] < target) {
            left = mid + 1;
        }
        // If the middle element is greater than the target, ignore the right half
        else {
            right = mid - 1;
        }
    }

    // If the target is not found, return -1
    return -1;
}

Recursive : 
public int search(int[] nums, int target) {
    return binarySearch(nums, target, 0, nums.length - 1);
}

private int binarySearch(int[] nums, int target, int left, int right) {
    if (left > right) {
        return -1; // Base case: Target not found
    }

    int mid = left + (right - left) / 2;

    if (nums[mid] == target) {
        return mid; // Base case: Target found
    } else if (nums[mid] < target) {
        // Recursive call to search the right half
        return binarySearch(nums, target, mid + 1, right);
    } else {
        // Recursive call to search the left half
        return binarySearch(nums, target, left, mid - 1);
    }
}

```

----------------------------------------------------------

2. First Bad Version (Question #278) [Easy]:
You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

Example 1:

Input: n = 5, bad = 4
Output: 4
Explanation:
call isBadVersion(3) -> false
call isBadVersion(5) -> true
call isBadVersion(4) -> true
Then 4 is the first bad version.
Example 2:

Input: n = 1, bad = 1
Output: 1

Solution:
1. Initialize the `left` and `right` pointers to the first and last versions (1 and `n`) in the range to be searched.
2. Initialize the `ans` variable to store the answer, i.e., the index of the first bad version.
3. Perform binary search using the `while` loop, which continues as long as the `left` pointer is less than or equal to the `right` pointer.
4. Calculate the middle index `mid` using `(left + right) / 2` to divide the search space.
5. Check if the middle version `mid` is bad using the `isBadVersion()` function.
6. If the middle version is bad, update the `ans` to `mid` as we found a possible candidate for the first bad version, and continue searching the left half to find the first occurrence of the bad version.
7. If the middle version is not bad, continue searching the right half.
8. Repeat steps 4 to 7 until the `left` pointer becomes greater than the `right` pointer, indicating that we have found the first bad version.
9. Return the `ans` as the index of the first bad version.

Time Complexity (TC): The time complexity of this binary search algorithm is O(log n), where `n` is the number of versions. Binary search efficiently reduces the search space by half in each iteration, resulting in logarithmic time complexity.

Space Complexity (SC): The space complexity is O(1) since the algorithm only uses a constant amount of extra space to store the variables `left`, `right`, `ans`, and `mid`, regardless of the size of the input `n`.

Code: 

```java
public int firstBadVersion(int n) {
    // Initialize left and right pointers to search the versions
    int left = 1, right = n;
    
    // Initialize a variable to store the answer (first bad version)
    int ans = 0;

    // Binary search loop
    while (left <= right) {
        // Calculate the middle index using the left and right pointers
        int mid = left + (right - left) / 2;

        // Check if the middle version is bad (using the provided isBadVersion() function)
        if (isBadVersion(mid)) {
            // If the middle version is bad, update the answer to mid and search the left half
            ans = mid;
            right = mid - 1;
        } else {
            // If the middle version is not bad, search the right half
            left = mid + 1;
        }
    }

    // Return the first bad version found
    return ans;
}
```
-----------------------------------------------------------

3. Find Minimum in Rotated Sorted Array (Question #153) [Medium]:
Suppose an array of length `n` is rotated at an unknown pivot index and initially sorted in ascending order. Find the minimum element in the array. You may assume that the array does not contain duplicates.

Solution:
1. The binary search algorithm is used to find the minimum element in a rotated sorted array.
2. Initialize `left` and `right` pointers to the first and last elements of the array, respectively.
3. Perform binary search using the `while` loop, which continues as long as `left` is less than `right`.
4. Calculate the middle index `mid` using `(left + right) / 2`.
5. Check if the element at the middle index `mid` is greater than the element at the right index `right`. If true, it means that the minimum element is on the right side of `mid`, so we update `left = mid + 1`.
6. Check if the element at the middle index `mid` is less than the element at the right index `right`. If true, 
it means that the minimum element is either `mid` or on the left side of `mid`, so we update `right = mid`.
7. If the element at the middle index `mid` is equal to the element at the right index `right`, it means there are duplicate elements. In this case, we can safely ignore the rightmost element as it will not affect the minimum element, so we update `right--` to exclude the duplicate element.
8. Repeat steps 4 to 7 until `left` becomes equal to `right`, indicating that we have found the minimum element.
9. Return the element at the `left` index, which is the minimum element.

Time Complexity (TC): The time complexity of this binary search algorithm is O(log n), where `n` is the number of elements in the array. Binary search efficiently reduces the search space by half in each iteration, resulting in logarithmic time complexity.

Space Complexity (SC): The space complexity is O(1) since the algorithm only uses a constant amount of extra space to store the variables `left`, `right`, and `mid`, regardless of the size of the input array.

Code:

```java
public int findMin(int[] nums) {
    int left = 0;
    int right = nums.length - 1;

    while (left < right) {
        int mid = left + (right - left) / 2;

        // Check if the middle element is greater than the rightmost element
        // If true, the minimum element is on the right side, 
        // so we update the left pointer
        if (nums[mid] > nums[right]) {
            left = mid + 1;
        }
        // Check if the middle element is less than the rightmost element
        // If true, the minimum element is either the middle element or 
        // on the left side
        // So we update the right pointer to mid since mid can be 
        // a potential candidate for the minimum element
        else if (nums[mid] < nums[right]) {
            right = mid;
        }
        // If the middle element is equal to the rightmost element
        // We can safely ignore the rightmost element as it will 
        // not affect the minimum element
        // So we update the right pointer to exclude the duplicate element
        // Below case is puerly to avoid duplicates in the array
        else {
            right--;
        }
    }

    // The left pointer will point to the minimum element
    return nums[left];
}
```

---------------------------------------------------------

4. Search in Rotated Sorted Array (Question #33) [Medium]:
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. You are given a target value to search for. If found in the array, return its index; otherwise, return -1. You may assume no duplicate exists in the array.

There is an integer array nums sorted in ascending order (with distinct values).

Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].

Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.

You must write an algorithm with O(log n) runtime complexity.

Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
Example 3:

Input: nums = [1], target = 0
Output: -1

Solution:

The given code implements a modified version of binary search to find the target element in a rotated sorted array. The algorithm exploits the fact that at least one half of the rotated array will always be sorted.

1. Initialize the left pointer to the beginning of the array (`0`) and the right pointer to the end of the array (`nums.length - 1`).
2. Use a while loop to perform binary search until the left and right pointers meet or cross each other.
3. Calculate the middle index (`mid`) in each iteration.
4. Check if the element at `mid` is equal to the target. If yes, return the index (`mid`).
5. Check if the left half or the right half is sorted by comparing the values at `left` and `mid`. This step helps in identifying which half to search for the target.
6. Adjust the pointers accordingly to continue the binary search in the sorted half that potentially contains the target element.
7. If the target is not found, the loop will terminate, and the function will return `-1`.

Time Complexity (TC):
The time complexity of this algorithm is O(log N) where N is the number of elements in the `nums` array. This is because binary search reduces the search space by half in each iteration.

Space Complexity (SC):
The space complexity of this algorithm is O(1) because it uses a constant amount of extra space for the variables (`left`, `right`, `mid`, and `target`) regardless of the size of the input array.

```java
public int search(int[] nums, int target) {
    int left = 0; // Initialize the left pointer to the start of the array.
    int right = nums.length - 1; // Initialize the right pointer to the end of the array.

    while (left <= right) { // Perform binary search until left and right pointers meet.
        int mid = (left + right) / 2; // Calculate the middle index.

        if (nums[mid] == target) { // If the middle element is the target, return its index.
            return mid;
        }

        if (nums[left] <= nums[mid]) { // Check if the left half is sorted.
            if (target >= nums[left] && target < nums[mid]) {
                // If the target lies in the left sorted half, adjust the right pointer.
                right = mid - 1;
            } else {
                // If the target doesn't lie in the left sorted half, adjust the left pointer.
                left = mid + 1;
            }
        } else {
            // The right half is sorted.
            if (target <= nums[right] && target > nums[mid]) {
                // If the target lies in the right sorted half, adjust the left pointer.
                left = mid + 1;
            } else {
                // If the target doesn't lie in the right sorted half, adjust the right pointer.
                right = mid - 1;
            }
        }
    }

    return -1; // Return -1 if the target is not found in the array.
}
```
--------------------------------------------------

5. Search Insert Position (Question #35) [Easy]:
Given a sorted array of distinct integers `nums` and a target value `target`, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

Example 1:

Input: nums = [1,3,5,6], target = 5
Output: 2
Example 2:

Input: nums = [1,3,5,6], target = 2
Output: 1
Example 3:

Input: nums = [1,3,5,6], target = 7
Output: 4

Solution:
The given code implements a modified version of binary search to find the index where the target should be inserted in the sorted array.

1. Initialize the left pointer to the beginning of the array (`0`) and the right pointer to the end of the array (`n - 1`).
2. Initialize a variable `lastLessValueIndex` to keep track of the index where the target would be inserted if it's not found in the array.
3. Use a while loop to perform binary search until the left and right pointers meet or cross each other.
4. Calculate the middle index (`mid`) in each iteration.
5. Check if the element at `mid` is equal to the target. If yes, return the index (`mid`) since the target is found in the array.
6. If the element at `mid` is less than the target, update `lastLessValueIndex` to `mid + 1` since the target would be inserted after the current `mid` element.
7. If the element at `mid` is greater than the target, adjust the right pointer to search in the left half of the array.
8. If the target is not found, the loop will terminate, and the function will return `lastLessValueIndex`.

Time Complexity (TC):
The time complexity of this algorithm is O(log N) where N is the number of elements in the `nums` array. This is because binary search reduces the search space by half in each iteration.

Space Complexity (SC):
The space complexity of this algorithm is O(1) because it uses a constant amount of extra space for the variables (`left`, `right`, `mid`, and `lastLessValueIndex`) regardless of the size of the input array.

```java
public int searchInsert(int[] nums, int target) {
    int n = nums.length; // Get the length of the input array.

    int left = 0, right = n - 1; // Initialize the left and right pointers.
    int lastLessValueIndex = 0; // Initialize a variable to store the index where the target would be inserted.

    while (left <= right) { // Perform binary search until the left and right pointers meet or cross each other.
        int mid = (right + left) / 2; // Calculate the middle index.

        if (nums[mid] == target) { // If the middle element is the target, return its index.
            return mid;
        }

        if (nums[mid] < target) { // If the middle element is less than the target, update the lastLessValueIndex and adjust the left pointer.
            lastLessValueIndex = mid + 1;
            left = mid + 1;
        } else {
            // If the middle element is greater than the target, adjust the right pointer.
            right = mid - 1;
        }
    }

    return lastLessValueIndex; // Return the index where the target would be inserted.
}
```
------------------------------------------------------------

6. Find Peak Element (Question #162) [Medium]:

A peak element is an element that is strictly greater than its neighbors.

Given a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, 
return the index to any of the peaks.

You may imagine that nums[-1] = nums[n] = -. In other words, an element is always considered to be strictly greater 
than a neighbor that is outside the array.

You must write an algorithm that runs in O(log n) time.

 

Example 1:

Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
Example 2:

Input: nums = [1,2,1,3,5,6,4]
Output: 5
Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 
where the peak element is 6.


Solution:

1. The first part of the code checks for special cases:
   - If there's only one element in the array, it is the peak element.
   - If the first element is greater than the second, it is the peak element.
   - If the last element is greater than the second-to-last, it is the peak element.
   These checks handle the edge cases and optimize the algorithm for arrays that have a peak at the start or end.

2. After handling the special cases, the algorithm proceeds with binary search to find a peak element in the remaining portion of the array. The binary search process continues until the left and right pointers meet or cross each other.

3. In each iteration of the binary search loop, the middle element (mid) is checked to see if it is a peak element (greater than its adjacent elements). If it is a peak element, its index is returned.

4. If the middle element is not a peak element, the algorithm determines whether it is in an increasing or decreasing sequence by comparing it with its adjacent element. Based on this information, the left or right pointer is adjusted to search for a peak in the appropriate direction.

Time Complexity (TC):
The time complexity of this algorithm is O(log N) because binary search reduces the search space by half in each iteration, where N is the number of elements in the `nums` array.

Space Complexity (SC):
The space complexity of this algorithm is O(1) because it uses a constant amount of extra space for the variables (`left`, `right`, `mid`, and `n`) regardless of the size of the input array.

```java
public int findPeakElement(int[] nums) {
    int n = nums.length;
    if (n == 1) {
        return 0; // If there's only one element in the array, it is the peak element.
    }

    if (nums[0] > nums[1]) {
        return 0; // If the first element is greater than the second, it is the peak element.
    }

    if (nums[n - 1] > nums[n - 2]) {
        return n - 1; // If the last element is greater than the second-to-last, it is the peak element.
    }

    int left = 1; // Initialize the left pointer to the second element.
    int right = n - 2; // Initialize the right pointer to the second-to-last element.

    while (left <= right) { // Perform binary search until the left and right pointers meet or cross each other.
        int mid = (left + right) / 2; // Calculate the middle index.

        // Check if the middle element is a peak element (greater than its adjacent elements).
        if (nums[mid] > nums[mid + 1] && nums[mid] > nums[mid - 1]) {
            return mid; // If the middle element is a peak, return its index.
        }

        // If the middle element is in an increasing sequence, move the left pointer to mid + 1.
        if (nums[mid] < nums[mid + 1]) {
            left = mid + 1;
        } else if (nums[mid] > nums[mid + 1]) {
            // If the middle element is in a decreasing sequence, move the right pointer to mid - 1.
            right = mid - 1;
        }
    }

    return -1; // Return -1 if a peak element is not found in the array.
}
```

------------------------------------------------------------

7. Search for a Range (Question #34) [Medium]:

Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.

If target is not found in the array, return [-1, -1].

You must write an algorithm with O(log n) runtime complexity.

Example 1:

Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
Example 2:

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
Example 3:

Input: nums = [], target = 0
Output: [-1,-1]

Solution:
The given code aims to find the first and last occurrences of the target element in a sorted array. The algorithm utilizes 
two binary search loops to find these occurrences.

1. The first binary search loop is used to find the leftmost occurrence of the target. It works in a similar way to 
standard binary search, but when the target is found, it continues searching on the left side to find the leftmost occurrence.
2. The second binary search loop is used to find the rightmost occurrence of the target. It also works similarly to 
standard binary search, but when the target is found, it continues searching on the right side to find the rightmost occurrence.

Time Complexity (TC):
The time complexity of this algorithm is O(log N) for each binary search loop, where N is the number of elements in the `nums` array. Since we have two binary search loops, the overall time complexity remains O(log N).

Space Complexity (SC):
The space complexity of this algorithm is O(1) because it uses a constant amount of extra space for the variables (`left`, `right`, `mid`, `result`, `leftMostIndex`, and `rightMostIndex`) regardless of the size of the input array.


```java
public int[] searchRange(int[] nums, int target) {
    int n = nums.length;
    if (n == 0) {
        return new int[]{-1, -1}; // If the input array is empty, return [-1, -1].
    }

    int left = 0;
    int right = nums.length - 1;

    int[] result = {-1, -1}; // Initialize the result array with [-1, -1].
    int leftMostIndex = -1; // Initialize variables to store the leftmost and rightmost indices of the target.
    int rightMostIndex = -1;

    // First, we'll find the leftmost occurrence of the target using binary search.
    while (left <= right) {
        int mid = (right + left) / 2;

        if (nums[mid] == target) {
            leftMostIndex = mid; // If target found, store the index in leftMostIndex and continue searching on the left side.
            right = mid - 1; // Adjust the right pointer to search in the left half.
        } else if (nums[mid] < target) {
            left = mid + 1; // If target is greater than mid, search in the right half.
        } else {
            right = mid - 1; // If target is less than mid, search in the left half.
        }
    }

    left = 0;
    right = nums.length - 1;

    // Now, we'll find the rightmost occurrence of the target using binary search.
    while (left <= right) {
        int mid = (right + left) / 2;

        if (nums[mid] == target) {
            rightMostIndex = mid; // If target found, store the index in rightMostIndex and continue searching on the right side.
            left = mid + 1; // Adjust the left pointer to search in the right half.
        } else if (nums[mid] < target) {
            left = mid + 1; // If target is greater than mid, search in the right half.
        } else {
            right = mid - 1; // If target is less than mid, search in the left half.
        }
    }

    result[0] = leftMostIndex; // Update the result array with the leftmost and rightmost indices of the target.
    result[1] = rightMostIndex;
    return result; // Return the result array.
}
```
------------------------------------------------------------

8. Sorted Array to Binary Search Tree (Question #108) [Easy]:
Given an integer array `nums` where the elements are sorted in ascending order, convert it to a height-balanced binary search tree (BST). A height-balanced BST is a binary tree in which the depth of the two subtrees of every node never differs by more than one.

Input: nums = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: [0,-10,5,null,-3,null,9] is also accepted:


Approach:
The given problem requires converting a sorted integer array into a height-balanced binary search tree (BST). 
A height-balanced BST is a binary tree in which the difference in the heights of the left and right subtrees of 
every node is at most one.

To construct a height-balanced BST, we can follow a recursive approach:
The main thing to notice here is Array is Sorted so the root will be always the middle element of the array

1. Find the middle element of the sorted array. This element will be the root of the BST.
2. Recursively construct the left subtree using the elements to the left of the middle element.
3. Recursively construct the right subtree using the elements to the right of the middle element.
4. Return the root node of the constructed BST.

Time Complexity (TC):
The time complexity of this algorithm is O(N), where N is the number of elements in the `nums` array. 
This is because each element of the array is visited once to construct the corresponding node in the BST.

Space Complexity (SC):
The space complexity of this algorithm is O(log N) due to the recursive call stack. In a balanced binary search tree, 
the maximum depth of the recursion is log N.

Code:

```java
public TreeNode sortedArrayToBST(int[] nums) {
    if (nums.length == 0) {
        return null; // If the input array is empty, return null as there are no nodes to create the BST.
    }

    return createTree(nums, 0, nums.length - 1); // Call the helper function to create the BST with the entire array.
}

public TreeNode createTree(int[] nums, int start, int end) {
    if (start > end) {
        return null; // Base case: If the start index becomes greater than the end index, return null.
    }

    int mid = (start + end) / 2; // Calculate the middle index.

    TreeNode node = new TreeNode(nums[mid]); // Create a new node with the middle element as the value.

    // Recursively construct the left and right subtrees using the elements to the left and right of the middle element.
    node.left = createTree(nums, start, mid - 1);
    node.right = createTree(nums, mid + 1, end);

    return node; // Return the root node of the constructed BST.
}
```
------------------------------------------------------------

9. Implement Binary Search (Question #702) [Medium]:
Given a sorted (in ascending order) integer array `nums` and a target value `target`, write a function to implement binary search iteratively and return the index of the target if it exists in the array. If the target is not found, return -1.

Given an integer array sorted in ascending order, write a function to search target in nums.  If target exists, then return its index, otherwise return -1. However, the array size is unknown to you. You may only access the array using an ArrayReader interface, where ArrayReader.get(k) returns the element of the array at index k (0-indexed).

You may assume all integers in the array are less than 10000, and if you access the array out of bounds, ArrayReader.get will return 2147483647.

 

Example 1:

Input: array = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4
Example 2:

Input: array = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1
 

Note:

You may assume that all elements in the array are unique.
The value of each element in the array will be in the range [-9999, 9999].


public int search(ArrayReader reader, int target) {
    int left = 0, right = 20000;
    while (left < right) {
        int mid = left + right >> 1;
        if (reader.get(mid) >= target) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return reader.get(left) == target ? left : -1;
}

-------------------------------------------------------------
-------------------------------------------------------------
##Sliding Window

1. Maximum Average Subarray I - (Maximum Sum Subarray of Size K) (easy) - LeetCode #643
You are given an integer array nums consisting of n elements, and an integer k.

Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer 
with a calculation error less than 10-5 will be accepted.

Example 1:

Input: nums = [1,12,-5,-6,50,3], k = 4
Output: 12.75000
Explanation: Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75
Example 2:

Input: nums = [5], k = 1
Output: 5.00000

Approach:
The problem requires finding a contiguous subarray of length `k` with the maximum average value. To do this efficiently, we can use a sliding window approach.

1. Initialize two pointers, `left` and `right`, both set to 0.
2. Calculate the sum of the first `k` elements (i.e., the sum of the first window) and store it in the `window` variable.
3. Calculate the average of the current window, `window / k`, and set it as the initial `ans`.
4. Move the `right` pointer to `k` to create the first window of length `k`.
5. For each subsequent window, keep adding the next element (`nums[right]`) and removing the leftmost element (`nums[right - k]`) from the window sum. Calculate the average for each window and update the `ans` if a larger average is found.
6. Continue this process until the `right` pointer reaches the end of the array.

Code:
```java
public double findMaxAverage(int[] nums, int k) {
    int left = 0; // Left pointer for the sliding window
    int n = nums.length; // Length of the array
    double ans = 0; // Variable to store the answer (maximum average)
    double window = 0; // Variable to store the sum of the current window

    // Calculate the sum of the first window (first k elements)
    for (int i = 0; i < k; i++) {
        window += nums[i];
    }

    // Initialize the answer with the average of the first window
    ans = window / k;

    // Start moving the right pointer to form the subsequent windows
    for (int right = k; right < n; right++) {
        // Add the next element and remove the leftmost element from the window sum
        window += nums[right] - nums[right - k];
        // Update the answer if a larger average is found
        ans = Math.max(ans, window / k);
    }

    return ans; // Return the maximum average found
}
```

Time Complexity (TC):
The time complexity of this algorithm is O(n), where n is the number of elements in the `nums` array. We iterate through the array once to calculate the initial window sum, and then we move the `right` pointer from `k` to `n` to form the subsequent windows. Each iteration takes constant time.

Space Complexity (SC):
The space complexity of this algorithm is O(1) because we use only a constant amount of extra space to store the variables, regardless of the size of the input array.

-----------------------------------------------------

2. Minimum Window Substring (hard) - LeetCode #76

Given two strings s and t of lengths m and n respectively, return the minimum window 
substring
 of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string "".

The testcases will be generated such that the answer is unique.

 

Example 1:

Input: s = "ADOBECODEBANC", t = "ABC"
Output: "BANC"
Explanation: The minimum window substring "BANC" includes 'A', 'B', and 'C' from string t.
Example 2:

Input: s = "a", t = "a"
Output: "a"
Explanation: The entire string s is the minimum window.
Example 3:

Input: s = "a", t = "aa"
Output: ""
Explanation: Both 'a's from t must be included in the window.
Since the largest window of s only has one 'a', return empty string.


Solution:

1. Initialize two pointers, `left` and `right`, to track the window boundaries. Set them both to 0 initially.

2. Create two frequency maps, `targetMap` and `windowMap`, to track the character frequencies of the target string `t` and the current window in string `s`, respectively. Initially, both maps should be empty.

3. Populate the `targetMap` by iterating through the characters of string `t`. For each character, update its frequency in the map.

4. Initialize variables to track the minimum window length (`minWindowLength`), the starting index of the minimum window (`minWindowStart`), and a counter to keep track of the characters in `t` that have been matched in the current window (`matchedCount`). Set the `matchedCount` to 0 initially.

5. Start iterating through the string `s` using the `right` pointer:
   - For each character encountered, update its frequency in the `windowMap`.
   - If the character is present in the `targetMap` and its frequency in the `windowMap` is less than or equal to its frequency in the `targetMap`, increment the `matchedCount` by 1.

6. Check if all characters in `t` have been matched in the current window:
   - If the `matchedCount` is equal to the length of the target string `t`, it means all characters in `t` have been matched. In this case, we have found a valid window.
   - Update the minimum window length and the starting index of the minimum window if necessary.

7. Shrink the window by moving the `left` pointer:
   - While the `left` pointer can be moved and the current window still contains all characters from `t`, update the `windowMap` and `matchedCount` accordingly.
   - Check if the updated window is still valid (contains all characters from `t`).
   - If the updated window is still valid, update the minimum window length and the starting index of the minimum window if necessary.

8. Repeat steps 5 to 7 until the `right` pointer reaches the end of the string `s`.

9. After the loop, check if a valid window was found. If so, return the substring of `s` that corresponds to the minimum window length, starting from the `minWindowStart` index. Otherwise, return an empty string.

Code:

```java
public String minWindow(String s, String t) {
    HashMap<Character, Integer> targetMap = new HashMap<>(); // Frequency map for target string t
    HashMap<Character, Integer> windowMap = new HashMap<>(); // Frequency map for current window in s

    // Populate the targetMap with character frequencies from string t
    for (char ch : t.toCharArray()) {
        targetMap.put(ch, targetMap.getOrDefault(ch, 0) + 1);
    }

    int left = 0;                  // Left pointer of the window
    int right = 0;                 // Right pointer of the window
    int minWindowStart = 0;        // Starting index of the minimum window
    int minWindowLength = Integer.MAX_VALUE; // Minimum window length
    int matchedCount = 0;          // Counter to track matched characters

    // Iterate through the string s using the right pointer
    while (right < s.length()) {
        char rightChar = s.charAt(right);
        windowMap.put(rightChar, windowMap.getOrDefault(rightChar, 0) + 1); // Update the frequency of the character in the window map

        // If the current character is present in targetMap and its frequency in the window map is <= its frequency in targetMap
        if (targetMap.containsKey(rightChar) && windowMap.get(rightChar) <= targetMap.get(rightChar)) {
            matchedCount++; // Increment matchedCount as a character from t is matched
        }

        // Check if all characters from t have been matched in the current window
        while (matchedCount == t.length()) {
            // Update the minimum window length and starting index if necessary
            if (right - left + 1 < minWindowLength) {
                minWindowLength = right - left + 1;
                minWindowStart = left;
            }

            // Shrink the window from the left side
            char leftChar = s.charAt(left);
            windowMap.put(leftChar, windowMap.get(leftChar) - 1); // Update the frequency of the character in the window map

            // If the current character was one of the characters from t, decrement the matchedCount
            if (targetMap.containsKey(leftChar) && windowMap.get(leftChar) < targetMap.get(leftChar)) {
                matchedCount--;
            }

            left++; // Move the left pointer to shrink the window
        }

        right++; // Move the right pointer to expand the window
    }

    // Check if a valid window was found
    if (minWindowLength != Integer.MAX_VALUE) {
        return s.substring(minWindowStart, minWindowStart + minWindowLength);
    } else {
        return "";
    }
}
```

Time and Space Complexity :

The time complexity of this solution is O(n), where n is the length of the string `s`. The two pointers, `left` and `right`, 
traverse the string `s` only once. Additionally, the frequency maps and comparisons have constant time complexity since the 
number of characters is limited (128 ASCII characters). Therefore, the overall time complexity is linear, meeting the complexity requirement of O(n).

-----------------------------------------------------
4. Fruit Into Baskets (medium) - LeetCode #904

You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array fruits where fruits[i] is the type of fruit the ith tree produces.

You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:

You only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.
Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.
Once you reach a tree with fruit that cannot fit in your baskets, you must stop.
Given the integer array fruits, return the maximum number of fruits you can pick.



Example 1:

Input: fruits = [1,2,1]
Output: 3
Explanation: We can pick from all 3 trees.
Example 2:

Input: fruits = [0,1,2,2]
Output: 3
Explanation: We can pick from trees [1,2,2].
If we had started at the first tree, we would only pick from trees [0,1].
Example 3:

Input: fruits = [1,2,3,2,2]
Output: 4
Explanation: We can pick from trees [2,3,2,2].
If we had started at the first tree, we would only pick from trees [1,2].



brute force :

The brute force solution for the Fruit Into Baskets problem involves trying all possible combinations 
of two fruit types and counting the maximum number of fruits we can pick. Here's the basic outline of the brute force approach:

Initialize a variable maxFruits to store the maximum number of fruits we can pick.

Start a nested loop to iterate over all possible starting points for the two fruit types. The outer loop will 
consider the starting point of the first fruit type, and the inner loop will consider the starting point of the second fruit type.

For each combination of starting points, iterate through the array and pick fruits until we encounter a third 
fruit type (different from the two starting types). Count the number of fruits we picked during this iteration.

Update the maxFruits variable with the maximum number of fruits found during the iterations.

Continue the nested loops until all possible combinations are tried.

Finally, return the maxFruits value as the result.

The time complexity of this brute force solution is O(n^3), where n is the length of the input array. 
This is because we are trying all possible combinations of two fruit types and iterating through the 
array for each combination. The overall solution is not efficient for large inputs and should be avoided in practice.
class Solution {
    public int totalFruit(int[] tree) {
        int n = tree.length;
        int maxFruits = 0;

        // Iterate through all possible starting points for the first fruit type
        for (int i = 0; i < n; i++) {
            // Iterate through all possible starting points for the second fruit type
            for (int j = i + 1; j < n; j++) {
                int firstFruit = tree[i];
                int secondFruit = tree[j];
                int count = 0;

                // Iterate through the array and count the number of fruits we can pick
                for (int k = 0; k < n; k++) {
                    if (tree[k] == firstFruit || tree[k] == secondFruit) {
                        count++;
                    } else {
                        break; // Encounter a third fruit type, stop counting
                    }
                }

                // Update the maximum number of fruits
                maxFruits = Math.max(maxFruits, count);
            }
        }

        return maxFruits;
    }
}

optimized :

Initialize two pointers, left and right, to mark the start and end of the current window, respectively. Also, 
initialize a maxFruits variable to store the maximum number of fruits we can pick.

Start iterating through the array with the right pointer. For each element tree[right], do the following:

a. Add the current fruit type to a frequency map. The frequency map will keep track of the count of each fruit 
type in the current window.

b. If the size of the frequency map becomes larger than 2 (i.e., there are more than two types of fruits in the window), 
we need to shrink the window from the left side until there are at most two types of fruits.

c. Update the maxFruits variable with the maximum number of fruits found so far (i.e., the length of the current window).

Continue the iteration until the right pointer reaches the end of the array.

Finally, return the maxFruits value as the result.

The sliding window approach helps us avoid unnecessary iterations and significantly improves the efficiency of the solution. 
The frequency map allows us to quickly determine the number of fruit types in the current window and decide when to 
shrink or expand the window efficiently.

Here's the optimized solution in Java:


class Solution {
    public int totalFruit(int[] tree) {
        int n = tree.length;
        int maxFruits = 0;
        int left = 0;
        HashMap<Integer, Integer> fruitFrequency = new HashMap<>();

        for (int right = 0; right < n; right++) {
            // Add the current fruit type to the frequency map
            fruitFrequency.put(tree[right], fruitFrequency.getOrDefault(tree[right], 0) + 1);

            // Shrink the window from the left side if there are more than 2 fruit types
            while (fruitFrequency.size() > 2) {
                fruitFrequency.put(tree[left], fruitFrequency.get(tree[left]) - 1);
                if (fruitFrequency.get(tree[left]) == 0) {
                    fruitFrequency.remove(tree[left]);
                }
                left++;
            }

            // Update the maximum number of fruits
            maxFruits = Math.max(maxFruits, right - left + 1);
        }

        return maxFruits;
    }
}

The time complexity of the optimized solution is O(n), where n is the length of the input array. This is because 
we iterate through the array once, and each element is processed by both the left and right pointers exactly once. 
The overall solution is much more efficient than the brute force approach and is suitable for large inputs.

-------------------------------------------------------
5. Longest Repeating Character Replacement (medium) - LeetCode #424

You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.

Return the length of the longest substring containing the same letter you can get after performing the above operations.

 

Example 1:

Input: s = "ABAB", k = 2
Output: 4
Explanation: Replace the two 'A's with two 'B's or vice versa.
Example 2:

Input: s = "AABABBA", k = 1
Output: 4
Explanation: Replace the one 'A' in the middle with 'B' and form "AABBBBA".
The substring "BBBB" has the longest repeating letters, which is 4.
There may exists other ways to achive this answer too.


Brute Force Approach:

In the brute force approach, we consider all possible substrings and calculate the maximum length of the substring 
that can be obtained by replacing characters to make all characters the same. We try all possible replacement counts 
(from 0 to the length of the substring) for each character in the substring.

Here's the basic outline of the brute force approach:

Initialize a variable maxLength to store the maximum length of the substring.

Start two nested loops to consider all possible substrings. The outer loop will represent the starting index of the 
substring, and the inner loop will represent the ending index of the substring.

For each substring, create a frequency map to count the occurrences of each character.

Start another loop to try all possible replacement counts (from 0 to the length of the substring) for each character 
in the substring.

Update the maxLength variable with the maximum length of the substring obtained after replacements.

Continue the nested loops until all possible substrings and replacement counts are considered.

Finally, return the maxLength value as the result.

The time complexity of this brute force approach is O(n^3), where n is the length of the input string. 
This is because we consider all possible substrings, and for each substring, we may need to try all possible 
replacement counts for each character in the substring.

class Solution {
    public int characterReplacement(String s, int k) {
        int n = s.length();
        int maxLength = 0;

        // Iterate through all possible substrings
        for (int left = 0; left < n; left++) {
            for (int right = left; right < n; right++) {
                String substring = s.substring(left, right + 1);
                int maxCount = getMaxCharacterCount(substring);

                // Calculate the number of characters that need replacement
                int replacementsNeeded = substring.length() - maxCount;

                // Check if the replacements needed are less than or equal to k
                if (replacementsNeeded <= k) {
                    // Update the maximum length of the substring found so far
                    maxLength = Math.max(maxLength, substring.length());
                }
            }
        }

        return maxLength;
    }

    private int getMaxCharacterCount(String s) {
        int maxCount = 0;
        HashMap<Character, Integer> charFrequency = new HashMap<>();

        for (char ch : s.toCharArray()) {
            charFrequency.put(ch, charFrequency.getOrDefault(ch, 0) + 1);
            maxCount = Math.max(maxCount, charFrequency.get(ch));
        }

        return maxCount;
    }
}


Optimized Approach:

The optimized solution for the Longest Repeating Character Replacement problem uses the sliding window 
approach to efficiently find the maximum length of the substring with at most k replacements. 

Here's how the optimized solution works:

Initialize two pointers, left and right, to mark the start and end of the current window, respectively.

Initialize a maxCount variable to store the maximum count of any character in the current window.

Start iterating through the string with the right pointer. For each character s[right], do the following:

a. Increment the count of the current character in the frequency map.

b. Update the maxCount with the maximum frequency of any character in the frequency map.

c. If the size of the current window (i.e., the length of the substring from left to right) minus maxCount is greater 
than k, then it means we have more than k characters that need replacement. In this case, we need to shrink the window 
from the left side.

d. Update the maximum length of the substring found so far (i.e., the length of the current window).

Continue the iteration until the right pointer reaches the end of the string.

Finally, return the maximum length of the substring found as the result.

The sliding window approach helps us avoid unnecessary iterations and significantly improves the efficiency of 
the solution. The frequency map allows us to quickly determine the maximum count of any character in the current 
window and decide when to shrink or expand the window efficiently.

class Solution {
    public int characterReplacement(String s, int k) {
        int n = s.length();
        int maxLength = 0;
        int maxCount = 0;
        int left = 0;
        HashMap<Character, Integer> charFrequency = new HashMap<>();

        for (int right = 0; right < n; right++) {
            char rightChar = s.charAt(right);
            charFrequency.put(rightChar, charFrequency.getOrDefault(rightChar, 0) + 1);
            maxCount = Math.max(maxCount, charFrequency.get(rightChar));

            // If the number of characters that need replacement is greater than k, shrink the window
            while (right - left + 1 - maxCount > k) {
                char leftChar = s.charAt(left);
                charFrequency.put(leftChar, charFrequency.get(leftChar) - 1);
                left++;
                // Update maxCount after removing a character from the window
                maxCount = charFrequency.values().stream().max(Integer::compare).orElse(0);
            }

            // Update the maximum length of the substring found so far
            maxLength = Math.max(maxLength, right - left + 1);
        }

        return maxLength;
    }
}


-------------------------------------------------------
6. Permutation in String (medium) - LeetCode #567


Brute force
In the brute force approach, we generate all possible permutations of the first string s1 and check if any of those permutations is a substring of the second string s2. We can use backtracking to generate all permutations of s1 and then check if each permutation is a substring of s2.

Here's the basic outline of the brute force approach:

Generate all permutations of the first string s1.

For each permutation of s1, check if it is a substring of s2. If we find a match, return true.

If we don't find any match after checking all permutations, return false.

The time complexity of this brute force approach is O((n+m)!), where n is the length of s1, and m is the length of s2. This is because we generate all permutations of s1, which takes (n!) time, and then for each permutation, we check if it is a substring of s2, which takes O(m) time.


class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int n = s1.length();
        int m = s2.length();
        if (n > m) {
            return false;
        }

        // Generate all permutations of s1
        List<String> permutations = new ArrayList<>();
        generatePermutations(s1.toCharArray(), 0, n - 1, permutations);

        // Check if any permutation is a substring of s2
        for (String permutation : permutations) {
            if (s2.contains(permutation)) {
                return true;
            }
        }

        return false;
    }

    private void generatePermutations(char[] chars, int left, int right, List<String> permutations) {
        if (left == right) {
            permutations.add(new String(chars));
        } else {
            for (int i = left; i <= right; i++) {
                swap(chars, left, i);
                generatePermutations(chars, left + 1, right, permutations);
                swap(chars, left, i); // Backtrack
            }
        }
    }

    private void swap(char[] chars, int i, int j) {
        char temp = chars[i];
        chars[i] = chars[j];
        chars[j] = temp;
    }
}


-------------------------------------------------------
7. Longest Substring Without Repeating Characters (medium) - LeetCode #3

Given a string s, find the length of the longest substring without repeating characters.

Example 1:

Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
Example 2:

Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
Example 3:

Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.

In the brute force approach, we consider all possible substrings of the input string s and check if each substring has all unique characters. We keep track of the maximum length of such substrings and return that as the result.

Algorithm:

Initialize a variable maxLength to store the maximum length of the substring without repeating characters. Set it to 0 initially.

Iterate through all possible starting positions of the substring using an outer loop.

For each starting position, use an inner loop to iterate through all possible ending positions of the substring.

Within the inner loop, check if the current substring from the starting to ending positions has all unique characters. If it does, update maxLength to the maximum of its current value and the length of the current substring.

Continue the inner loop until all possible ending positions have been considered for the given starting position.

Continue the outer loop until all possible starting positions have been considered.

After both loops, the maxLength variable will hold the length of the longest substring without repeating characters.

Return maxLength as the result.

Complexity Analysis:

The time complexity of the brute force approach is O(n^3) because we have two nested loops for iterating through all possible substrings, and each loop takes O(n) time.

The space complexity is O(1) as we are not using any additional data structures.

class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        int maxLength = 0;

        for (int start = 0; start < n; start++) {
            for (int end = start + 1; end <= n; end++) {
                if (isUnique(s, start, end)) {
                    maxLength = Math.max(maxLength, end - start);
                }
            }
        }

        return maxLength;
    }

    private boolean isUnique(String s, int start, int end) {
        Set<Character> charSet = new HashSet<>();
        for (int i = start; i < end; i++) {
            char ch = s.charAt(i);
            if (charSet.contains(ch)) {
                return false;
            }
            charSet.add(ch);
        }
        return true;
    }
}


Optimized : 
Algorithm:

Initialize a HashSet called set to keep track of characters in the current window.

Initialize three variables i, j, and max to represent the current window's start position, end position, and the maximum length of the substring without repeating characters. Set i = j = max = 0 initially.

Start iterating through the string s using the i pointer:

Check if the character at the i pointer is not already present in the set.

If it is not present, it means adding this character to the current window will not result in any repeating characters. So, we can expand the window by moving the i pointer one step to the right and add the character to the set.

Update the max variable with the maximum of its current value and the size of the set. This represents the length of the current substring without repeating characters.

Move the i pointer one step to the right.

If the character at the i pointer is already present in the set, it means we have encountered a repeating character. In this case, we need to shrink the window from the left side to eliminate the repeating character.

Remove the character at the j pointer from the set.

Move the j pointer one step to the right.

Continue the iteration until the i pointer reaches the end of the string s.

After the loop, the max variable will hold the length of the longest substring without repeating characters.

Return max as the result.

Explanation:

The given solution uses a sliding window approach to efficiently find the length of the longest substring without repeating characters. The HashSet called set is used to maintain the characters in the current window. The i pointer moves to expand the window, and the j pointer moves to shrink the window when a repeating character is encountered.

As we iterate through the string s, the set keeps track of the unique characters in the current window. When we encounter a repeating character, we remove characters from the set starting from the left side of the window (pointed by j) until the repeating character is no longer present. This process ensures that we have a new window with no repeating characters.

While updating the window, we keep track of the max variable by calculating the length of the current window (which is i - j) and updating max if needed. The max variable will eventually hold the length of the longest substring without repeating characters.

Complexity Analysis:

The time complexity of the given solution is O(n), where n is the length of the input string s. This is because we traverse the string once from left to right.

The space complexity is O(k), where k is the size of the character set (in this case, the number of unique characters in the input string). Since the character set is limited to ASCII characters (256 characters), the space complexity is considered constant.

public int lengthOfLongestSubstring(String s) {
    HashSet<Character> set = new HashSet<>();
    int i=0, j=0, max=0;
    while(i<s.length())
    {
        if(!set.contains(s.charAt(i)))
        {
           set.add(s.charAt(i));
           max= Math.max(max, set.size());
           i++;
        }
        else
        {
           set.remove(s.charAt(j));
           j++;
        }
    }
    return max;
}


-------------------------------------------------------
8. Find All Anagrams in a String (medium) - LeetCode #438

Given two strings s and p, return an array of all the start indices of p's anagrams in s. You may return the answer in any order.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

 

Example 1:

Input: s = "cbaebabacd", p = "abc"
Output: [0,6]
Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".
Example 2:

Input: s = "abab", p = "ab"
Output: [0,1,2]
Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".

Brute force : 

In the brute force approach, we consider all possible substrings of the string s with the same length as the string p, and for each substring, we check if it is an anagram of p. We keep track of the start indices of all such anagrams and return them as the result.

Algorithm:

Initialize an empty list called anagramIndices to store the start indices of the anagrams of p in s.

Calculate the lengths of the strings s and p and store them in variables n and m, respectively.

Iterate through all possible starting positions of the substring in s using an outer loop with the pointer i ranging from 0 to n - m.

For each starting position i, extract the substring of length m starting from i in s. This substring represents the current window.

Check if the current window (substring) is an anagram of p by comparing the character frequencies of both strings.

To do this, initialize two arrays charFrequencyS and charFrequencyP of size 26 (to represent each lowercase English alphabet).

For the current window in s, increment the count of each character in charFrequencyS.

For the string p, increment the count of each character in charFrequencyP.

Check if charFrequencyS is equal to charFrequencyP. If they are equal, it means the current window is an anagram of p, so add the current start index i to the anagramIndices list.

After the loop, return the anagramIndices list as the result.

Complexity Analysis:

The time complexity of the brute force approach is O((n-m) * m), where n is the length of s and m is the length of p. The outer loop runs (n-m) times, and for each iteration, we compare m characters of both strings.

The space complexity is O(1) since we are using fixed-size arrays to store character frequencies.

Brute Force Implementation:
import java.util.ArrayList;
import java.util.List;

class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> anagramIndices = new ArrayList<>();
        int n = s.length();
        int m = p.length();

        for (int i = 0; i <= n - m; i++) {
            if (isAnagram(s.substring(i, i + m), p)) {
                anagramIndices.add(i);
            }
        }

        return anagramIndices;
    }

    private boolean isAnagram(String s, String p) {
        int[] charFrequencyS = new int[26];
        int[] charFrequencyP = new int[26];

        for (int i = 0; i < s.length(); i++) {
            charFrequencyS[s.charAt(i) - 'a']++;
            charFrequencyP[p.charAt(i) - 'a']++;
        }

        for (int i = 0; i < 26; i++) {
            if (charFrequencyS[i] != charFrequencyP[i]) {
                return false;
            }
        }

        return true;
    }
}




Optimized:
Sliding Window with Frequency Map

Algorithm:

Initialize an empty list called anagramIndices to store the start indices of the anagrams of p in s.

Calculate the lengths of the strings s and p and store them in variables n and m, respectively.

Create two integer arrays charFrequencyS and charFrequencyP of size 26 (to represent each lowercase English alphabet) to keep track of character frequencies in s and p, respectively.

Populate charFrequencyP with the character frequencies of string p.

Start iterating through the string s using the right pointer:

Increment the frequency of the character at the right pointer in charFrequencyS.

If the current window (substring) size becomes greater than m, we need to shrink the window from the left side. Decrement the frequency of the character at the left pointer in charFrequencyS and move the left pointer one step to the right.

Check if the charFrequencyS is equal to charFrequencyP. If they are equal, it means the current window is an anagram of p, so add the current start index left to the anagramIndices list.

Move the right pointer one step to the right to expand the window.

After the loop, return the anagramIndices list as the result.

Complexity Analysis:

The time complexity of the optimized approach is O(n), where n is the length of the input string s. This is because we traverse the string once from left to right, and each character is processed exactly twice (once by the left pointer and once by the right pointer).

The space complexity is O(1) since we are using fixed-size arrays to store character frequencies.

Optimized Implementation:


class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> anagramIndices = new ArrayList<>();
        int n = s.length();
        int m = p.length();

        int[] charFrequencyS = new int[26];
        int[] charFrequencyP = new int[26];

        // Populate charFrequencyP with character frequencies of string p
        for (char ch : p.toCharArray()) {
            charFrequencyP[ch - 'a']++;
        }

        int left = 0;
        for (int right = 0; right < n; right++) {
            char rightChar = s.charAt(right);
            charFrequencyS[rightChar - 'a']++;

            // Shrink the window from the left side if its size becomes greater than m
            if (right - left + 1 > m) {
                char leftChar = s.charAt(left);
                charFrequencyS[leftChar - 'a']--;
                left++;
            }

            // Check if the current window is an anagram
            if (isAnagram(charFrequencyS, charFrequencyP)) {
                anagramIndices.add(left);
            }
        }

        return anagramIndices;
    }

    private boolean isAnagram(int[] charFrequencyS, int[] charFrequencyP) {
        for (int i = 0; i < 26; i++) {
            if (charFrequencyS[i] != charFrequencyP[i]) {
                return false;
            }
        }
        return true;
    }
}

-------------------------------------------------------
9. Subarrays with K Different Integers (hard) - LeetCode #992

-------------------------------------------------------
10. Minimum Size Subarray Sum (medium) - LeetCode #209

Given an array of positive integers nums and a positive integer target, return the minimal length of a 
subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.

Example 1:

Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.
Example 2:

Input: target = 4, nums = [1,4,4]
Output: 1
Example 3:

Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0

Algorithm:

The given solution uses a sliding window approach to find the minimum size subarray whose sum is greater than or equal to the given target. The idea is to keep a window whose sum is greater than or equal to the target and continuously shrink the window from the left side until the sum becomes less than the target. During this process, we keep track of the minimum window size encountered so far.

Explanation:

Initialize two pointers start and end to represent the window. Set start and end to 0 initially.

Initialize a variable sum to keep track of the sum of elements in the current window. Set sum to 0 initially.

Initialize a variable min to store the minimum size of the subarray whose sum is greater than or equal to the target. Set min to Integer.MAX_VALUE initially.

Iterate through the array nums using the start pointer:

Add the value at the start pointer to the current sum.

Check if the sum is greater than or equal to the target.

If sum is greater than or equal to the target, it means the current window's sum satisfies the condition. So, we update the min variable with the minimum of its current value and the window size (start - end + 1).

Shrink the window from the left side by moving the end pointer one step to the right and subtracting the value at the end pointer from the current sum.

Continue the inner loop until the sum becomes less than the target.

After the loop, return the min variable as the result. If min is still Integer.MAX_VALUE, it means no subarray satisfies the condition, so return 0.

Time Complexity:

The time complexity of the given solution is O(n), where n is the length of the input array nums. This is because both start and end pointers traverse the array from left to right exactly once.

Space Complexity:

The space complexity is O(1) because the solution uses a constant amount of extra space to store the variables start, end, sum, and min.

Implementation:

class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int start = 0, end = 0;
        int sum = 0;
        int min = Integer.MAX_VALUE;
        
        for (start = 0; start < nums.length; start++) {
            sum += nums[start];
            while (sum >= target) {
                min = Math.min(min, (start - end + 1));
                sum -= nums[end++];
            }
        }
        
        return min == Integer.MAX_VALUE ? 0 : min;
    }
}

-------------------------------------------------------
11. Shortest Subarray with Sum at Least K (hard) - LeetCode #862

-------------------------------------------------------
12. Replace the Substring for Balanced String (medium) - LeetCode #1234

You are given a string s of length n containing only four kinds of characters: 'Q', 'W', 'E', and 'R'.

A string is said to be balanced if each of its characters appears n / 4 times where n is the length of the string.

Return the minimum length of the substring that can be replaced with any other string of the same length to make s balanced. 
If s is already balanced, return 0.

Example 1:

Input: s = "QWER"
Output: 0
Explanation: s is already balanced.
Example 2:

Input: s = "QQWE"
Output: 1
Explanation: We need to replace a 'Q' to 'R', so that "RQWE" (or "QRWE") is balanced.
Example 3:

Input: s = "QQQW"
Output: 2
Explanation: We can replace the first "QQ" to "ER". 


Approach :
Calculate the expected count count of each character in a balanced string. Since there are four kinds of characters ('Q', 'W', 'E', and 'R'), the expected count for each character is n / 4, where n is the length of the string s.

Create a HashMap charFrequency to store the character frequencies in the string. Loop through each character in the string s and populate the HashMap, incrementing the count for each character.

Initialize two pointers, left and right, to represent the window. These pointers will help us track the substring that needs to be replaced.

Start traversing the string from left to right using the right pointer. For each character at the right pointer, decrement its count in the charFrequency HashMap.

Move the right pointer to the right to expand the window.

Enter a loop to shrink the window from the left side. This loop runs as long as the window is balanced (i.e., the character frequencies are within the expected counts).

Inside the loop, calculate the length of the current window (right - left) and update minLength with the minimum of its current value and the length of the current window.

Increment the count of the character at the left pointer in the charFrequency HashMap, effectively removing it from the window.

Move the left pointer to the right to shrink the window further.

Return the minLength as the result.

The isBalanced helper function checks if the current window is balanced. It iterates through the values (character frequencies) of the charFrequency HashMap and returns false if any character's count exceeds the expected count.

Code :

class Solution {
    public int balancedString(String s) {
        int n = s.length();
        int count = n / 4;
        int minLength = n;
        
        // Calculate the expected count of each character in a balanced string
        HashMap<Character, Integer> charFrequency = new HashMap<>();
        for (char ch : s.toCharArray()) {
            charFrequency.put(ch, charFrequency.getOrDefault(ch, 0) + 1);
        }
        
        // Initialize pointers to represent the window
        int left = 0;
        int right = 0;
        
        // Traverse the string to find the minimum length of the substring to replace
        while (right < n) {
            char rightChar = s.charAt(right);
            charFrequency.put(rightChar, charFrequency.get(rightChar) - 1);
            right++;
            
            // Shrink the window from the left side if it is balanced
            while (left < n && isBalanced(charFrequency, count)) {
                minLength = Math.min(minLength, right - left);
                char leftChar = s.charAt(left);
                charFrequency.put(leftChar, charFrequency.get(leftChar) + 1);
                left++;
            }
        }
        
        return minLength;
    }
    
    // Helper function to check if the current window is balanced
    private boolean isBalanced(HashMap<Character, Integer> charFrequency, int count) {
        for (int freq : charFrequency.values()) {
            if (freq > count) {
                return false;
            }
        }
        return true;
    }
}

TC and SC :
TC = O(N) and SC = O(1)

-------------------------------------------------------
14. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit (medium) - LeetCode #1438


Given an array of integers nums and an integer limit, return the size of the longest non-empty subarray such that the absolute difference between any two elements of this subarray is less than or equal to limit.

 

Example 1:

Input: nums = [8,2,4,7], limit = 4
Output: 2 
Explanation: All subarrays are: 
[8] with maximum absolute diff |8-8| = 0 <= 4.
[8,2] with maximum absolute diff |8-2| = 6 > 4. 
[8,2,4] with maximum absolute diff |8-2| = 6 > 4.
[8,2,4,7] with maximum absolute diff |8-2| = 6 > 4.
[2] with maximum absolute diff |2-2| = 0 <= 4.
[2,4] with maximum absolute diff |2-4| = 2 <= 4.
[2,4,7] with maximum absolute diff |2-7| = 5 > 4.
[4] with maximum absolute diff |4-4| = 0 <= 4.
[4,7] with maximum absolute diff |4-7| = 3 <= 4.
[7] with maximum absolute diff |7-7| = 0 <= 4. 
Therefore, the size of the longest subarray is 2.
Example 2:

Input: nums = [10,1,2,4,7,2], limit = 5
Output: 4 
Explanation: The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 <= 5.
Example 3:

Input: nums = [4,2,2,2,4,4,2,2], limit = 0
Output: 3


Explanation:

We use a TreeMap freqMap to keep track of the frequencies of elements in the current window. The TreeMap is sorted based on the elements' natural order, allowing us to efficiently access the minimum and maximum elements within the window.

The left and right pointers are used to represent the window boundaries, just like in the previous solutions.

We traverse the array from left to right using the right pointer and perform the following steps:

For each element at the right pointer, add it to the freqMap and update its frequency count.

Calculate the absolute difference between the maximum and minimum elements in the current window (freqMap.lastKey() - freqMap.firstKey()).

While the absolute difference is greater than the limit, it means the current window is invalid, and we need to adjust the left pointer and update the frequency map.

We decrement the frequency count of the element at the left pointer and remove it from the freqMap if its frequency becomes 0. We increment the left pointer until the absolute difference becomes less than or equal to the limit.

After adjusting the window, we update the maxWindowSize with the maximum of its current value and the size of the current window (right - left + 1).

After the loop, we return the maxWindowSize as the result.

Time Complexity:
The time complexity of this approach is O(n * log(n)), where n is the size of the input array nums. Both the left and right pointers traverse the array exactly once. For each right pointer, we perform insertion and deletion operations on the TreeMap, which take O(log(n)) time. In the worst case, the TreeMap can have n distinct elements, resulting in an overall time complexity of O(n * log(n)).

Space Complexity:
The space complexity is O(n), where n is the size of the input array nums. In the worst case, the TreeMap can have n distinct elements.


Code:
import java.util.TreeMap;

class Solution {
    public int longestSubarray(int[] nums, int limit) {
        TreeMap<Integer, Integer> freqMap = new TreeMap<>();
        int left = 0;
        int maxWindowSize = 0;

        for (int right = 0; right < nums.length; right++) {
            freqMap.put(nums[right], freqMap.getOrDefault(nums[right], 0) + 1);

            // While the absolute difference between the minimum and maximum elements in the current window
            // is greater than the limit, adjust the left pointer and update the frequency map.
            while (freqMap.lastKey() - freqMap.firstKey() > limit) {
                freqMap.put(nums[left], freqMap.get(nums[left]) - 1);
                if (freqMap.get(nums[left]) == 0) {
                    freqMap.remove(nums[left]);
                }
                left++;
            }

            // Update the maxWindowSize
            maxWindowSize = Math.max(maxWindowSize, right - left + 1);
        }

        return maxWindowSize;
    }
}


-------------------------------------------------------
15. Max Consecutive Ones III (medium) - LeetCode #1004

Given a binary array nums and an integer k, return the maximum number of consecutive 1's in the array if you can flip at most k 0's.

Example 1:

Input: nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2
Output: 6
Explanation: [1,1,1,0,0,1,1,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.
Example 2:

Input: nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], k = 3
Output: 10
Explanation: [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
Bolded numbers were flipped from 0 to 1. The longest subarray is underlined.

BRUTE FORCE:

Initialize a variable maxConsecutiveOnes to keep track of the maximum length of consecutive 1's found so far.
Use a nested loop to consider all possible subarrays with at most k flips.
For each subarray, maintain two variables flipsLeft and consecutiveOnes. flipsLeft represents the number of flips available, and consecutiveOnes counts the consecutive 1's in the subarray.
If the current element is 1, increment consecutiveOnes.
If the current element is 0 and there are flips available (flipsLeft > 0), we can consider flipping it to 1. Increment consecutiveOnes and decrement flipsLeft.
If the current element is 0, and no more flips are available (flipsLeft == 0), we cannot consider flipping it, so we break the inner loop.
Update maxConsecutiveOnes with the maximum of its current value and consecutiveOnes.
After both loops, return the maxConsecutiveOnes as the result.
Time Complexity:
The time complexity of the brute force approach is O(n^2), where n is the length of the input array nums. The nested loops consider all possible subarrays, leading to a quadratic time complexity.

Space Complexity:
The space complexity is O(1) since we are using only a few variables to keep track of the state, and we are not using any additional data structures with a size dependent on the input.

class Solution {
    public int longestOnes(int[] nums, int k) {
        int maxConsecutiveOnes = 0;

        for (int i = 0; i < nums.length; i++) {
            int flipsLeft = k;
            int consecutiveOnes = 0;

            for (int j = i; j < nums.length; j++) {
                if (nums[j] == 1) {
                    consecutiveOnes++;
                } else {
                    if (flipsLeft > 0) {
                        consecutiveOnes++;
                        flipsLeft--;
                    } else {
                        break;
                    }
                }

                maxConsecutiveOnes = Math.max(maxConsecutiveOnes, consecutiveOnes);
            }
        }

        return maxConsecutiveOnes;
    }
}


OPTIMIZED SLIDING WINDOW:
Algorithm:

Initialize left and right pointers to represent the window boundaries.
Initialize a variable maxConsecutiveOnes to keep track of the maximum length of consecutive 1's found so far.
Initialize a variable flipsLeft to represent the number of flips available.
Traverse the array using the right pointer.
If the current element is 0, decrement flipsLeft.
While flipsLeft becomes negative (i.e., the number of flips used exceeds the allowed k flips), we need to move the left pointer to shrink the window. If the element at the left pointer is 0, increment flipsLeft to free up a flip. Move the left pointer to the right to shrink the window.
Update maxConsecutiveOnes with the maximum of its current value and the size of the current window (right - left + 1).
After the loop, return the maxConsecutiveOnes as the result.
Time Complexity:
The time complexity of the optimized approach is O(n), where n is the length of the input array nums. Both the left and right pointers traverse the array exactly once. The while loop inside the for loop performs constant-time operations, and the overall time complexity is linear.

Space Complexity:
The space complexity is O(1) since we are using only a few variables to keep track of the state, and we are not using any additional data structures with a size dependent on the input.

class Solution {
    public int longestOnes(int[] nums, int k) {
        int left = 0;
        int maxConsecutiveOnes = 0;
        int flipsLeft = k;

        for (int right = 0; right < nums.length; right++) {
            if (nums[right] == 0) {
                flipsLeft--;
            }

            while (flipsLeft < 0) {
                if (nums[left] == 0) {
                    flipsLeft++;
                }
                left++;
            }

            maxConsecutiveOnes = Math.max(maxConsecutiveOnes, right - left + 1);
        }

        return maxConsecutiveOnes;
    }
}

-------------------------------------------------------------
-------------------------------------------------------------
##Heap


1. Kth Largest Element in an Array (Question #215) [Medium]:
Given an integer array nums and an integer k, return the kth largest element in the array.

Note that it is the kth largest element in the sorted order, not the kth distinct element.

Can you solve it without sorting?


Example 1:

Input: nums = [3,2,1,5,6,4], k = 2
Output: 5
Example 2:

Input: nums = [3,2,3,1,2,4,5,5,6], k = 4
Output: 4

Approach:
The min heap will keep track of the k largest elements seen so far, with the smallest element at the top (root) of the heap. When the heap contains k elements, the smallest element will be the kth largest element among all elements seen so far.

1. We initialize an empty priority queue (`queue`) which acts as a min-heap.

2. We iterate through each element `i` in the input `nums` array.

3. If the priority queue (`queue`) has already k elements, we check if the smallest element (top element) in the min heap (`queue.peek()`) is less than the current element `i`. If it is, it means `i` is larger than the smallest element, so we remove the smallest element from the min heap and add the current element `i` to the heap. This ensures that we keep track of the k largest elements in the min heap at all times.

4. If the priority queue has less than k elements, we simply add the current element `i` to the min heap.

5. After processing all elements in the input array, the top element of the min heap (`queue.poll()`) will be the kth largest element.

Time Complexity (TC):
The time complexity of this algorithm is O(N log K), where N is the number of elements in the input array and K is the value of `k`. For each element, we perform heap operations (`offer()` and `poll()`), which take O(log K) time in the worst case. Since we have N elements, the overall time complexity is O(N log K).

Space Complexity (SC):
The space complexity of this algorithm is O(K) because we use a min heap (PriorityQueue) to store at most k elements at any given time.

```java
public int findKthLargest(int[] nums, int k) {
    PriorityQueue<Integer> queue = new PriorityQueue<>();

    for (int i : nums) {
        if (queue.size() == k) {
            // If the priority queue (min heap) has already k elements, compare the smallest element with the current element i.
            // If i is greater than the smallest element (i.e., the top element of the min heap), remove the smallest element and add i to the heap.
            if (queue.peek() < i) {
                queue.poll(); // Remove the smallest element from the min heap.
                queue.offer(i); // Add the current element i to the min heap.
            }
        } else {
            queue.offer(i); // If the priority queue has less than k elements, simply add the current element i to the min heap.
        }
    }

    return queue.poll(); // After processing all elements, the top element of the min heap will be the kth largest element.
}
```


1. **Kth Largest Element in an Array**
   - LeetCode #215

2. **Merge k Sorted Lists**
   - LeetCode #23

3. **Top K Frequent Elements**
   - LeetCode #347

4. **Find Median from Data Stream**
   - LeetCode #295

5. **Kth Smallest Element in a BST**
   - LeetCode #230

6. **Sliding Window Maximum**
   - LeetCode #239

7. **Find K Pairs with Smallest Sums**
   - LeetCode #373

8. **Sort Characters By Frequency**
   - LeetCode #451

9. **Find K Closest Elements**
   - LeetCode #658

10. **Top K Frequent Words**
    - LeetCode #692

11. **Find Median from Data Stream**
    - LeetCode #295

12. **Last Stone Weight**
    - LeetCode #1046

13. **Find Kth Smallest Pair Distance**
    - LeetCode #719

14. **K Closest Points to Origin**
    - LeetCode #973

15. **Smallest Range Covering Elements from K Lists**
    - LeetCode #632

16. **Kth Largest Element in a Stream**
    - LeetCode #703

17. **Find the Kth Smallest Sum of a Matrix With Sorted Rows**
    - LeetCode #1439

18. **Find K Pairs with Smallest Sums**
    - LeetCode #373

19. **Find Kth Smallest Element in a Sorted Matrix**
    - LeetCode #378

20. **Find K Closest Elements**
    - LeetCode #658

--------------------------------------------------------------
--------------------------------------------------------------

##LinkedList

1. Reverse Linked List - LeetCode #206

Given the head of a singly linked list, reverse the list, and return the reversed list.

Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]

Initialize two pointers: prev and current.

prev is initialized to null since the last node's next pointer should be null after the reversal.
current is initialized to the head of the linked list, which is node 1 in this case.
Iterate through the linked list using a while loop until current becomes null.

In each iteration:

Store the next node of current in a temporary variable nextNode. For example, when current is 1, nextNode will be 2.
Reverse the current node's next pointer to point to the previous node (prev). For example, when current is 1, 
the next pointer of node 1 will be set to null.
Move prev to current and current to the next node (nextNode) to progress in the linked list. For example, after the first iteration, prev will be node 1 and current will be node 2.
After iterating through the entire linked list, the prev pointer will be pointing to the new head of the reversed linked list.

Return prev as the new head of the reversed linked list

Code:
public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode current = head;
    
    while (current != null) {
        ListNode nextNode = current.next;
        current.next = prev;
        prev = current;
        current = nextNode;
    }
    
    return prev;
}


public ListNode reverseList(ListNode head) {
    if (head == null || head.next == null) {
        // Base case: one node or empty list
        return head;
    }
    
    ListNode last = reverseList(head.next);
    // Reverse the links
    head.next.next = head;
    head.next = null;
    
    // 'last' is the new head of the reversed list
    return last;
}

--------------------------------------------------------------

2. Detect Cycle in a Linked List - LeetCode #141

The function takes the head of the linked list as input and returns a boolean value indicating whether the linked list has a cycle (true) or not (false).

The first step is to check if the linked list is empty or contains only one node. If the list is empty or has only one node, it cannot have a cycle, so we return false.

Next, we initialize two pointers: slow and fast. The slow pointer starts from the head, and the fast pointer starts from the next node of the head. This is because we will be comparing slow and fast in the loop, and starting fast from the next node avoids having slow and fast pointing to the same node initially.

Now, we enter a loop that continues until slow becomes equal to fast, which indicates the presence of a cycle. Inside the loop:

We first check if either fast or fast.next is null. If it is, this means that fast has reached the end of the linked list, and there is no cycle. In this case, we return false.
Otherwise, we move the fast pointer two steps ahead (fast = fast.next.next) and the slow pointer one step ahead (slow = slow.next).
If the loop exits, it means that slow is equal to fast, which indicates that the linked list has a cycle. In this case, we return true.

The "Floyd's Tortoise and Hare" algorithm is an efficient way to detect cycles in a linked list using two pointers moving at different speeds. It ensures that if there is a cycle, the fast pointer will eventually catch up to the slow pointer. If there is no cycle, the fast pointer will reach the end of the linked list, and the loop will exit before the slow pointer and fast pointer meet.

Code:
public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) {
        return false;
    }

    ListNode slow = head, fast = head.next;

    while (slow != fast) {
        if (fast == null || fast.next == null) {
            return false;
        }
        fast = fast.next.next;
        slow = slow.next;
    }

    return true;
}
--------------------------------------------------------------

3. Find the Middle of a Linked List - LeetCode #876

Given the head of a singly linked list, return the middle node of the linked list.

If there are two middle nodes, return the second middle node.

Input: head = [1,2,3,4,5]
Output: [3,4,5]
Explanation: The middle node of the list is node 3.

Input: head = [1,2,3,4,5,6]
Output: [4,5,6]
Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.

Explanation:

The function takes the head of the linked list as input and returns the middle node.

The first step is to check if the linked list is empty or contains only one node. If the list is empty or has only one node, it is the middle node, so we return the head.

Next, we initialize two pointers: slow and fast. Both slow and fast start from the head of the linked list.

We enter a loop that continues until fast reaches the end of the list or the next node of the end. Inside the loop:

The fast pointer moves two steps ahead (fast = fast.next.next) in each iteration.
The slow pointer moves one step ahead (slow = slow.next) in each iteration.
When the loop exits, it means that fast has reached the end of the list or the next node of the end. This indicates that slow is pointing to the middle node of the linked list.

Finally, we return the node referenced by the slow pointer as the middle node of the linked list.

Time Complexity (TC):
The time complexity of this algorithm is O(n/2) or simply O(n), where n is the number of nodes in the linked list. The fast pointer traverses the list at twice the speed of the slow pointer, so the loop takes approximately n/2 iterations to find the middle node.

Space Complexity:
The space complexity of this algorithm is O(1) since it uses only two additional pointers (slow and fast) regardless of the size of the linked list. The space used is constant and does not depend on the number of nodes in the list.

Code :
public ListNode middleNode(ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }

    ListNode slow = head, fast = head;

    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        slow = slow.next;
    }

    return slow;
}

--------------------------------------------------------------

4. Merge Two Sorted Lists - LeetCode #21

You are given the heads of two sorted linked lists list1 and list2.

Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

Example 1:
Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]

Example 2:
Input: list1 = [], list2 = []
Output: []

Example 3:
Input: list1 = [], list2 = [0]
Output: [0]


Explanation:

1. Create a `dummyHead` node with a value of -1. This node will serve as the starting point of the merged list.

2. Initialize a `current` pointer, which initially points to the `dummyHead` node. This pointer will be used to build the merged list step by step.

3. Use a `while` loop to merge the lists. The loop will continue as long as both `list1` and `list2` are not null. Inside the loop:

   a. Compare the values of the nodes pointed to by `list1` and `list2`.

   b. If the value of the node in `list1` is less than or equal to the value of the node in `list2`, append the node from `list1` to the `current` node, and move the `list1` pointer to its next node.

   c. If the value of the node in `list2` is less than the value of the node in `list1`, append the node from `list2` to the `current` node, and move the `list2` pointer to its next node.

   d. Move the `current` pointer to the node that was just added.

4. After the loop, there might be remaining nodes in either `list1` or `list2`. Append the remaining nodes to the end of the merged list.

5. Finally, return the merged list starting from the node after the `dummyHead`.

Time Complexity (TC):
The time complexity of this approach is O(m + n), where m is the number of nodes in `list1` and n is the number of nodes in `list2`. In the worst case, we traverse through all nodes of both lists once.

Space Complexity (SC):
The space complexity is O(1) since no additional data structures are used except for a constant amount of extra space to hold the `dummyHead` and `current` pointers. The merged list is created in-place without using extra space proportional to the input sizes.

Code:
public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
    ListNode dummyHead = new ListNode(-1);
    ListNode current = dummyHead;

    while (list1 != null && list2 != null) {
        if (list1.val <= list2.val) {
            current.next = list1;
            list1 = list1.next;
        } else {
            current.next = list2;
            list2 = list2.next;
        }
        current = current.next;
    }

    // Append the remaining nodes of list1 or list2
    if (list1 != null) {
        current.next = list1;
    } else {
        current.next = list2;
    }

    return dummyHead.next;
}

--------------------------------------------------------------

5. Remove Nth Node From End of List - LeetCode #19

Given the head of a linked list, remove the nth node from the end of the list and return its head.

Example 1:
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]

Example 2:
Input: head = [1], n = 1
Output: []

Example 3:
Input: head = [1,2], n = 1
Output: [1]


Explanation:
1. Create a `dummyPtr` node with a value of 0. This node will be used as the starting point of the linked list and can handle edge cases where the first node needs to be removed.

2. Initialize two pointers, `leftPtr` and `rightPtr`, both initially pointing to the head of the linked list.

3. Move the `rightPtr` n steps ahead to create a gap of n nodes between `leftPtr` and `rightPtr`. This can be done using a `while` loop that runs as long as n is greater than 0 and `rightPtr` is not null. In each iteration, decrement n and move `rightPtr` to its next node.

4. After the above loop, `rightPtr` will be at the (n+1)-th node from the end, and `leftPtr` will be at the dummy node or the node before the nth node from the end.

5. Now, move both `leftPtr` and `rightPtr` simultaneously until `rightPtr` reaches the end of the list (i.e., `rightPtr` becomes null). This is done using another `while` loop. In each iteration, both pointers move to their respective next nodes.

6. After the second loop, `leftPtr` will be at the node right before the nth node from the end, and `rightPtr` will be null.

7. Update the next pointer of `leftPtr` to skip the nth node from the end, effectively removing it from the linked list.

8. Return the next node of the `dummyPtr`, which is the new head of the modified linked list.

Time Complexity (TC):
The time complexity of this approach is O(N), where N is the number of nodes in the linked list. We traverse the entire list twice: once to create a gap between the pointers, and then to find the node before the nth node from the end.

Space Complexity (SC):
The space complexity is O(1) since no additional data structures are used, and the manipulation of pointers is done in-place without using extra space proportional to the input size.

public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummyPtr = new ListNode(0, head);
    ListNode leftPtr = dummyPtr;
    ListNode rightPtr = head;

    while (n > 0 && rightPtr != null) {
        rightPtr = rightPtr.next;
        n--;
    }

    while (rightPtr != null) {
        rightPtr = rightPtr.next;
        leftPtr = leftPtr.next;
    }

    leftPtr.next = leftPtr.next.next;

    return dummyPtr.next;
}
--------------------------------------------------------------

6. Add Two Numbers as Linked Lists - LeetCode #2

You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Example 1:

Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.

Example 2:

Input: l1 = [0], l2 = [0]
Output: [0]

Example 3:

Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]


Explanation:
1. Create a `dummy` node with a value of 0. This node will be used as the starting point of the result linked list.

2. Initialize three pointers, `p`, `q`, and `curr`, all initially pointing to the heads of the input linked lists `l1` and `l2`, and the dummy node, respectively.

3. Initialize a variable `carry` to store the carry generated while adding digits. Set it to 0 initially.

4. Use a `while` loop to traverse through both linked lists (`l1` and `l2`) or until there is a carry to consider. Inside the loop:

   a. Calculate the sum of the corresponding digits from `l1` and `l2`, along with the carry. If any of the linked lists reaches the end (becomes null), use 0 for the corresponding digit.

   b. Update the carry as `sum / 10`.

   c. Create a new node with the value of `sum % 10` (the last digit of the sum) and make `curr.next` point to it. Move the `curr` pointer to its next node.

   d. Move `p` and `q` pointers to their respective next nodes, if they are not null.

   e. If there is a carry remaining after the loop, create a new node with the carry value and make `curr.next` point to it.

5. Return the next node of the `dummy` node, which is the head of the result linked list (the sum of `l1` and `l2`).

Time Complexity (TC):
The time complexity of this approach is O(max(m, n)), where m is the number of nodes in `l1` and n is the number of nodes in `l2`. We traverse through the longer linked list once.

Space Complexity (SC):
The space complexity is O(max(m, n)) since we create a new linked list to store the result. The size of the result list can be at most max(m, n) + 1, considering the case when the addition results in an additional carry.


Code:
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(0);
    ListNode p = l1, q =l2, curr = dummy;
    int carry = 0;
    while(p != null || q != null){
        int x = (p != null)?p.val :0;
        int y = (q != null)?q.val :0;
        int sum = carry + x +y;
        carry = sum / 10;
        curr.next = new ListNode(sum % 10);
        curr = curr.next;
        if(p != null)
            p = p.next;
        if(q != null)
            q = q.next;
        if(carry > 0)
            curr.next = new ListNode(carry);
    }
    return dummy.next; 
}
--------------------------------------------------------------

7. Palindrome Linked List - LeetCode #234

Given the head of a singly linked list, return true if it is a 
palindrome or false otherwise.

Example 1:

Input: head = [1,2,2,1]
Output: true

Example 2:

Input: head = [1,2]
Output: false

Approach:

1. Handle Base Cases: If the linked list is empty or has only one node, it is considered a palindrome, so we return `true`.

2. Find the Middle: We use two pointers, `slow` and `fast`, to find the middle of the linked list. The `slow` pointer moves one node 
at a time, while the `fast` pointer moves two nodes at a time. By the time the `fast` pointer reaches the end of the linked list, 
the `slow` pointer will be at the middle.

3. Handle Odd-Length Linked List: If the linked list has an odd number of nodes, the `fast` pointer will not be null when the loop 
exits. In that case, we need to move the `slow` pointer one node ahead to exclude the middle node from the comparison for the 
palindromic property.

4. Separate the Two Halves: To prepare for comparison, we need to separate the two halves of the linked list. We set the `next` 
of the `prev` node (node just before the middle node) to `null`, effectively cutting off the first half from the second half.

5. Reverse the Second Half: We reverse the second half (from the middle node to the end) of the linked list using the `reverse` 
function. The `reverse` function returns the new head of the reversed list.

6. Compare the Two Halves: We then compare each corresponding element in the first half (original) with the second half (reversed) 
of the linked list. If any pair of nodes has different values, we return `false`, indicating that the linked list is not a palindrome.

7. Return Result: If the loop completes without finding any mismatched nodes, the linked list is a palindrome, and we return `true`.

Time Complexity (TC):
The time complexity of the given solution is O(N), where N is the number of nodes in the linked list. The two-pointer approach 
helps us find the middle of the linked list in one pass, and reversing the second half also takes linear time. The subsequent 
comparison of the two halves takes another linear pass.

Space Complexity (SC):
The space complexity is O(1) because we use a constant amount of additional space to store pointers (slow, fast, prev, etc.), and 
the reversal of the second half is done in-place without using any extra space other than a few pointers. Therefore, the space 
complexity is constant, irrespective of the input size.

Code:
public boolean isPalindrome(ListNode head) {
    if (head == null || head.next == null) {
        return true;
    }
    
    ListNode slow = head, fast = head, prev = null;
    
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        prev = slow;
        slow = slow.next;
    }

    //Odd length ll change slow
    if (fast != null) {
        prev = slow;
        slow = slow.next;
    }

    prev.next = null;

    slow = reverse(slow);

    fast = head;

    while (slow != null) {
        if (slow.val != fast.val) {
            return false;
        }
        slow = slow.next;
        fast = fast.next;
    }

    return true;
}

public ListNode reverse(ListNode head) {
    ListNode curr = head, prev = null;

    while (curr != null) {
        ListNode next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }

    return prev;
}


--------------------------------------------------------------

8. Intersection of Two Linked Lists - LeetCode #160

Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.

For example, the following two linked lists begin to intersect at node c1:


The test cases are generated such that there are no cycles anywhere in the entire linked structure.

Note that the linked lists must retain their original structure after the function returns.

Custom Judge:

The inputs to the judge are given as follows (your program is not given these inputs):

intersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.
listA - The first linked list.
listB - The second linked list.
skipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.
skipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.
The judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.


Example 1:

Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
Output: Intersected at '8'
Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect).
From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the 
intersected node in A; There are 3 nodes before the intersected node in B.
- Note that the intersected node's value is not 1 because the nodes with value 1 in A and B (2nd node in A and 3rd node in B) are different node references. In other words, they point to two different locations in memory, while the nodes with value 8 in 
A and B (3rd node in A and 4th node in B) point to the same location in memory.

Example 2:

Input: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
Output: Intersected at '2'
Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect).
From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.

Example 3:

Input: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
Output: No intersection
Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.
Explanation: The two lists do not intersect, so return null.


Approach:

1. First, we handle the edge cases where either `headA` or `headB` is null. If one of them is null, it means there is no intersection, so we return the other head as the result.

2. Next, we traverse both linked lists `headA` and `headB` separately and count their lengths `lengthA` and `lengthB`.

3. After counting the lengths, we find the absolute difference `differenceInLength` between `lengthA` and `lengthB`. This difference represents the number of extra nodes in the longer linked list.

4. Now, we identify which linked list is longer, and we create a pointer `firstPointerToMove` to start from the head of the longer linked list.

5. We move the `firstPointerToMove` forward by `differenceInLength` nodes. This ensures that both linked lists are aligned from the intersection point onwards. If there is an intersection, the `firstPointerToMove` will be pointing to the same node as the pointer in the shorter linked list.

6. Finally, we create a `lessLengthPointer` that starts from the head of the shorter linked list. We move both `lessLengthPointer` and `firstPointerToMove` one node at a time until they meet. The meeting point will be the intersection node.

7. If there is no intersection, both `lessLengthPointer` and `firstPointerToMove` will become null, and the loop will end. In that case, we return null.

8. If there is an intersection, the loop will end when both pointers point to the same node, which is the intersection node. We return this node as the result.

The time complexity of this approach is O(N), where N is the total number of nodes in both linked lists. This is because we traverse both lists once to calculate their lengths and then again to find the intersection node. The space complexity is O(1) as we are using only a constant amount of additional space to store pointers and variables.

Code:
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    if (headA == null || headB == null) {
        return null;
    }

    int lengthA = 0, lengthB = 0;
    ListNode tempA = headA, tempB = headB;

    while (tempA != null) {
        lengthA++;
        tempA = tempA.next;
    }

    while (tempB != null) {
        lengthB++;
        tempB = tempB.next;
    }

    int differenceInLength = Math.abs(lengthA - lengthB);

    ListNode firstPointerToMove = lengthA > lengthB ? headA : headB;

    while (differenceInLength != 0) {
        firstPointerToMove = firstPointerToMove.next;
        differenceInLength--;
    }

    ListNode secondPointerToMove = lengthA > lengthB ? headB : headA;

    while (firstPointerToMove != secondPointerToMove) {
        firstPointerToMove = firstPointerToMove.next;
        secondPointerToMove = secondPointerToMove.next;
    }

    return firstPointerToMove;
}


--------------------------------------------------------------

9. Linked List Cycle II - LeetCode #142

Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail's next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.

Do not modify the linked list.

Example 1:

Input: head = [3,2,0,-4], pos = 1
Output: tail connects to node index 1
Explanation: There is a cycle in the linked list, where tail connects to the second node.

Example 2:

Input: head = [1,2], pos = 0
Output: tail connects to node index 0
Explanation: There is a cycle in the linked list, where tail connects to the first node.

Example 3:

Input: head = [1], pos = -1
Output: no cycle
Explanation: There is no cycle in the linked list.


Algorithm:(Floyd's Tortoise and Hare algorithm)

1. We use two pointers, `slow` and `fast`, initially pointing to the head of the linked list.

2. We traverse the linked list using the following loop:
   - `slow` moves one step at a time (slow = slow.next)
   - `fast` moves two steps at a time (fast = fast.next.next)

3. If there is a cycle in the linked list, `fast` will eventually catch up to `slow` and they will meet at some point. This is because `fast` moves twice as fast as `slow`, and in a cycle, `fast` will eventually lap `slow` and meet it again.

4. When `fast` and `slow` meet, we break out of the loop.

5. We then reset one of the pointers, in this case, `slow`, to the head of the linked list.

6. Now, we move both `slow` and `fast` one step at a time until they meet again. The point where they meet is the starting node of the cycle.

7. If there is no cycle in the linked list, the `fast` pointer will reach the end of the list and become null, in which case we return null to indicate that there is no cycle.

The time complexity of this algorithm is O(N), where N is the number of nodes in the linked list. The slow pointer will traverse the entire list at most once, and the fast pointer will also traverse the list at most once due to its faster movement. Therefore, the time complexity is linear in the number of nodes in the list.

The space complexity of the algorithm is O(1) as we are using only a constant amount of additional space to store the `slow` and `fast` pointers. The algorithm does not require any extra data structures that grow with the size of the input.

Code:
public ListNode detectCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;

    while(fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (fast == slow){
            break;
        }
    }

    if (fast == null || fast.next == null){
        return null;
    }

    slow = head;

    while (slow != fast) {
        slow = slow.next;
        fast = fast.next;
    }

    return slow;
}
--------------------------------------------------------------

10. Remove Duplicates from Sorted List - LeetCode #83
Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.

Example 1:

Input: head = [1,1,2]
Output: [1,2]

Example 2:

Input: head = [1,1,2,3,3]
Output: [1,2,3]


Algorithm:

1. If the linked list is empty or has only one node, there are no duplicates to remove, so we return the head of the list as it is.

2. We initialize two pointers, `prev` and `trav`, both pointing to the head of the linked list.

3. We start traversing the linked list using the following loop:
   - If the value of `prev` and `trav` nodes are equal, it means we have encountered a duplicate node.
   - In this case, we skip the duplicate node by updating `prev.next` to point to `trav.next` and then move `trav` to `trav.next`.
   - If the values of `prev` and `trav` nodes are different, it means we have found a unique node.
   - In this case, we update `prev` to point to `trav` and move `trav` to `trav.next`.

4. We continue this process until `trav` becomes null, indicating the end of the linked list.

5. Finally, we return the head of the modified linked list.

The time complexity of this algorithm is O(N), where N is the number of nodes in the linked list. In the worst case, we may need to traverse the entire list once to remove all the duplicates.

The space complexity of the algorithm is O(1) as we are using only a constant amount of additional space to store the `prev` and `trav` pointers. The algorithm does not require any extra data structures that grow with the size of the input.

Code:
public ListNode deleteDuplicates(ListNode head) {
    if(head == null || head.next == null){
        return head;
    }
    ListNode prev = head, trav = head.next;
    while(trav != null){
        if(prev.val == trav.val){
            prev.next = trav.next;
            trav = trav.next;
        }else{
            prev = trav;
            trav = trav.next;
        }
    }
    return head;
}
--------------------------------------------------------------
11. Flatten a Multilevel Doubly Linked List - LeetCode #430

You are given a doubly linked list, which contains nodes that have a next pointer, a previous pointer, and an additional child pointer.
This child pointer may or may not point to a separate doubly linked list, also containing these special nodes. These child lists may 
have one or more children of their own, and so on, to produce a multilevel data structure as shown in the example below.

Given the head of the first level of the list, flatten the list so that all the nodes appear in a single-level, doubly linked list. 
Let curr be a node with a child list. The nodes in the child list should appear after curr and before curr.next in the flattened list.

Return the head of the flattened list. The nodes in the list must have all of their child pointers set to null.

Example 1:

Input: head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
Output: [1,2,3,7,8,11,12,9,10,4,5,6]
Explanation: The multilevel linked list in the input is shown.
After flattening the multilevel linked list it becomes:

Example 2:

Input: head = [1,2,null,3]
Output: [1,3,2]
Explanation: The multilevel linked list in the input is shown.
After flattening the multilevel linked list it becomes:

Example 3:

Input: head = []
Output: []
Explanation: There could be empty list in the input.


Approach:
The code iterates through the main linked list and uses a stack to store nodes that need to be connected back to the main list after flattening the child lists. It performs the following steps:

1. Initialize the `curr` pointer to the head of the main linked list and a `Stack` to store nodes.
2. Traverse through the main linked list using `curr`:
   - If `curr` has a child, flatten the child list by connecting it with `curr.next`. Store `curr.next` in the stack so that we can connect it back to the main list later.
   - If `curr` does not have a child but has reached the end of the list and there are nodes in the stack, pop a node from the stack and connect it as the `next` node of the current node (`curr`).
   - Move `curr` to the next node in the list.

**Time Complexity (TC):**
The code iterates through the entire linked list once, so the time complexity is O(n), where n is the number of nodes in the list.

**Space Complexity (SC):**
The space complexity is O(m), where m is the number of nodes that have child lists. The code uses a stack to store these nodes temporarily.

Code:
public Node flatten(Node head) {
    if (head == null) {
        return null;
    }

    Node curr = head;
    Stack<Node> stack = new Stack<>();

    while (curr != null) {
        if (curr.child != null) {
            if (curr.next != null) {
                stack.push(curr.next);
            }
            curr.next = curr.child;
            curr.child.prev = curr;
            curr.child = null;
        } else if (curr.next == null && !stack.isEmpty()) {
            Node nextNode = stack.pop();
            curr.next = nextNode;
            nextNode.prev = curr;
        }
        curr = curr.next;
    }

    return head;
}

--------------------------------------------------------------
12. Rotate List - LeetCode #61

Given the head of a linked list, rotate the list to the right by k places.

Example 1:

Input: head = [1,2,3,4,5], k = 2
Output: [4,5,1,2,3]

Example 2:

Input: head = [0,1,2], k = 4
Output: [2,0,1]

Approach:
1. First, we create a copy of the head node and initialize a variable 'numNodes' to keep track of the number of nodes in the list.
2. We iterate through the list to count the number of nodes and update the 'numNodes' variable accordingly.
3. To handle cases where 'k' is larger than the number of nodes in the list, we calculate 'rotations' as 'k % numNodes'. 
This ensures that 'rotations' is less than 'numNodes', so it won't lead to unnecessary rotations.
4. If 'k' is zero or the list has only one node (numNodes == 1), we return the original head as the list remains unchanged.
5. Otherwise, we find the (numNodes - rotations)th node (lastNode) in the list. The node following lastNode will become the 
new head of the rotated list.
6. We update the pointers to achieve the rotation. The next pointer of the current last node should point to the original head, 
and the next pointer of the (numNodes - rotations - 1)th node should be set to null to disconnect the list at the (numNodes - rotations)th node.
7. Finally, we return the new head, which was the node following lastNode before the rotation.

Time Complexity (TC):
The time complexity of the algorithm is O(n) since it iterates through the linked list once to count the number of nodes and 
once again to find the (numNodes - rotations)th node.

Space Complexity (SC):
The space complexity of the algorithm is O(1) since it uses a constant amount of additional space to store variables, 
regardless of the size of the input list.

Code:
public ListNode rotateRight(ListNode head, int k) {
    ListNode current = head; 
    // Creating a copy of the head to iterate the list while keeping the head unchanged

    // If the list is empty or if we don't have to rotate the list, return it
    if (current == null || k == 0) {
        return head;
    }

    int numNodes = 1; // Counting the number of nodes in the list
    while (current.next != null) {
        current = current.next;
        numNodes++;
    }

    int rotations = k % numNodes; 
    // Updating the number of rotations based on the list size

    // If the number of rotations is zero or there's only one node in the list,
    // the list will not change, so just return it
    if (rotations == 0 || numNodes == 1) {
        return head;
    }

    ListNode lastNode = head;
    int i = 1;
    // Finding the (numNodes - k)th node (y) to make it the new tail of the rotated list
    while (i < numNodes - rotations) {
        lastNode = lastNode.next;
        i++;
    }

    ListNode newHead = lastNode.next; 
    // Creating a new head pointing to the (numNodes - k)th node
    lastNode.next = null; 
    // Pointing the (numNodes - k - 1)th node to null to disconnect the list
    current.next = head; 
    // Pointing the last node to the original head to complete the rotation

    return newHead;
}
--------------------------------------------------------------
13. Sort List - LeetCode #148

Given the head of a linked list, return the list after sorting it in ascending order.

Example 1:

Input: head = [4,2,1,3]
Output: [1,2,3,4]

Example 2:

Input: head = [-1,5,3,4,0]
Output: [-1,0,3,4,5]

Example 3:

Input: head = []
Output: []


Approach:

1. The function `sortList` is a recursive function that sorts the given linked list. The base cases are when the list is empty or has only one node, in which case it returns the head itself as it is already sorted.

2. To sort the list, we first find the middle node using the `findMiddle` function. We use the slow and fast pointer technique to find the middle node, where the slow pointer moves one step at a time and the fast pointer moves two steps at a time. When the fast pointer reaches the end, the slow pointer points to the middle node.

3. We then split the list into two halves at the middle node. We update the `next` pointer of the middle node to null to disconnect the two halves.

4. We recursively call `sortList` on both halves to sort them separately.

5. The sorted halves are obtained as `head1` and `head2`.

6. Finally, we merge the sorted halves using the `mergeList` function. This function takes two sorted linked lists and merges them into a single sorted linked list.

7. In the `mergeList` function, we use a dummy node to build the merged list. We iterate through both lists, comparing the values of nodes from both lists. We add the smaller node to the merged list, and then move the corresponding pointer forward.

8. After merging, we return the head of the merged list, which is the `next` node of the dummy node.

Time Complexity (TC):
The time complexity of the merge sort algorithm is O(n log n), where 'n' is the number of nodes in the linked list. The recursive approach divides the list into halves in each recursive call, and merging takes linear time. Since the depth of the recursion is log n (due to dividing the list into halves), the overall time complexity is O(n log n).

Space Complexity (SC):
The space complexity of the merge sort algorithm is O(log n) due to the recursive calls. Each recursive call creates a new stack frame, and the maximum depth of recursion is log n (when dividing the list into halves). Additionally, the `mergeList` function uses a constant amount of extra space to create the merged list, so it doesn't contribute to the space complexity with respect to the input size 'n'.

Code:
class Solution {
    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null)
            return head;
        
        ListNode mid = findMiddle(head);
        
        ListNode midnext = mid.next;
        
        mid.next = null;
        
        ListNode head1 = sortList(head);
        ListNode head2 = sortList(midnext);
        
        return mergeList(head1, head2);
    }

    public static ListNode findMiddle(ListNode head){
        ListNode slow = head, fast = head;
        while(fast.next != null && fast.next.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
    
    public static ListNode mergeList(ListNode head1, ListNode head2){
        ListNode dummy = new ListNode(-1);
        ListNode head = dummy;
        while(head1 != null && head2 != null){
            if(head1.val < head2.val){
                dummy.next = head1;
                head1 = head1.next;
            }else{
                dummy.next = head2;
                head2 = head2.next;
            }
            dummy = dummy.next;
        }
        dummy.next = head1 == null ? head2 : head1;
        return head.next;
    }
}
--------------------------------------------------------------
14. Swap Nodes in Pairs - LeetCode #24

Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)

Example 1:

Input: head = [1,2,3,4]
Output: [2,1,4,3]

Example 2:

Input: head = []
Output: []

Example 3:

Input: head = [1]
Output: [1]

Approach:
1. The base condition checks if there is no node or only one node remaining in the list. If either condition is true, it returns the node itself as there is nothing to swap.

2. For lists with more than one node, we recursively call the `swapPairs` function on the `next.next` element. This call will return the head of the swapped list after processing the rest of the list.

3. After the recursive call, we perform the swapping logic. We swap the current head (`head`) with its next node (`head.next`).

4. Then, we connect the swapped pair (`head` and `head.next`) with the head of the remaining swapped list (`tHead`).

5. Finally, we return the new head of the swapped list, which is the second node of the original pair (`head.next`).

Time Complexity (TC):
The time complexity of the recursive approach is O(n), where 'n' is the number of nodes in the linked list. Each node is processed once during the recursion.

Space Complexity (SC):
The space complexity of the recursive approach is O(n) due to the function call stack. In the worst case, the maximum depth of recursion will be 'n' when there are 'n' nodes in the list.


Code:
public ListNode swapPairs(ListNode head) {
    /**
    * The base condition will be triggered when there is no node left or there is just 1 node.
    * If there is just 1 node left, there is nothing that can be swapped, hence we return the node
    * itself.
    */
    if(head == null || head.next == null) return head;
    
    /**
    * If there are more than 1 nodes remaining, we would recursively call the method by passing the
    * next.next element.
    * This is because we would be swapping the head and the head.next element.
    * So, to call the method we would pass the head.next.next element.
    * This call will return a head which we would have to attach it to the current head.next element,
    AFTER SWAPPING.
    */
    ListNode tHead = swapPairs(head.next.next);
    
    /**
    * Here, we would write the swapping logic.
    * The node which is returned from the above line of code, will be connected with the nodes after
    * swapping here.
    */
    
    ListNode temp = head.next;
    head.next = tHead;
    temp.next = head;
    return temp;
}

--------------------------------------------------------------

15. Copy List with Random Pointer - LeetCode #138

A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.

Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.

For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.

Return the head of the copied linked list.

The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:

val: an integer representing Node.val
random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.
Your code will only be given the head of the original linked list.

Example 1:

Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]

Example 2:
Input: head = [[1,1],[2,1]]
Output: [[1,1],[2,1]]

Example 3:
Input: head = [[3,null],[3,0],[3,null]]
Output: [[3,null],[3,0],[3,null]]

Approach:
The given code performs a deep copy of a linked list with random pointers using a HashMap. It creates a new list with new nodes having the same values as the original list, and then establishes the correct connections (next and random pointers) using the HashMap to maintain the mapping between the original nodes and their corresponding new nodes.

1. First, it traverses the original linked list and creates a new node for each node in the original list. It stores the mapping between the original nodes and their corresponding new nodes in a HashMap (`nodeMap`).

2. Then, it traverses the original list again. For each node, it retrieves the corresponding new node from the `nodeMap` and sets its `next` and `random` pointers by looking up the corresponding nodes in the HashMap.

3. Finally, it returns the head of the new linked list, which is the value mapped to the original head in the `nodeMap`.

Time Complexity (TC):
The time complexity of this approach is O(n), where 'n' is the number of nodes in the linked list. In the first traversal, we create new nodes for each node in the original list. In the second traversal, we set the `next` and `random` pointers for each new node.

Space Complexity (SC):
The space complexity of this approach is O(n), where 'n' is the number of nodes in the linked list. The additional space is used to store the mapping between the original nodes and their corresponding new nodes in the HashMap. In the worst case, when all nodes have unique random pointers, the HashMap will store all nodes.

Note: This approach creates a deep copy of the linked list, meaning it creates new nodes for both the main list and the random pointers.


Code:
public Node copyRandomList(Node head) {
    Map<Node, Node> nodeMap = new HashMap<>();

    Node trav = head;
    while (trav != null) {
        Node temp = new Node(trav.val);
        nodeMap.put(trav, temp);
        trav = trav.next;
    }

    trav = head;
    while (trav != null) {
        Node temp = nodeMap.get(trav);
        temp.next = nodeMap.get(trav.next);
        temp.random = nodeMap.get(trav.random);
        trav = trav.next;
    }

    return nodeMap.get(head);
}

--------------------------------------------------------------

16. Reverse Nodes in k-Group - LeetCode #25

Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.

k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.

You may not alter the values in the list's nodes, only nodes themselves may be changed.

Example 1:
Input: head = [1,2,3,4,5], k = 2
Output: [2,1,4,3,5]

Example 2:
Input: head = [1,2,3,4,5], k = 3
Output: [3,2,1,4,5]



--------------------------------------------------------------

17. Delete Node in a Linked List - LeetCode #237

There is a singly-linked list head and we want to delete a node node in it.

You are given the node to be deleted node. You will not be given access to the first node of head.

All the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.

Delete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:

The value of the given node should not exist in the linked list.
The number of nodes in the linked list should decrease by one.
All the values before node should be in the same order.
All the values after node should be in the same order.
Custom testing:

For the input, you should provide the entire linked list head and the node to be given node. node should not be the last node of the list and should be an actual node in the list.
We will build the linked list and pass the node to your function.
The output will be the entire list after calling your function.
 

Example 1:
Input: head = [4,5,1,9], node = 5
Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.

Example 2:
Input: head = [4,5,1,9], node = 1
Output: [4,5,9]
Explanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.


Approach:
To delete a node in a singly-linked list without having access to the first node of the list, we can follow the given node's reference and copy the value of the next node into the given node. Then, we can update the given node's next reference to skip the next node, effectively removing it from the list.

Code:
public void deleteNode(ListNode node) {
    if (node == null || node.next == null) {
        return; // Given node is null or the last node, cannot delete
    }

    // Copy the value of the next node into the given node
    node.val = node.next.val;

    // Skip the next node by updating the next reference
    node.next = node.next.next;
}

--------------------------------------------------------------
18. Odd Even Linked List - LeetCode #328

Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, 
and return the reordered list.

The first node is considered odd, and the second node is even, and so on.

Note that the relative order inside both the even and odd groups should remain as it was in the input.

You must solve the problem in O(1) extra space complexity and O(n) time complexity.

Example 1:
Input: head = [1,2,3,4,5]
Output: [1,3,5,2,4]

Example 2:
Input: head = [2,1,3,5,6,4,7]
Output: [2,3,6,7,1,5,4]

Approach:

1. First, we handle edge cases: If the list is empty or contains only one node, there is no need to reorder, so we return the list as it is.

2. We create two pointers `oddHead` and `evenHead` initially pointing to the first and second nodes, respectively. These pointers will be used to track the heads of the odd and even groups.

3. We also create two more pointers `odd` and `even` to iterate through the odd and even groups, respectively. We initialize them to the same nodes as `oddHead` and `evenHead`.

4. We start iterating through the list using `even` as our primary pointer. In each iteration, we first update the `odd.next` pointer to point to the next node after `even`. This effectively detaches the current `even` node from the odd group and adds it to the even group.

5. Next, we update the `odd` pointer to move to the next odd-indexed node, which is now the next node after `even`.

6. We then update the `even.next` pointer to point to the next node after `odd`. This detaches the current `odd` node from the even group and adds it to the odd group.

7. Finally, we update the `even` pointer to move to the next even-indexed node, which is now the next node after `odd`.

8. We repeat steps 4 to 7 until `even` becomes null or `even.next` becomes null (indicating the end of the list).

9. After the iteration is complete, we have two separate lists: one containing odd-indexed nodes (starting from `oddHead`) and another containing even-indexed nodes (starting from `evenHead`).

10. We then connect the tail of the odd group (`odd`) to the head of the even group (`evenHead`) to combine both lists.

11. The reordered list is now formed with odd-indexed nodes followed by even-indexed nodes.

12. Finally, we return `oddHead`, which is the head of the reordered list.

Code:
public ListNode oddEvenList(ListNode head) {
    if (head == null || head.next == null){
        return head;
    }

    ListNode oddHead = head;
    ListNode evenHead = head.next;

    ListNode odd = oddHead;
    ListNode even = evenHead;

    while (even != null && even.next != null) {
        odd.next = even.next;
        odd = odd.next;
        even.next = odd.next;
        even = even.next;
    }

    odd.next = evenHead;

    return oddHead;
}


--------------------------------------------------------------

19. Convert Sorted List to Binary Search Tree - LeetCode #109

Given the head of a singly linked list where elements are sorted in ascending order, convert it to a 
height-balanced binary search tree.

Example 1:
Input: head = [-10,-3,0,5,9]
Output: [0,-3,9,-10,null,5]
Explanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.

Example 2:
Input: head = []
Output: []

Approach:
The given problem is to convert a sorted singly linked list into a height-balanced binary search tree (BST). To achieve this, the solution uses a recursive approach based on the following steps:

1. Find the middle node: We use the slow and fast pointer approach to find the middle node of the linked list. The fast pointer moves two steps at a time, while the slow pointer moves one step at a time. When the fast pointer reaches the end of the list, the slow pointer will be at the middle node.

2. Divide the linked list into two halves: Once we find the middle node, we split the linked list into two parts by setting the `next` pointer of the node before the middle node (i.e., `prev.next`) to `null`.

3. Recursively build left and right subtrees: We create a new TreeNode with the value of the middle node and recursively call the `sortedListToBST` function on the left and right halves of the linked list. This step ensures that each subtree is a balanced BST.

**Time Complexity (TC):**
The time complexity of the overall approach is O(n log n), where n is the number of elements in the linked list. The reason for the logarithmic factor comes from the fact that for each level of the recursive calls, we find the middle node, which takes O(n) time. Since the recursion tree has a maximum depth of log n (balanced BST), the overall time complexity is O(n log n).

**Space Complexity (SC):**
The space complexity is O(log n) due to the maximum depth of the recursion stack. This is because the recursive function calls create new stack frames for each level of the recursion, and the maximum depth of the recursion is log n in the case of a balanced BST. Additionally, the space used by the `prev` and `slow` pointers during the slow and fast pointer approach is constant, so it does not contribute to the overall space complexity.


Code:
public TreeNode sortedListToBST(ListNode head) {
    if (head == null) {
        return null;
    }
    if(head.next==null) {
        return new TreeNode(head.val);
    }
        
    // Step 1: Find the middle node
    ListNode prev = null;
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null && fast.next != null) {
        prev = slow;
        slow = slow.next;
        fast = fast.next.next;
    }
    
    // Step 2: Divide the linked list into two halves
    if (prev != null) {
        prev.next = null;
    }
    
    // Step 3: Recursively build left and right subtrees
    TreeNode root = new TreeNode(slow.val);
    root.left = sortedListToBST(head);
    root.right = sortedListToBST(slow.next);
    
    return root;
}


--------------------------------------------------------------

20. Remove Linked List Elements - LeetCode #203

Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, 
and return the new head.

Example 1:
Input: head = [1,2,6,3,4,5,6], val = 6
Output: [1,2,3,4,5]

Example 2:
Input: head = [], val = 1
Output: []

Example 3:
Input: head = [7,7,7,7], val = 7
Output: []

Approach:

1. Initialize `prev` and `trav` as `null` and `head`, respectively, to start from the beginning of the linked list.
2. Use a while loop to iterate through the linked list, stopping when `trav` becomes `null` (end of the list).
3. Inside the loop, check if the value of the current node (`trav.val`) matches the given `val`.
4. If there is a match, remove the current node:
   - If the current node is the head node (`trav == head`), update `head` to point to the next node and move `trav` to the new head (i.e., `trav = head.next`). This effectively removes the current head from the list.
   - If the current node is not the head, update the `next` pointer of the previous node (`prev.next`) to skip the current node and point to the node after it. Then, move `trav` to the next node (i.e., `trav = trav.next`). This effectively removes the current node from the list.
5. If there is no match, update `prev` to point to the current node and move `trav` to the next node (i.e., `prev = trav` and `trav = trav.next`), to continue traversing the list.
6. Repeat steps 3 to 5 until `trav` becomes `null`, and all nodes with the value `val` have been removed from the list.

**Time Complexity:** The time complexity of this approach is O(n), where n is the number of nodes in the linked list. In the worst case, we may need to traverse the entire list to remove all nodes with the value `val`.

**Space Complexity:** The space complexity is O(1) because the algorithm uses a constant amount of extra space regardless of the size of the input linked list. The space used by `prev` and `trav` pointers remains constant throughout the process.

Code:
public ListNode removeElements(ListNode head, int val) {
    ListNode prev = null, trav = head;

    while (trav != null) {
        if(trav.val == val){
            if(trav == head){
                head = head.next;
                trav = head;
            }else{
                prev.next = trav.next;
                trav = trav.next;
            }
        }else{
            prev = trav;
            trav = trav.next;
        } 
    }

    return head;
}


--------------------------------------------------------------
--------------------------------------------------------------

#Tree

1. Binary Tree Inorder Traversal - LeetCode #94
Inorder is LEFT->ROOT->RIGHT
Code:
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> list = new ArrayList<Integer>();
    inorder(root, list);
    return list;
}

public void inorder(TreeNode root, List<Integer> list) {
    if (root == null) {
        return;
    }
    inorder(root.left, list);
    list.add(root.val);
    inorder(root.right, list);
}

Time Complexity (TC):
The time complexity of the `inorderTraversal` function is O(n), where n is the number of nodes in the binary tree. This is because 
the function visits each node exactly once during the inorder traversal. In the worst case, the function needs to visit all nodes 
in the binary tree.

Space Complexity (SC):
The space complexity of the `inorderTraversal` function is O(h), where h is the height of the binary tree. In the worst case, the 
binary tree can be skewed, and the height of the tree becomes n (number of nodes), making the space complexity O(n). This is because 
the function uses a recursive approach, and the maximum number of recursive calls in the call stack corresponds to the height of 
the tree. However, in the average case of a balanced binary tree, the height is log(n), making the space complexity O(log(n)).

Additionally, the function uses a list `list` to store the inorder traversal result. The space complexity for this list is 
also O(n) because, in the worst case, all n node values need to be stored in the list.
--------------------------------------------------------------

2. Validate Binary Search Tree - LeetCode #98

Given the root of a binary tree, determine if it is a valid binary search tree (BST).

A valid BST is defined as follows:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.

Example 1:
Input: root = [2,1,3]
Output: true
Example 2:


Input: root = [5,1,4,null,null,3,6]
Output: false
Explanation: The root node's value is 5 but its right child's value is 4.


The given solution checks if a binary tree represented by `TreeNode` objects is a valid binary search tree (BST) or not. 
A valid BST is a binary tree where the left subtree contains nodes with values less than the current node, and the right 
subtree contains nodes with values greater than the current node. Additionally, it ensures that no duplicate values are allowed.

Approach:
The function `isValidBST` is the main function that takes the root of the binary tree as input and calls the helper function `isValidBSTHelper` to perform the recursive check.

The `isValidBSTHelper` function is a recursive function that traverses the binary tree in an inorder manner. During the inorder traversal, it keeps track of the minimum and maximum allowable values for each node to ensure that the left subtree values are 
less than the current node's value, and the right subtree values are greater than the current node's value.

1. The function `isValidBSTHelper` checks if the current node is null. If so, it returns true because an empty tree is considered 
a valid BST.

2. It then checks if the current node's value violates the BST property. It compares the current node's value with the `min` and 
`max` values. If the current node's value is less than or equal to the `min` value or greater than or equal to the `max` value, 
it means the current node's value violates the BST property, and the function returns false.

3. If the current node's value is within the valid range, the function continues the inorder traversal by calling itself 
recursively for the left and right subtrees.

4. The left subtree's valid range is from `min` to the current node's value (exclusive), and the right subtree's valid range 
is from the current node's value (exclusive) to `max`.

5. If both recursive calls return true (i.e., both subtrees are valid BSTs), then the function returns true. Otherwise, it 
returns false.

Time Complexity:
The time complexity of the solution is O(n), where n is the number of nodes in the binary tree. This is because the function 
visits each node once during the inorder traversal.

Space Complexity:
The space complexity of the solution is O(h), where h is the height of the binary tree. In the worst case, the binary tree can 
be skewed, and the height of the tree becomes n (number of nodes). However, in the average case, the height of a balanced BST 
is log(n), making the space complexity O(log(n)). The space is used for the recursive call stack during the inorder traversal.

Code:
public boolean isValidBST(TreeNode root) {
    return isValidBSTHelper(root, null, null);
}

private boolean isValidBSTHelper(TreeNode node, Integer min, Integer max) {
    if (node == null) {
        return true;
    }

    if ((min != null && node.val <= min) ||
        (max != null && node.val >= max)) {
        return false;
    }

    return isValidBSTHelper(node.left, min, node.val) &&
           isValidBSTHelper(node.right, node.val, max);
}


--------------------------------------------------------------

3. Maximum Depth of Binary Tree - LeetCode #104

Given the root of a binary tree, return its maximum depth.

A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

Example 1:
Input: root = [3,9,20,null,null,15,7]
Output: 3

Example 2:
Input: root = [1,null,2]
Output: 2

Approach:
The function `maxDepth` calculates the maximum depth (maximum height) of a binary tree using a recursive approach. The maximum 
depth of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.

The function follows a depth-first traversal approach, where it first calculates the maximum depth of the left subtree and then 
the maximum depth of the right subtree. The maximum depth of the current node is then the maximum of the left and right subtree 
depths, plus 1 (to account for the current node).

Time Complexity (TC):
The time complexity of the `maxDepth` function is O(n), where n is the number of nodes in the binary tree. In the worst case, 
the function needs to visit all nodes of the binary tree once to calculate the maximum depth.

Space Complexity (SC):
The space complexity of the `maxDepth` function is O(h), where h is the height of the binary tree. In the worst case, the binary 
tree can be skewed, and the height of the tree becomes n (number of nodes), making the space complexity O(n). This is because 
the function uses a recursive approach, and the maximum number of recursive calls in the call stack corresponds to the height 
of the tree. However, in the average case of a balanced binary tree, the height is log(n), making the space complexity O(log(n)).


Code:
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }

    int leftDepth = maxDepth(root.left);
    int rightDepth = maxDepth(root.right);

    return Math.max(leftDepth, rightDepth) + 1;
}

--------------------------------------------------------------

4. Symmetric Tree - LeetCode #101
Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).

Example 1:

Input: root = [1,2,2,3,4,4,3]
Output: true

Example 2:

Input: root = [1,2,2,null,3,null,3]
Output: false

Approach:
The `isSymmetric` method is a wrapper function that calls the helper function `isSymmetric(TreeNode left, TreeNode right)`. This helper function recursively checks if the left subtree and right subtree are symmetric at each level. If both subtrees are symmetric at each level, the entire tree is considered symmetric.

1. The base case checks if both `left` and `right` are null. If both are null, it means the subtrees are symmetric, so we return `true`.

2. The next base case checks if either `left` or `right` is null while the other is not null. If this happens, it means the subtrees are not symmetric, so we return `false`.

3. If both `left` and `right` are not null and have the same value, we continue checking their subtrees recursively. We call `isSymmetric` on `left.left` and `right.right`, and `isSymmetric` on `left.right` and `right.left`. If both recursive calls return `true`, it means both subtrees are symmetric, so we return `true`. Otherwise, we return `false`.

Time Complexity:
The time complexity of this approach is O(N), where N is the number of nodes in the binary tree. We visit each node once in the worst case.

Space Complexity:
The space complexity is O(H), where H is the height of the binary tree. In the worst case, the recursion stack will have a maximum depth equal to the height of the tree. In a balanced binary tree, the height is log(N), but in the worst case (skewed tree), the height is N.

Code:
public boolean isSymmetric(TreeNode root) {
    return isSymmetric(root.left, root.right);
}

public boolean isSymmetric(TreeNode left, TreeNode right) {
    if(left == null && right == null){
        return true;
    }

    if (left == null || right == null) {
        return false;
    }

    if (left.val != right.val) {
        return false;
    }

    return (isSymmetric(left.left, right.right) && 
            isSymmetric(left.right, right.left));
}

--------------------------------------------------------------

5. Binary Tree Level Order Traversal - LeetCode #102

Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).

Example 1:
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]

Example 2:
Input: root = [1]
Output: [[1]]

Example 3:
Input: root = []
Output: []

Approach:

1. The `levelOrder` function takes a `TreeNode` object `root` as input and returns a list of lists (`List<List<Integer>>`) containing 
the values of nodes at each level in the binary tree.

2. The function first initializes an empty list of lists called `result`, which will store the values of nodes at each level.

3. If the `root` is null (i.e., the tree is empty), the function directly returns the empty `result`.

4. To perform the level order traversal, the function uses a queue (`Queue<TreeNode>`). It starts by adding the `root` node to the queue.

5. While the queue is not empty, the function enters into a loop, which iterates through the current level of nodes in the queue.

6. For each level, it creates a new list `currentLevel` to store the values of nodes at that level.

7. It processes all nodes present in the current level:
   - Dequeue the front node from the queue.
   - Add the value of the dequeued node to the `currentLevel`.
   - Enqueue the left and right children of the dequeued node into the queue if they exist.

8. After processing all nodes of the current level, it adds the `currentLevel` to the `result` list.

9. The process continues until all levels are traversed, and the queue becomes empty.

10. Finally, the `result` list contains the level-order traversal of the binary tree.

Time Complexity:
The time complexity of this approach is O(N), where N is the number of nodes in the binary tree. In the worst case, we visit all nodes in the binary tree once.

Space Complexity:
The space complexity is O(W), where W is the maximum width of the binary tree (i.e., the maximum number of nodes at any level). 
In the worst case, the maximum width of a binary tree can be N/2, which occurs in a perfect binary tree with N nodes at the 
bottommost level. The space complexity is determined by the queue, which holds at most W nodes at any point during the traversal.

Code:
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();

        if (root == null) {
            return result;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            List<Integer> currentLevel = new ArrayList<>();

            for (int i = 0; i < levelSize; i++) {
                TreeNode currentNode = queue.poll();
                currentLevel.add(currentNode.val);

                if (currentNode.left != null) {
                    queue.offer(currentNode.left);
                }

                if (currentNode.right != null) {
                    queue.offer(currentNode.right);
                }
            }

            result.add(currentLevel);
        }

        return result;
    }
}

--------------------------------------------------------------

6. Path Sum - LeetCode #112

Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.

A leaf is a node with no children.

Example 1:
Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
Output: true
Explanation: The root-to-leaf path with the target sum is shown.

Example 2:
Input: root = [1,2,3], targetSum = 5
Output: false
Explanation: There two root-to-leaf paths in the tree:
(1 --> 2): The sum is 3.
(1 --> 3): The sum is 4.
There is no root-to-leaf path with sum = 5.

Example 3:
Input: root = [], targetSum = 0
Output: false
Explanation: Since the tree is empty, there are no root-to-leaf paths.

Approach:

1. The `hasPathSum` function is the main function that takes a `TreeNode` object `root` and an integer `targetSum` as input 
and returns a boolean value indicating whether there exists a root-to-leaf path with the given sum.

2. The base case of the recursion is:
   - If the `root` is null, it means there are no more nodes to explore, and the function returns false.

3. In the recursive part:
   - The function first checks if the current node's value (`root.val`) equals the remaining `targetSum` 
(i.e., `targetSum - root.val`) and if the node is a leaf node (i.e., both `root.left` and `root.right` are null). If this 
condition is met, it means we have found a path with the required sum, and the function returns true.
   - If the above condition is not met, the function continues the search in the left subtree and the right subtree, 
recursively calling `hasPathSum` with the updated `targetSum` (i.e., `targetSum - root.val`). The function returns the 
logical OR of these two recursive calls.

4. The recursion explores all possible paths from the root to the leaves of the binary tree, searching for a path with the given sum.

Time Complexity:
The time complexity of this approach is O(N), where N is the number of nodes in the binary tree. In the worst case, we visit all 
nodes in the binary tree once.

Space Complexity:
The space complexity is O(H) due to the recursion stack, where H is the height of the binary tree. In the worst case, the 
recursion stack will have a maximum depth equal to the height of the binary tree. In a balanced binary tree, the height is 
log(N), but in the worst case (skewed tree), the height is N.

Code:

public boolean hasPathSum(TreeNode root, int targetSum) {
    if(root == null)
        return false;
    if(targetSum - root.val == 0 && root.left == null && root.right == null)
        return true;
    return (hasPathSum(root.left, targetSum-root.val) || 
            hasPathSum(root.right, targetSum - root.val));
}
--------------------------------------------------------------

7. Construct Binary Tree from Preorder and Inorder Traversal - LeetCode #105

--------------------------------------------------------------

8. Construct Binary Tree from Inorder and Postorder Traversal - LeetCode #106

--------------------------------------------------------------

9. Lowest Common Ancestor of a Binary Tree - LeetCode #236

Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

According to the definition of LCA on Wikipedia: The lowest common ancestor is defined between two nodes p and q as the lowest 
node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).

Example 1:

Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.

Example 2:

Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.

Example 3:

Input: root = [1,2], p = 1, q = 2
Output: 1

MAIN THING TO NOTE : a node can be descendent of itself
Approach:

1. Start from the root of the binary tree.
2. If the current node is null, return null, as there is no ancestor.
3. If the current node is either `p` or `q`, return the current node itself as one of the nodes is an ancestor of itself.
4. Recursively find the LCA in the left subtree and store it in the variable `left`.
5. Recursively find the LCA in the right subtree and store it in the variable `right`.
6. If both `left` and `right` are not null, it means that `p` and `q` are present in different subtrees of the current node, so the current node is the LCA.
7. If only one of `left` or `right` is not null, it means that either `p` or `q` is present in the subtree, and the other node is not present in the tree, so return the non-null node.
8. If both `left` and `right` are null, it means that neither `p` nor `q` is present in the subtree, so return null.

Time Complexity:
The time complexity of this approach is O(N), where N is the number of nodes in the binary tree. In the worst case, we visit all nodes once.

Space Complexity:
The space complexity is O(H), where H is the height of the binary tree. In the worst case, the height of the binary tree can 
be N (in the case of a skewed binary tree). The space complexity is determined by the recursive call stack during the traversal.

Let's implement the solution in Java:

```java

public class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) {
            return null;
        }

        if (root == p || root == q) {
            return root;
        }

        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        if (left != null && right != null) {
            return root;
        } else if (left != null) {
            return left;
        } else {
            return right;
        }
    }
}
```

You can use this implementation to find the lowest common ancestor of the given nodes in a binary tree.
--------------------------------------------------------------

10. Binary Tree Maximum Path Sum - LeetCode #124

A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.

The path sum of a path is the sum of the node's values in the path.

Given the root of a binary tree, return the maximum path sum of any non-empty path.

Example 1:
Input: root = [1,2,3]
Output: 6
Explanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.

Example 2:
Input: root = [-10,9,20,null,null,15,7]
Output: 42
Explanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.

The given code is a solution to the "Binary Tree Maximum Path Sum" problem on LeetCode. The task is to find the maximum path sum in a binary tree, where a path can start and end at any node in the tree, and it does not necessarily have to go through the root node.

Approach:
The solution uses a recursive approach to traverse the binary tree and calculate the maximum path sum for each node and its subtrees. The algorithm is based on the idea of finding the maximum sum that can be extended from each node to its parent.

1. The `maxPathSum` function is the main function that initiates the recursive traversal of the binary tree. It initializes a global variable `maxSum` to store the maximum path sum found so far and calls the `maxPathSumRecursive` function with the root of the tree.

2. The `maxPathSumRecursive` function takes a TreeNode as input and returns the maximum sum that can be extended from the current node. If the node is null (i.e., a leaf node or a null child of a leaf node), it returns 0, as there is no path to extend.

3. In the recursive calls, for each node, the function calculates the maximum path sum for its left and right subtrees using the following steps:
   a. Recursively call the function for the left and right children of the current node.
   b. Calculate the maximum sum of either the left or right subtree. If the sum is negative, it means that it's better to ignore the subtree (i.e., set the sum to 0) since including it in the path would reduce the overall sum.
   
4. After calculating the maximum sums for the left and right subtrees, the function calculates the current path sum by adding the node's value to the maximum sums of both subtrees and the node itself. It then updates the `maxSum` variable with the maximum of the current sum and the global `maxSum`.

5. The function finally returns the maximum sum that can be extended from the current node to its parent. This value is used in the recursive call for the parent node.

Note:
int leftSum = Math.max(maxPathSumRecursive(node.left), 0);

In this line, we are calculating the maximum sum that can be extended from the left subtree of the current node.

maxPathSumRecursive(node.left): This part makes a recursive call to the maxPathSumRecursive function with the left child of the 
urrent node (node.left) as the input. This recursive call calculates the maximum sum that can be extended from the left subtree 
rooted at node.left. It's important to note that this recursive call computes the maximum path sum in the left subtree.

Math.max(..., 0): This part takes two arguments and returns the larger of the two. The first argument is the maximum path 
sum calculated from the left subtree, and the second argument is 0. We use 0 here to handle the case where the maximum sum from 
the left subtree is negative. If the maximum sum is negative, it means that it's better to ignore the left subtree and set the 
sum to 0 instead. This is because including a negative sum in the path would reduce the overall sum. By taking the maximum of the calculated sum and 0, we ensure that we consider the left subtree only if its sum is non-negative, effectively excluding it from 
the path if it has a negative contribution.

Time Complexity:
The algorithm visits each node of the binary tree once, so the time complexity is O(N), where N is the number of nodes in the tree.

Space Complexity:
The space complexity is O(H), where H is the height of the binary tree. In the worst case, the height of the tree can be N (in case of a skewed tree), resulting in a space complexity of O(N). However, in a balanced binary tree, the height is log(N), resulting in a space complexity of O(log N). The space is used for the recursive call stack during the depth-first traversal.

Code:
class Solution {
    int maxSum = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        maxPathSumRecursive(root);
        return maxSum;
    }

    private int maxPathSumRecursive(TreeNode node) {
        if (node == null) {
            return 0;
        }

        // Calculate the maximum path sum for the left and right subtrees
        // Here taking max with 0 is to avoid negative values coming from both subtrees
        int leftSum = Math.max(maxPathSumRecursive(node.left), 0);
        int rightSum = Math.max(maxPathSumRecursive(node.right), 0);

        // Update the maximum path sum if the current path is the maximum
        int currentSum = node.val + leftSum + rightSum;
        maxSum = Math.max(maxSum, currentSum);

        // Return the maximum sum that can be extended from the current node
        return node.val + Math.max(leftSum, rightSum);
    }
}

--------------------------------------------------------------

11. Binary Tree Zigzag Level Order Traversal - LeetCode #103

Given the root of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between). 

Example 1:
Input: root = [3,9,20,null,null,15,7]
Output: [[3],[20,9],[15,7]]

Example 2:
Input: root = [1]
Output: [[1]]

Example 3:
Input: root = []
Output: []

Approach:
1. We start with an empty list `result` that will store the final zigzag level order traversal.
2. If the root of the tree is null, we return the empty `result`.
3. We use a double-ended queue (`Deque`) called `queue` to perform a level order traversal of the binary tree.
4. We add the root node to the `queue` to start the traversal.
5. We maintain a boolean variable `isLeftToRight` to keep track of whether we should add nodes' values from left-to-right or right-to-left at each level.
6. While the `queue` is not empty, we process each level:
   a. Get the current level size to process the nodes at the current level only.
   b. Create a new `Deque` called `currentLevel` to store the values of the nodes at the current level in zigzag order.
   c. For each node at the current level, we perform the following steps:
      - Poll the node from the front of the `queue`.
      - If `isLeftToRight` is true, add the node's value at the end of the `currentLevel` using `currentLevel.offerLast(currentNode.val)`.
      - If `isLeftToRight` is false, add the node's value at the beginning of the `currentLevel` using `currentLevel.offerFirst(currentNode.val)`.
      - Add the left and right children of the current node to the `queue`.
   d. After processing all nodes at the current level, add the `currentLevel` to the `result`.
   e. Toggle the `isLeftToRight` flag to prepare for the next level.
7. Finally, the `result` will contain the zigzag level order traversal of the binary tree, and we return it.

Time Complexity (TC):
- The code performs a level order traversal of the binary tree, visiting each node once. Therefore, the time complexity is O(N), where N is the number of nodes in the binary tree.

Space Complexity (SC):
- The space complexity is O(N), where N is the number of nodes in the binary tree. This is because we use a double-ended queue `queue` to perform the level order traversal, and in the worst case, all nodes of the binary tree can be in the `queue` at the same time. Additionally, we use `currentLevel` to store the values at each level, and it can also contain all nodes in the worst case. The `result` list will contain N elements, each representing the values at each level. Hence, the overall space complexity is O(N).

Code:
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> result = new ArrayList<>();

        if (root == null) {
            return result;
        }

        Deque<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        boolean isLeftToRight = true;

        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            Deque<Integer> currentLevel = new LinkedList<>();

            for (int i = 0; i < levelSize; i++) {
                TreeNode currentNode = queue.poll();

                if (isLeftToRight) {
                    currentLevel.offerLast(currentNode.val); 
                    // Add node value at the end
                } else {
                    currentLevel.offerFirst(currentNode.val); 
                    // Add node value at the beginning
                }

                if (currentNode.left != null) {
                    queue.offer(currentNode.left);
                }

                if (currentNode.right != null) {
                    queue.offer(currentNode.right);
                }
            }

            result.add(new ArrayList<>(currentLevel));
            isLeftToRight = !isLeftToRight;
        }

        return result;
    }
}
--------------------------------------------------------------

12. Invert Binary Tree - LeetCode #226

Given the root of a binary tree, invert the tree, and return its root.

Example 1:

Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]

Example 2:

Input: root = [2,1,3]
Output: [2,3,1]
Example 3:

Input: root = []
Output: []


Approach:
The approach used is a simple recursive approach. The `invertTree` method is a wrapper function that calls the `invert` method, 
which recursively inverts the left and right subtrees of each node.

1. The `invert` method is a recursive function that takes a `TreeNode` as input. If the input node `root` is null (i.e., the 
tree is empty), the function returns immediately.

2. If the input node `root` is not null, it proceeds with the swapping process. It stores the left subtree of `root` in a 
temporary `TreeNode` variable `left`, and then assigns `root.right` to `root.left` and `left` to `root.right`. This effectively 
swaps the left and right subtrees of the current node.

3. After the swap, the `invert` method is called recursively on the new left and right subtrees to invert them as well.

4. The `invertTree` method is the entry point, and it calls the `invert` method with the root of the tree to start the inversion process.

Time Complexity:
The time complexity of this approach is O(N), where N is the number of nodes in the binary tree. We visit each node once during 
the recursion, and the time taken to process each node is constant.

Space Complexity:
The space complexity is O(H), where H is the height of the binary tree. In the worst case, the recursion stack will have a maximum 
depth equal to the height of the tree. In a balanced binary tree, the height is log(N), but in the worst case (skewed tree), the 
height is N.

Code:
class Solution {
    public TreeNode invertTree(TreeNode root) {
        invert(root);
        return root;
    }
    public void invert(TreeNode root){
        if(root == null)
            return;
        TreeNode left = root.left;
        root.left = root.right;
        root.right = left;
        invert(root.left);
        invert(root.right);
    }
}

--------------------------------------------------------------

13. Same Tree - LeetCode #100

Given the roots of two binary trees p and q, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

Example 1:

Input: p = [1,2,3], q = [1,2,3]
Output: true

Example 2:

Input: p = [1,2], q = [1,null,2]
Output: false

Example 3:

Input: p = [1,2,1], q = [1,1,2]
Output: false

Approach:

1. The `isSameTree` function is a recursive method that takes two `TreeNode` objects `p` and `q` as input and returns a boolean value indicating whether the trees are identical or not.

2. The base cases of the recursion are:
   - If both `p` and `q` are null, it means both subtrees are empty, and they are considered identical. The function returns true 
in this case.
   - If either `p` or `q` is null but not both, it means the subtrees differ in size, and they cannot be identical. The function 
returns false in this case.
   - If the values of the current nodes `p` and `q` are not equal, they cannot be identical, and the function returns false.

3. If none of the base cases is satisfied, it means both `p` and `q` are non-null nodes with the same value. In this case, 
the function recursively checks whether the left subtrees of `p` and `q` are identical and also checks whether the right subtrees 
of `p` and `q` are identical. It returns the logical AND of these two checks.

Time Complexity:
The time complexity of this approach is O(N), where N is the total number of nodes in the binary tree. This is because in the 
worst case, we need to visit all nodes in both trees to compare them.

Space Complexity:
The space complexity is O(H), where H is the height of the binary tree. In the worst case, the recursion stack will have a 
maximum depth equal to the height of the tree. In a balanced binary tree, the height is log(N), but in the worst 
case (skewed tree), the height is N.

Code:
public boolean isSameTree(TreeNode p, TreeNode q) {
    // If both trees are null, they are considered the same
    if (p == null && q == null) {
        return true;
    }
    // If one tree is null and the other is not, they are not the same
    if (p == null || q == null) {
        return false;
    }
    // If the values of the current nodes are different, they are not the same
    if (p.val != q.val) {
        return false;
    }
    // Recursively check if the left and right subtrees are the same
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
}

--------------------------------------------------------------

14. Binary Tree Right Side View - LeetCode #199

Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see 
ordered from top to bottom.

Example 1:


Input: root = [1,2,3,null,5,null,4]
Output: [1,3,4]
Example 2:

Input: root = [1,null,3]
Output: [1,3]
Example 3:

Input: root = []
Output: []

To solve the Binary Tree Right Side View problem, we can use a level-order traversal (Breadth-First Search) of the binary tree. 
The idea is to visit each level of the tree and keep track of the rightmost node at each level. We will use a queue to perform the 
level-order traversal.

Here's the step-by-step approach:

1. Initialize an empty list called `result` to store the right side view of the binary tree.

2. If the `root` is null (i.e., the binary tree is empty), return an empty list `result`.

3. Create a queue to perform the level-order traversal. Add the `root` node to the queue.

4. Start the level-order traversal using a while loop until the queue becomes empty.

5. Inside the loop, get the size of the queue (i.e., the number of nodes in the current level).

6. Iterate through the nodes of the current level. For each node, dequeue it and check if it is the last node in the current level. 
If it is, add its value to the `result` list. Then, enqueue the left and right child nodes (if they exist) into the queue for the 
next level.

7. After processing all nodes in the current level, the rightmost node's value has been added to the `result` list. Repeat the 
process for the next levels until the queue becomes empty.

8. Return the `result` list containing the right side view of the binary tree.

Here's the Java code implementing the above approach:

```java

class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<>();

        if (root == null) {
            return result;
        }

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();

            for (int i = 0; i < levelSize; i++) {
                TreeNode currentNode = queue.poll();

                // If it is the last node in the current level, add its value to the result list
                if (i == levelSize - 1) {
                    result.add(currentNode.val);
                }

                // Enqueue the left and right child nodes (if they exist)
                if (currentNode.left != null) {
                    queue.offer(currentNode.left);
                }
                if (currentNode.right != null) {
                    queue.offer(currentNode.right);
                }
            }
        }

        return result;
    }
}
```

The time complexity of this solution is O(N), where N is the number of nodes in the binary tree, as we visit each node once during 
the level-order traversal. 
The space complexity is O(W), where W is the maximum width of the binary tree (i.e., the maximum number of nodes at any level). 
In the worst case, the width of the binary tree can be N/2, so the space complexity can be O(N).

--------------------------------------------------------------

15. Binary Tree Preorder Traversal - LeetCode #144

PREORDER = ROOT->LEFT->RIGHT
Code:
class Solution {
    List<Integer> arr = new ArrayList<>();
    public List<Integer> preorderTraversal(TreeNode root) {
        preorder(root);
        return arr;
        
    }
    public void preorder(TreeNode root){
        if(root == null)
            return;
        arr.add(root.val);
        preorder(root.left);
        preorder(root.right);     
    }
}

--------------------------------------------------------------

16. Binary Tree Postorder Traversal - LeetCode #145


POSTORDER - LEFT->RIGHT->ROOT
class Solution {
    List<Integer> arr = new ArrayList<>();
    public List<Integer> postorderTraversal(TreeNode root) {
        postorder(root);
        return arr;
    }
     public void postorder(TreeNode root){
        if(root == null)
            return;
        postorder(root.left);
        postorder(root.right);   
        arr.add(root.val);
    }
}

--------------------------------------------------------------

17. Binary Search Tree Iterator - LeetCode #173

--------------------------------------------------------------

18. Kth Smallest Element in a BST - LeetCode #230

Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.

Example 1:
Input: root = [3,1,4,null,2], k = 1
Output: 1

Example 2:
Input: root = [5,3,6,2,4,null,null,1], k = 3
Output: 3

Approach:
1. We maintain two variables: `count` to keep track of the number of nodes visited during the inorder traversal and `ans` to store 
the kth smallest element found so far.
2. We start the inorder traversal from the root of the BST and keep traversing left recursively until we reach the leftmost node, 
which will be the smallest element in the BST.
3. At each node, we increment the `count` by 1 and check if it matches the target value `k`.
4. If `count` is equal to `k`, it means we have found the kth smallest element, so we update `ans` with the value of the current node.
5. After visiting the left subtree and processing the current node, we then move to the right subtree and continue the inorder 
traversal.
6. The process is repeated until we find the kth smallest element or traverse the entire BST.

Time Complexity (TC):
- The time complexity of the `kthSmallest` function is O(N), where N is the number of nodes in the BST. This is because we perform 
an inorder traversal of the entire BST, visiting each node once.

Space Complexity (SC):
- The space complexity of the `kthSmallest` function is O(H), where H is the height of the BST. In the worst case, the height of 
the BST can be equal to N (for a skewed tree), resulting in O(N) space complexity due to the recursive function calls. However, 
for a balanced BST, the height is log(N), resulting in O(log(N)) space complexity for the function calls. Additionally, we use 
two extra variables `count` and `ans`, which occupy constant space, so their contribution to the space complexity is negligible.

class Solution {
    int count = 0, ans = 0;
    public int kthSmallest(TreeNode root, int k) {
        inorder(root, k);
        return ans;
    }

    public void inorder(TreeNode root, int k) {
        if (root == null) {
            return;
        }

        inorder(root.left, k);
        count += 1;
        if (k == count) {
            ans = root.val;
            return;
        }
        inorder(root.right, k);
    }
}

--------------------------------------------------------------

19. Subtree of Another Tree - LeetCode #572

Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.

A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. 
The tree could also be considered as a subtree of itself.

Example 1:

Input: root = [3,4,5,1,2], subRoot = [4,1,2]
Output: true

Example 2:
Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
Output: false

Approach:

1. The `isSubtree` function is the main function that takes two `TreeNode` objects `root` and `subRoot` as input and returns 
a boolean value indicating whether `subRoot` is a subtree of `root`.

2. The base case of the recursion is:
   - If the `root` is null, it means there are no more nodes to compare, and the function returns false.

3. In the recursive part:
   - The function first checks if the `subRoot` is identical to the current `root` tree by calling the `isSameTree` function. 
If they are identical, it means `subRoot` is a subtree of `root`, and the function returns true.
   - If the `subRoot` is not identical to the current `root`, the function recursively checks if `subRoot` is a subtree of the 
left subtree of `root` or the right subtree of `root`. It returns the logical OR of these two recursive checks.

4. The `isSameTree` function is a helper function that checks if two trees `p` and `q` are identical. It is similar to the 
`isSameTree` function used in the previous solution.

Time Complexity:
The time complexity of this approach is O(M*N), where M is the number of nodes in the `root` tree and N is the number of 
nodes in the `subRoot` tree. In the worst case, we need to compare the `subRoot` tree with each possible subtree of the `root` tree.

Space Complexity:
The space complexity is O(H) due to the recursion stack, where H is the height of the binary tree. In the worst case, the 
recursion stack will have a maximum depth equal to the height of the `root` tree. In a balanced binary tree, the height is log(M), 
but in the worst case (skewed tree), the height is M.

Code:

class Solution {
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        if (root == null) {
            return false;
        }

        if (isSameTree(root, subRoot)) {
            return true;
        }

        return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);
    }

    private boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        }

        if (p == null || q == null) {
            return false;
        }

        if (p.val != q.val) {
            return false;
        }

        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
--------------------------------------------------------------

20. Binary Tree Cameras - LeetCode #968

--------------------------------------------------------------
--------------------------------------------------------------
#Array

2. **Best Time to Buy and Sell Stock**
   - LeetCode #121

You are given an array prices where prices[i] is the price of a given stock on the ith day.

You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.


Example 1:

Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
Example 2:

Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transactions are done and the max profit = 0.

Approach:
1. We initialize two variables: `minAmountToBuy` and `maxProfit`. The `minAmountToBuy` variable is set to `Integer.MAX_VALUE`, 
which represents the maximum possible value in Java. This variable will keep track of the minimum stock price encountered so far. 
The `maxProfit` variable is initialized to 0, and it will store the maximum profit that can be obtained.
2. We iterate through the array of stock prices using a loop. For each price, we compare it with the `minAmountToBuy`. If the 
current price is less than `minAmountToBuy`, it means this is a potential buying point because we want to buy at the lowest 
possible price. So, we update the `minAmountToBuy` to the current price.
3. Next, we calculate the profit that can be obtained if we sell the stock at the current price (`prices[i] - minAmountToBuy`). We 
then compare this profit with the `maxProfit` and update `maxProfit` to the maximum of the two values. This way, we keep track of the 
maximum profit obtained so far.
4. Finally, after iterating through all the stock prices, we have the maximum profit stored in the `maxProfit` variable. We return 
this value as the result.

Time Complexity (TC):
The given algorithm uses a single loop to iterate through the array of stock prices. Hence, the time complexity is O(n), where n 
is the number of stock prices in the input array.

Space Complexity (SC):
The algorithm uses only a constant amount of extra space to store the `minAmountToBuy` and `maxProfit` variables. Therefore, 
the space complexity is O(1), which is constant space.


Code:
class Solution {
    public int maxProfit(int[] prices) {
        int minAmountToBuy = Integer.MAX_VALUE;
        int maxProfit = 0;
        for(int i = 0; i < prices.length; i++){
            if(prices[i] < minAmountToBuy){
                minAmountToBuy = prices[i];
            }
            maxProfit = Math.max(maxProfit, prices[i] - minAmountToBuy);
        }
        return maxProfit;
    }
}

--------------------------------------------------------------
3. **Contains Duplicate**
   - LeetCode #217

Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

Example 1:

Input: nums = [1,2,3,1]
Output: true
Example 2:

Input: nums = [1,2,3,4]
Output: false
Example 3:

Input: nums = [1,1,1,3,3,4,3,2,4,2]
Output: true

Code:
class Solution {
    public boolean containsDuplicate(int[] nums) {
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < nums.length; i++) {
            if (set.contains(nums[i])) {
                return true;
            }
            set.add(nums[i]);
        }
        return false;
    }
}

--------------------------------------------------------------
4. **Product of Array Except Self**
   - LeetCode #238

Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].

The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.

You must write an algorithm that runs in O(n) time and without using the division operation.

Example 1:

Input: nums = [1,2,3,4]
Output: [24,12,8,6]
Example 2:

Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]

Approach:
1. The code first creates two arrays `pre` and `suff` to store the prefix product and suffix product of the elements, respectively.
2. The `pre` array stores the product of all elements to the left of the current element.
3. The `suff` array stores the product of all elements to the right of the current element.
4. After computing the prefix and suffix product arrays, the code then calculates the final answer by taking the product of the corresponding prefix and suffix values for each element.

Time Complexity (TC):
- The code traverses the input array three times: once for calculating the `pre` array, once for calculating the `suff` array, and once for calculating the final answer.
- Each traversal takes linear time O(n), where n is the size of the input array.
- Therefore, the overall time complexity is O(n).

Space Complexity (SC):
- The code uses three additional arrays: `pre`, `suff`, and `ans`, each of size n, where n is the size of the input array.
- Therefore, the space complexity is O(n).

Example:
For the input array [1, 2, 3, 4], the code calculates the prefix and suffix arrays as follows:
- `pre` = [1, 2, 6, 24] (product of elements to the left)
- `suff` = [24, 24, 12, 4] (product of elements to the right)

Then, it calculates the final answer `ans` as follows:
- `ans` = [24, 12, 8, 6]

Each element in the `ans` array is the product of all elements in the input array except for the element at that index.

Code:
class Solution {
    public int[] productExceptSelf(int[] nums) {
        // [1,2,3,4]
        // [9,8,7,6]
        // pre - [1,3,6,10]
        // suff - [10,9,7,4]

        // [1,2,3,4]
        // [24,12,8,6]

        // [1,2,6,20]
        // [24,24,12,4]
        // [1,2,3,4]
        // pre = [1, 1, 2, 6]
        // suff = [24 ,12 ,4 ,1]
        int n = nums.length;
        int pre[] = new int[n];
        int suff[] = new int[n];
        pre[0] = nums[0];
        suff[n - 1] = nums[n-1];
        
        for(int i = 1; i < n; i++) {
            pre[i] = pre[i - 1] * nums[i];
        }
        for(int i = n - 2; i >= 0; i--) {
            suff[i] = suff[i + 1] * nums[i];
        }
        
        int ans[] = new int[n];
        ans[0] = suff[1];
        ans[n-1] = pre[n-2];
        for(int i = 1; i < n-1; i++) {
            ans[i] = pre[i-1] * suff[i+1];
        }
        return ans;
    }
}

--------------------------------------------------------------
5. **Maximum Subarray**
   - LeetCode #53

Given an integer array nums, find the 
subarray with the largest sum, and return its sum.

Example 1:

Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: The subarray [4,-1,2,1] has the largest sum 6.
Example 2:

Input: nums = [1]
Output: 1
Explanation: The subarray [1] has the largest sum 1.
Example 3:

Input: nums = [5,4,-1,7,8]
Output: 23
Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.

Kadane's Algorithm:
- The algorithm iterates through the array from left to right, keeping track of the current sum (`currentSum`) and the maximum sum (`maxSum`) seen so far.
- For each element, the algorithm updates the `currentSum` by considering whether to include the current element in the subarray or 
start a new subarray from the current element.
- If the `currentSum` becomes negative, it means that including the current element in the subarray will only decrease the sum. So, 
the algorithm resets the `currentSum` to the current element to start a new potential subarray.
- The algorithm updates the `maxSum` at each step to keep track of the maximum sum found so far.

The time complexity of this approach is O(n) because it iterates through the array once. The space complexity is O(1) because it 
only uses a constant amount of additional space.

Divide and Conquer Approach:
The divide and conquer approach to solve the maximum subarray problem is more complex and involves recursively dividing the array 
into subproblems, finding maximum subarrays in the left and right halves, and then combining them to find the maximum subarray that 
spans the mid-point of the array.

The time complexity of the divide and conquer approach is also O(n), but it involves a more intricate implementation and is 
generally less straightforward compared to Kadane's algorithm. While it's an interesting exercise to implement the divide and 
conquer approach, the Kadane's algorithm should be preferred in practice due to its simplicity and efficiency.


Code:
class Solution {
    public int maxSubArray(int[] nums) {
        int maxSum = Integer.MIN_VALUE; 
        // Initialize the maximum sum with the first element of the array
        int currentSum = Integer.MIN_VALUE; 
        // Initialize the current sum with the first element of the array
        int n = nums.length;

        for (int i = 0; i < n; i++) {
            // Calculate the current sum considering the current element
            // Choose either the current element itself or the sum of the current 
            // element and the previous currentSum
            // Update the currentSum to track the maximum sum seen so far

            if (currentSum < 0) {
                currentSum = nums[i];
            } else {
                currentSum = currentSum + nums[i];
            }

            // Update the maximum sum if the currentSum is greater
            if (currentSum > maxSum) {
                maxSum = currentSum;
            }
        }

        return maxSum;
    }
}

--------------------------------------------------------------
6. **Move Zeroes**
   - LeetCode #283

Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.

Example 1:

Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]
Example 2:

Input: nums = [0]
Output: [0]

Time Complexity (TC):
The given code uses a single loop that iterates through the array once, and for each non-zero element encountered, it performs a 
constant-time swap operation. Therefore, the time complexity of this code is O(n), where n is the size of the input array `nums`. 
This is because the time taken by the loop is directly proportional to the number of elements in the array.

Space Complexity (SC):
The given code uses a constant amount of extra space. The space used does not depend on the size of the input array. The only 
extra variables used are `i`, `j`, and `temp`, which are integers and do not depend on the size of the array. Hence, the space 
complexity of this code is O(1), which is constant space.


Code:
public void moveZeroes(int[] nums) {
    int i = 0;
    int j = 0;
    while (i < nums.length) {
        if (nums[i] != 0) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
            j++;
        }
        i++;
    }
}

--------------------------------------------------------------
10. **Group Anagrams**
    - LeetCode #49

Given an array of strings strs, group the anagrams together. You can return the answer in any order.

An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

Example 1:

Input: strs = ["eat","tea","tan","ate","nat","bat"]
Output: [["bat"],["nat","tan"],["ate","eat","tea"]]
Example 2:

Input: strs = [""]
Output: [[""]]
Example 3:

Input: strs = ["a"]
Output: [["a"]]


Approach:

1. Create a HashMap with a key of type String and value of type List of Strings. This will be used to group anagrams together.

2. Iterate through each word in the input array `strs`.
   - Create a character array for the word and sort it alphabetically.
   - Convert the sorted character array back to a string. This will be the key for the HashMap.
   - If the key does not exist in the HashMap, create a new entry with an empty list as the value.
   - Add the original word to the list corresponding to the key in the HashMap.

3. After processing all words, the HashMap will contain groups of anagrams together.

4. Return the values of the HashMap as the final answer.
TC & SC:
The function `groupAnagrams` will group the anagrams together and return the result as a list of lists of strings. 
The time complexity of this solution is O(N * K * log(K)), where N is the number of words in the input array, and K is the 
maximum length of a word. The space complexity is O(N) to store the anagram groups in the HashMap.

Code:

```java
import java.util.*;

public class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> anagramMap = new HashMap<>();

        for (String word : strs) {
            char[] chars = word.toCharArray();
            Arrays.sort(chars);
            String sortedKey = new String(chars);

            anagramMap.putIfAbsent(sortedKey, new ArrayList<>());
            anagramMap.get(sortedKey).add(word);
        }

        return new ArrayList<>(anagramMap.values());
    }
}
```


--------------------------------------------------------------
11. **Valid Sudoku**
    - LeetCode #36

--------------------------------------------------------------
13. **Minimum Size Subarray Sum**
    - LeetCode #209

Given an array of positive integers nums and a positive integer target, return the minimal length of a 
subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.

Example 1:
Input: target = 7, nums = [2,3,1,2,4,3]
Output: 2
Explanation: The subarray [4,3] has the minimal length under the problem constraint.

Example 2:
Input: target = 4, nums = [1,4,4]
Output: 1

Example 3:
Input: target = 11, nums = [1,1,1,1,1,1,1,1]
Output: 0


Approach:
The approach used here is the sliding window technique. We use two pointers, `start` and `end`, to represent the current subarray. 
We initialize both pointers to 0. We also maintain a `sum` variable to keep track of the sum of the current subarray and a `min` 
variable to store the minimum length found so far.

1. Initialize `start` and `end` to 0, `sum` to 0, and `min` to `Integer.MAX_VALUE`.

2. Start iterating from the `end` pointer, and at each step, add the current element `nums[end]` to the `sum`.

3. Check if the `sum` is greater than or equal to the `target`.
   - If it is, update the `min` to be the minimum of `min` and the length of the current subarray `(end - start + 1)`.
   - Move the `start` pointer to the right and subtract the element `nums[start]` from the `sum` until `sum` becomes less than `target`.

4. Continue steps 2 and 3 until the `end` pointer reaches the end of the array.

5. Finally, return the `min` value. If no subarray is found whose sum is greater than or equal to `target`, return 0.

Time Complexity:
The `start` and `end` pointers each move at most `n` steps (where `n` is the length of the `nums` array). So the time complexity is O(n).

Space Complexity:
The space complexity is O(1) because we are not using any extra data structures that grow with the input size.

Overall, this algorithm efficiently finds the minimum length of a contiguous subarray with a sum greater than or equal to the given `target` value.

Code:
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int start = 0, end = 0;
        int sum = 0;
        int min = Integer.MAX_VALUE;
        
        for(end = 0; end < nums.length; end++){
            sum += nums[end];
            while(sum >= target){
                min = Math.min(min, (end-start+1));
                sum -= nums[start++];
            }
        }
        
        return min == Integer.MAX_VALUE ? 0 : min;
    }
}

--------------------------------------------------------------
16. **Set Matrix Zeroes**
    - LeetCode #73

Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.
You must do it in place.

Example 1:
Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]
Output: [[1,0,1],[0,0,0],[1,0,1]]

Example 2:
Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]



--------------------------------------------------------------
17. **Jump Game**
    - LeetCode #55

You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.

Return true if you can reach the last index, or false otherwise.

Example 1:
Input: nums = [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.

Example 2:
Input: nums = [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.

To solve this problem, we can use a greedy approach to determine if it's possible to reach the last index.

**Approach:**

1. Start from the first index of the array.

2. Initialize a variable `maxReach` to store the maximum index that we can reach from the current position.

3. Loop through the array from the first index up to the last index (excluding the last index), and update the `maxReach` at each step.

4. At each step, check if the current index is greater than or equal to the `maxReach`. If it is, then we cannot progress further, and we return `false`.

5. If the loop completes without encountering any situation where we cannot progress further, it means we can reach the last index, and we return `true`.

**Time Complexity (TC):**
The algorithm iterates through the array once, so the time complexity is O(n), where n is the length of the input array `nums`.

**Space Complexity (SC):**
The algorithm uses a constant amount of extra space for variables, so the space complexity is O(1), which is constant. No additional data structures are used that grow with the input size.

**Java Code:**

```java
public boolean canJump(int[] nums) {
    int n = nums.length;
    int maxReach = 0;

    for (int i = 0; i < n - 1; i++) {
        maxReach = Math.max(maxReach, i + nums[i]);
        if (maxReach <= i) {
            return false;
        }
    }

    return true;
}
```


--------------------------------------------------------------
18. **Majority Element**
    - LeetCode #169

Given an array nums of size n, return the majority element.

The majority element is the element that appears more than n / 2 times. You may assume that the majority element always exists in the array.

Example 1:
Input: nums = [3,2,3]
Output: 3

Example 2:
Input: nums = [2,2,1,1,1,2,2]
Output: 2

**Approach:**

1. Initialize two variables: `majorityEle` and `count`. Set `majorityEle` to the first element of the array `nums[0]`, and `count` to 1.
This is because the first element is a potential candidate for the majority element, and we've seen it once.

2. Loop through the array starting from the second element (index `1`) up to the last element.

3. For each element `nums[i]` in the array, compare it with the `majorityEle`. If they are equal, increment the `count` by 1, 
indicating that we've seen another occurrence of a potential majority element.

4. If the current element `nums[i]` is not equal to the `majorityEle`, decrement the `count` by 1. This indicates that we're 
canceling out one occurrence of the current element as well as one occurrence of the potential majority element. If the `count` 
becomes 0, it means we've canceled out all occurrences of the previous majority element and its counterpart elements.

5. In this case, update the `majorityEle` to the current element `nums[i]`, and reset the `count` to 1. This new element becomes 
the new potential candidate for the majority element.

6. Repeat steps 3 to 5 for all elements in the array.

7. After looping through the entire array, the `majorityEle` will contain the element that is the majority element.

8. Return `majorityEle` as the result.

**Time Complexity (TC):**
The algorithm iterates through the entire array once, so the time complexity is O(n), where n is the length of the input array `nums`.

**Space Complexity (SC):**
The algorithm uses a constant amount of extra space for the `majorityEle` and `count` variables, so the space complexity is O(1), 
which is constant. No additional data structures are used that grow with the input size.

Code:
class Solution {
    public int majorityElement(int[] nums) {
        int majorityEle = nums[0];
        int count = 1;

        for (int i = 1; i < nums.length; i++) {
            if (majorityEle == nums[i]) {
                count++;
            } else {
                count--;
                if (count == 0) {
                    majorityEle = nums[i];
                    count = 1;
                }
            }
        }

        return majorityEle;
    }
}

--------------------------------------------------------------
19. **Missing Number**
    - LeetCode #268

Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.

Example 1:

Input: nums = [3,0,1]
Output: 2
Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.
Example 2:

Input: nums = [0,1]
Output: 2
Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.
Example 3:

Input: nums = [9,6,4,2,3,5,7,0,1]
Output: 8
Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.

**Approach:**

The algorithm uses the XOR operation to find the missing number. The key property of XOR is that it returns 1 for different bits 
and 0 for identical bits.

1. Initialize a variable `x` to 0.

2. Iterate through the given `nums` array and perform XOR operation with each element `l`. This operation will effectively cancel out 
the numbers that appear twice in the array, leaving us with the XOR result of the missing number and 0.

3. Now, iterate from 0 to `nums.length` (both inclusive) and perform XOR operation with each `i`. This operation will cancel out all 
the numbers from 0 to n, leaving us with the XOR result of the missing number.

4. Return the value of `x` as the result, which is the missing number.

**Example:**

Let's take an example for better understanding. Consider the array `nums = [3, 0, 1]`.

1. Initialize `x = 0`.
2. XOR of `x` with each element of the array: `x ^= 3 ^ 0 ^ 1 = 2`.
3. XOR of `x` with each number from 0 to 3: `x ^= 2 ^ 0 ^ 1 ^ 2 ^ 3 = 0`.

The result is 0, which is the missing number.

**Time Complexity (TC):**
The algorithm iterates through the `nums` array and also through the numbers from 0 to n, where n is the length of the array. So 
the time complexity is O(n).

**Space Complexity (SC):**
The algorithm uses a constant amount of extra space for the variable `x`, so the space complexity is O(1), which is constant. 
No additional data structures are used that grow with the input size.

Code:
class Solution {
    public int missingNumber(int[] nums) {
        int x = 0;
        for(int l : nums){
            x ^= l;
        }
        for(int i = 0; i <= nums.length; i++){
            x ^= i;
        }
        return x;
    }
}

--------------------------------------------------------------
--------------------------------------------------------------

#Stack

1. **Valid Parentheses**
   - LeetCode #20

2. **Min Stack**
   - LeetCode #155

3. **Evaluate Reverse Polish Notation**
   - LeetCode #150

4. **Decode String**
   - LeetCode #394

5. **Longest Valid Parentheses**
   - LeetCode #32

6. **Implement Queue using Stacks**
   - LeetCode #232

7. **Next Greater Element I**
   - LeetCode #496

8. **Daily Temperatures**
   - LeetCode #739

9. **Remove All Adjacent Duplicates In String**
   - LeetCode #1047

10. **Backspace String Compare**
    - LeetCode #844

11. **Implement Stack using Queues**
    - LeetCode #225

12. **Online Stock Span**
    - LeetCode #901

13. **Valid Parenthesis String**
    - LeetCode #678

14. **Remove Outermost Parentheses**
    - LeetCode #1021

15. **Score of Parentheses**
    - LeetCode #856

16. **Largest Rectangle in Histogram**
    - LeetCode #84

17. **Baseball Game**
    - LeetCode #682

18. **Flood Fill**
    - LeetCode #733

19. **Maximal Rectangle**
    - LeetCode #85

20. **Trapping Rain Water**
    - LeetCode #42

--------------------------------------------------------------
--------------------------------------------------------------

#Queue

1. **Implement Queue using Stacks**
   - LeetCode #232

2. **Queue Reconstruction by Height**
   - LeetCode #406

3. **Design Circular Queue**
   - LeetCode #622

4. **Sliding Window Maximum**
   - LeetCode #239

5. **Implement Stack using Queues**
   - LeetCode #225

6. **Moving Average from Data Stream**
   - LeetCode #346

7. **Number of Recent Calls**
   - LeetCode #933

8. **Design Circular Deque**
   - LeetCode #641

9. **The Maze**
   - LeetCode #490

10. **Shortest Path in Binary Matrix**
    - LeetCode #1091

11. **Perfect Squares**
    - LeetCode #279

12. **Binary Tree Right Side View**
    - LeetCode #199

13. **Rotten Oranges**
    - LeetCode #994

14. **As Far from Land as Possible**
    - LeetCode #1162

15. **Moving Average from Data Stream**
    - LeetCode #346

16. **Snakes and Ladders**
    - LeetCode #909

17. **Open the Lock**
    - LeetCode #752

18. **Implement Stack using Queues**
    - LeetCode #225

19. **Sliding Window Maximum**
    - LeetCode #239

20. **Design Circular Queue**
    - LeetCode #622

--------------------------------------------------------------
--------------------------------------------------------------

##HashMap

--------------------------------------------------------------
1. Two Sum (Question #1):
Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.
Example:
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: The sum of 2 and 7 equals 9, so the output is [0,1].

public int[] twoSum(int[] nums, int target) {
    HashMap<Integer, Integer> map = new HashMap<>();

    for (int i = 0; i < nums.length; i++){
        int complement = target - nums[i];
        if (map.containsKey(complement)){
            return new int[] {map.get(complement), i};
        }
        map.put(nums[i], i);
    }
    return new int[]{};
}

-------------------------------------------------

2. **Valid Anagram**
   - LeetCode #242

4. **Contains Duplicate**
   - LeetCode #217

--------------------------------------------------

5. **Longest Substring Without Repeating Characters**

Given a string s, find the length of the longest 
substring without repeating characters.

Example 1:

Input: s = "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
Example 2:

Input: s = "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
Example 3:

Input: s = "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.

Approach:
- The function uses a sliding window approach with two pointers `i` and `j` to form the substring.
- The `i` pointer moves forward and expands the window to the right as long as there are no repeating characters in the window.
- The `j` pointer moves forward to shrink the window from the left when a repeating character is encountered.
- The `max` variable keeps track of the maximum length of the non-repeating substring encountered so far.
- A `HashSet` named `set` is used to store the characters of the current window to check for repetitions.

Time Complexity (TC):
- The function uses two pointers that move through the string from left to right without backtracking.
- So, each character is visited at most twice (once by each pointer), making the time complexity linear with respect to the length of 
the string.
- Therefore, the time complexity is O(n), where n is the length of the input string `s`.

Space Complexity (SC):
- The function uses a `HashSet` to store characters in the current window.
- In the worst case, the `HashSet` can contain all unique characters of the entire string, which would be O(n) space.
- Therefore, the space complexity is O(n), where n is the length of the input string `s`.

Code:
class Solution {
    public int lengthOfLongestSubstring(String s) {
        HashSet<Character> set = new HashSet<>();
        int i=0, j=0, max=0;
        while(i<s.length())
        {
            if(!set.contains(s.charAt(i)))
            {
               set.add(s.charAt(i));
               max= Math.max(max, set.size());
               i++;
            }
            else
            {
               set.remove(s.charAt(j));
               j++;
            }
        }
        return max;
    }
}

------------------------------------------------------------
   - LeetCode #3

6. **Most Common Word**
   - LeetCode #819

7. **Word Pattern**
   - LeetCode #290

8. **First Unique Character in a String**
   - LeetCode #387

9. **Minimum Window Substring**
   - LeetCode #76

10. **Group Anagrams**
    - LeetCode #49

11. **Subarray Sum Equals K**
    - LeetCode #560

12. **Intersection of Two Arrays II**
    - LeetCode #350

13. **Find All Anagrams in a String**
    - LeetCode #438

14. **Longest Consecutive Sequence**
    - LeetCode #128

15. **Isomorphic Strings**
    - LeetCode #205

---------------------------------------------------
16. **Top K Frequent Elements**
    - LeetCode #347

Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.
Note : frequent element is the element with maximum frequency
Example 1:

Input: nums = [1,1,1,2,2,3], k = 2
Output: [1,2]
Example 2:

Input: nums = [1], k = 1
Output: [1]

Approach:
1. First, it counts the frequency of each number in the array `nums` using a `frequencyMap`, which is a HashMap. The keys of this map are the numbers in the array, and the values are their corresponding frequencies.
2. Next, it creates a min-heap (PriorityQueue with a custom comparator) to store the k most frequent elements. The min-heap will keep the elements with the smallest frequencies at the top. We iterate through the `frequencyMap` and insert each frequency entry (key-value pair) into the min-heap.
3. While inserting elements into the min-heap, if the size of the heap becomes greater than k, we remove the smallest element (i.e., the element with the smallest frequency) from the heap to maintain the k most frequent elements at any time.
4. Finally, we extract the k most frequent elements from the min-heap and store them in the `result` array.

Time Complexity (TC):
1. Counting the frequency of each element in the array takes O(n) time, where n is the number of elements in the array.
2. Inserting each element into the min-heap takes O(log k) time, as the min-heap can have at most k elements.
3. We do this for all the n elements in the array, so the total time complexity is O(n log k).

Space Complexity (SC):
1. The space used by the `frequencyMap` is O(n), as it stores frequency entries for each element in the array.
2. The space used by the min-heap is O(k), as it can store at most k elements.
3. The space used by the `result` array is O(k) to store the k most frequent elements.
4. Therefore, the overall space complexity is O(n + k).

In conclusion, the given approach efficiently finds the k most frequent elements from the input array `nums` using a min-heap and has a time complexity of O(n log k) and a space complexity of O(n + k).

Code:
lass Solution {
    public int[] topKFrequent(int[] nums, int k) {
        // Count the frequency of each number
        Map<Integer, Integer> frequencyMap = new HashMap<>();
        for (int num : nums) {
            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);
        }

        // Create a min-heap to store the k most frequent elements
        PriorityQueue<Map.Entry<Integer, Integer>> minHeap = new PriorityQueue<>(
            (a, b) -> Integer.compare(a.getValue(), b.getValue())
        );

        // Insert elements into the min-heap
        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {
            minHeap.offer(entry);
            if (minHeap.size() > k) {
                minHeap.poll();
            }
        }

        // Extract the k most frequent elements from the min-heap
        int[] result = new int[k];
        int index = 0;
        while (!minHeap.isEmpty()) {
            result[index++] = minHeap.poll().getKey();
        }

        return result;
    }

}

---------------------------------------------------
17. **Sort Characters By Frequency**
    - LeetCode #451

18. **Minimum Index Sum of Two Lists**
    - LeetCode #599

19. **Two Sum IV - Input is a BST**
    - LeetCode #653

20. **Fraction to Recurring Decimal**
    - LeetCode #166


